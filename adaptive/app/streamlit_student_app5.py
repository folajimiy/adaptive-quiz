import streamlit as st
import pandas as pd
import os
import time
import matplotlib


# --- Session State ---
def initialize_session_state():
    defaults = {
        "started": False,
        "log": [],
        "bookmarked": set(),
        "score": {},
        "wrong_qs": [],
        "confidence_record": {},
        "topic_mastery": {},
        "asked_qs": set(),
        "submitted": False,
        "current_question": None,
        "current_reason": "",
        "review_mode": False,
        "remediation_queue": [],
        "session_id": str(int(time.time()))
    }
    for k, v in defaults.items():
        st.session_state.setdefault(k, v)

initialize_session_state()



# --- DIFFICULTY MODELING ---
def calculate_difficulty(df_logs):
    """Assigns and refines difficulty weights for each question."""
    bloom_base = {
        "Remember": 0.2,
        "Understand": 0.4,
        "Apply": 0.6,
        "Analyze": 0.75,
        "Evaluate": 0.9,
        "Create": 1.0
    }

    # Bloom-weight baseline
    df_logs["bloom_weight"] = df_logs["bloom_level"].map(bloom_base).fillna(0.5)

    # Empirical difficulty (1 - average accuracy per question)
    empirical = df_logs.groupby("question_id")["correct"].mean().to_dict()
    df_logs["empirical_difficulty"] = df_logs["question_id"].map(lambda x: 1 - empirical.get(x, 0.5))

    # Combined difficulty model
    df_logs["difficulty_score"] = 0.6 * df_logs["bloom_weight"] + 0.4 * df_logs["empirical_difficulty"]

    return df_logs




def calculate_learning_gains(df_logs):
    """Compute learning gain per student per Bloom level."""
    # Sort logs by time for temporal grouping
    df_logs = df_logs.sort_values(["session_id", "timestamp"])

    # Rolling mean of accuracy for learning curve
    df_logs["rolling_accuracy"] = (
        df_logs.groupby(["session_id", "bloom_level"])["correct"]
        .apply(lambda x: x.rolling(5, min_periods=1).mean())
        .reset_index(level=[0,1], drop=True)
    )

    # Compute overall learning gain
    gain = (
        df_logs.groupby(["session_id", "bloom_level"])["rolling_accuracy"]
        .agg(["first", "last"])
        .reset_index()
    )
    gain["learning_gain"] = (gain["last"] - gain["first"]) * 100
    return df_logs, gain

  ##
# --- Configuration ---
st.set_page_config("Adaptive Java Learning", layout="wide")

# --- Data Loading ---
# @st.cache_data
# def load_data():
#     try:
#         df = pd.read_csv("data/java_question_bank_with_topics_cleaned_gpt.csv", encoding="latin1")
#     except FileNotFoundError:
#         st.error("Error: Data file not found.")
#         return pd.DataFrame()

#     topic_order = [
#         "Basic Syntax", "Data Types", "Variables", "Operators", "Control Flow",
#         "Loops", "Methods", "Arrays", "Object-Oriented Programming",
#         "Inheritance", "Polymorphism", "Abstraction", "Encapsulation",
#         "Exception Handling", "File I/O", "Multithreading", "Collections", "Generics"
#     ]
#     df['topic'] = pd.Categorical(df['topic'], categories=topic_order, ordered=True)
#     df['bloom_level'] = pd.Categorical(df['bloom_level'], categories=df['bloom_level'].unique(), ordered=True)
#     return df.sort_values(['topic', 'bloom_level'])
# --- Data Loading ---
@st.cache_data
def load_data():
    # Get path relative to this script
    script_dir = os.path.dirname(os.path.abspath(__file__))
    data_path = os.path.join(script_dir, "..", "data", "java_question_bank_with_topics_cleaned_gpt.csv")

    if not os.path.exists(data_path):
        st.error(f"Error: Data file not found at {data_path}")
        return pd.DataFrame()

    try:
        df = pd.read_csv(data_path, encoding="latin1")
    except Exception as e:
        st.error(f"Error reading CSV: {e}")
        return pd.DataFrame()

    topic_order = [
        "Basic Syntax", "Data Types", "Variables", "Operators", "Control Flow",
        "Loops", "Methods", "Arrays", "Object-Oriented Programming",
        "Inheritance", "Polymorphism", "Abstraction", "Encapsulation",
        "Exception Handling", "File I/O", "Multithreading", "Collections", "Generics"
    ]

    df["topic"] = pd.Categorical(df["topic"], categories=topic_order, ordered=True)
    df["bloom_level"] = pd.Categorical(df["bloom_level"].astype(str),
                                       categories=df["bloom_level"].dropna().unique(),
                                       ordered=True)

    return df.sort_values(["topic", "bloom_level"])



# Inject CSS to remove syntax highlighting colors
st.markdown(
    """
    <style>
    /* Target the code blocks generated by st.code */
    pre code {
        color: unset !important; /* Remove specific text colors */
        background-color: unset !important; /* Remove specific background colors */
    }

    /* Target individual tokens within the code block if needed */
    pre code .token {
        color: unset !important;
    }
    </style>
    """,
    unsafe_allow_html=True
)

 

# --- Adaptive BBPS Logic ---
def get_next_question(topic_df, selected_topic):
    bloom_levels = topic_df['bloom_level'].cat.categories
    mastery = st.session_state.topic_mastery[selected_topic]
    confidence_log = st.session_state.confidence_record[selected_topic]

    # 1. Remediation
    if st.session_state.remediation_queue:
        target = st.session_state.remediation_queue.pop(0)
        qs = topic_df[(topic_df["sub_concept"] == target) &
                      (~topic_df["question_id"].isin(st.session_state.asked_qs))]
        if not qs.empty:
            return qs.sample(1).iloc[0], f"üéØ Targeting weak area: {target}"

    # 2. Bidirectional Bloom Logic
    for i, level in enumerate(bloom_levels):
        level_qs = topic_df[(topic_df["bloom_level"] == level) &
                            (~topic_df["question_id"].isin(st.session_state.asked_qs))]
        if level_qs.empty:
            continue

        records = confidence_log.get(level, [])
        high_conf_wrong = [r for r in records if not r['correct'] and r['confidence'] >= 4]
        low_conf_right = [r for r in records if r['correct'] and r['confidence'] <= 2]

        if high_conf_wrong and i > 0:
            lower = bloom_levels[i - 1]
            demotion_qs = topic_df[(topic_df["bloom_level"] == lower) &
                                   (~topic_df["question_id"].isin(st.session_state.asked_qs))]
            if not demotion_qs.empty:
                return demotion_qs.sample(1).iloc[0], f"üîª Demoting to reinforce: {lower}"

        if low_conf_right:
            reinforce_qs = level_qs
            return reinforce_qs.sample(1).iloc[0], f"üîÑ Reinforcing: {level} due to low confidence"

        if mastery.get(level, 0) < 2:
            return level_qs.sample(1).iloc[0], f"‚¨ÜÔ∏è Progressing to: {level}"

    return None, "üéâ You've completed this topic!"

# --- UI ---
def render_sidebar(topics):
    st.sidebar.title("üìö Adaptive Java Practice")
    role = st.sidebar.radio("Select Role", ["Student", "Teacher"])
    selected_topic = st.sidebar.selectbox("üìò Choose a Topic", topics)

    if st.sidebar.button("üîÑ Reset Session"):
        for key in list(st.session_state.keys()):
            del st.session_state[key]
        st.rerun()

    if st.sidebar.button("üîñ Review Bookmarked"):
        st.session_state.review_mode = True
        st.session_state.submitted = False
        st.session_state.current_question = None
        st.rerun()
        
    
    if role == "Teacher":
        st.session_state.started = False
        st.session_state.review_mode = False
        st.session_state.current_question = None
        render_teacher_view()
        st.stop()


    return role, selected_topic

##############################
# Student View
##############################

def render_student_view(df):
    topics = df["topic"].dropna().unique().tolist()
    role, selected_topic = render_sidebar(topics)

    st.title("üéì Java Learning ‚Äì Student Mode")
    st.subheader(f"üìò Topic: {selected_topic}")

    # Setup states
    st.session_state.topic_mastery.setdefault(selected_topic, {b: 0 for b in df['bloom_level'].cat.categories})
    st.session_state.score.setdefault(selected_topic, {b: {"correct": 0, "total": 0} for b in df['bloom_level'].cat.categories})
    st.session_state.confidence_record.setdefault(selected_topic, {})

    if not st.session_state.started:
        st.info("Click 'Start Learning' to begin.")
        if st.button("üöÄ Start Learning"):
            st.session_state.started = True
            st.rerun()
        return

    topic_df = df[df["topic"] == selected_topic]
    if topic_df.empty:
        st.warning("No questions for this topic.")
        return

    # Question Flow
    if st.session_state.current_question is None and not st.session_state.submitted:
        if st.session_state.review_mode:
            bookmarked = topic_df[topic_df["question_id"].isin(st.session_state.bookmarked)]
            if not bookmarked.empty:
                q = bookmarked.sample(1).iloc[0]
                st.session_state.current_question = q.to_dict()
                st.session_state.current_reason = "üîñ Reviewing a bookmarked question."
            else:
                st.success("No bookmarked questions left!")
                st.session_state.review_mode = False
        else:
            q, reason = get_next_question(topic_df, selected_topic)
            if q is not None:
                st.session_state.current_question = q.to_dict()
                st.session_state.current_reason = reason
                st.session_state.asked_qs.add(q["question_id"])

    # Show UI
    if st.session_state.current_question:
        display_question(pd.Series(st.session_state.current_question), selected_topic)

def display_question(q, topic):
    st.info(st.session_state.current_reason)
    st.markdown(f"**Bloom:** '{q['bloom_level']}' | **Question Id:** '{q['question_id']}') | **Sub-Concept:** '{q.get('sub_concept', 'General')}' ")
    
    
    st.code(q['question_stem'], language='java')

    choice = st.radio("Choose:", ["a", "b", "c", "d"], index=None,
                      format_func=lambda x: f"{x.upper()}. {q[f'option_{x}']}",
                      key=f"choice_{q['question_id']}")
    # confidence = st.slider("Confidence?", 1, 5, 3, key=f"conf_{q['question_id']}",
    #                        format_func=lambda x: ["Guessing", "Unsure", "Okay", "Confident", "Very Confident"][x-1])

    confidence = st.slider("How confident are you?", 1, 5, 3, key=f"conf_{q['question_id']}")
    confidence_labels = {
        1: "üò¨ Guessing",
        2: "ü§î Unsure",
        3: "üòê Okay",
        4: "üôÇ Confident",
        5: "üòé Very Confident"
    }
    st.markdown(f"**Selected Confidence:** {confidence_labels[confidence]}")

    submit_col, bookmark_col = st.columns(2)
    if bookmark_col.button("üîñ Bookmark", use_container_width=True):
        st.session_state.bookmarked.add(q['question_id'])
        st.success("Bookmarked.")

    if submit_col.button("‚úÖ Submit", use_container_width=True) and not st.session_state.submitted:
        if choice is None:
            st.warning("Choose an option.")
        else:
            handle_submission(q, choice, confidence, topic)
            st.session_state.submitted = True
            # st.rerun()

    if st.session_state.submitted:
        if st.button("‚û°Ô∏è Next Question"):
            st.session_state.submitted = False
            st.session_state.current_question = None
            st.rerun()

# def handle_submission(q, choice, confidence, topic):
#     correct = q["correct_option"].strip().lower()
#     is_correct = (choice == correct)
#     bloom = q["bloom_level"]
#     points = 0.5 + (confidence / 10.0) if is_correct else 0

#     if is_correct:
#         st.success(f"Correct! +{points:.2f} points.")
#     else:
#         st.error(f"Wrong. Correct: **{correct.upper()}**")
#         if confidence >= 4 and pd.notna(q.get('sub_concept')):
#             st.session_state.remediation_queue.append(q['sub_concept'])

#     if not st.session_state.review_mode:
#         st.session_state.topic_mastery[topic][bloom] += points
#         st.session_state.score[topic][bloom]["total"] += 1
#         st.session_state.score[topic][bloom]["correct"] += int(is_correct)
#         st.session_state.confidence_record[topic].setdefault(bloom, []).append({
#             'question_id': q['question_id'],
#             'confidence': confidence,
#             'correct': is_correct
#         })

#     # Log result
#     st.session_state.log.append({
#         # "timestamp": time.time(),
#         "timestamp": pd.Timestamp.now().isoformat(),
#         "session_id": st.session_state.session_id,
#         "topic": topic,
#         "bloom_level": bloom,
#         "question_id": q['question_id'],
#         "confidence": confidence,
#         "correct": is_correct,
#         "reinforcement": st.session_state.current_reason
#     })

#     # Explanation
#     with st.expander("üìò Explanation"):
#         st.markdown(q['main_explanation'])

#     # Save logs to CSV
#     log_df = pd.DataFrame(st.session_state.log)
#     os.makedirs("logs", exist_ok=True)
#     log_df.to_csv(f"logs/session_{st.session_state.session_id}.csv", index=False)
#     check_for_bloom_badge(topic, bloom)


def handle_submission(q, choice, confidence, topic):
    """Handles the logic after a user submits an answer."""
    correct = q["correct_option"].strip().lower()
    is_correct = (choice == correct)
    bloom = q["bloom_level"]
    points = 0.5 + (confidence / 10.0) if is_correct else 0

    if is_correct:
        st.success("‚úÖ Correct!")
        if not st.session_state.review_mode:
            st.session_state.topic_mastery[q['topic']][q['bloom_level']] += 1
    else:
        st.error(f"‚ùå Incorrect. The correct answer is **{correct.upper()}**.")
        if not st.session_state.review_mode:
            st.session_state.wrong_qs.append(q["question_id"])
            
    if not st.session_state.review_mode:
        st.session_state.topic_mastery[topic][bloom] += points
        st.session_state.score[topic][bloom]["total"] += 1
        st.session_state.score[topic][bloom]["correct"] += int(is_correct)
        st.session_state.confidence_record[topic].setdefault(bloom, []).append({
            'question_id': q['question_id'],
            'confidence': confidence,
            'correct': is_correct
        })

    with st.expander("View Explanation"):
        st.markdown(f"{q['main_explanation']}")

    # Update scores and log
    score = st.session_state.score[q['topic']][q['bloom_level']]
    score['total'] += 1
    if is_correct:
        score['correct'] += 1

    student_id = st.session_state.get("user_id", "unknown_student")
    session_id = st.session_state.get("session_id", "unknown_session")

    # Prepare log entry
    log_entry = {
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "student_id": student_id,
        "session_id": session_id,
        "topic": topic,
        "bloom_level": bloom,
        "question_id": q["question_id"],
        "selected": choice,
        "correct_option": correct,
        "is_correct": is_correct,
        "confidence": confidence,
        "reinforcement_reason": st.session_state.get("current_reason", "")
    }

    # Add this entry to in-memory log list
    st.session_state.log.append(log_entry)

    # === Absolute path: go back one directory from current file ===
    base_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(base_dir, ".."))  # one level up
    data_dir = os.path.join(project_root, "logs")
    os.makedirs(data_dir, exist_ok=True)

    # === Unified file per student ===
    student_csv = os.path.join(data_dir, f"student_{student_id}.csv")

    # Convert log to DataFrame and save (append mode)
    log_df = pd.DataFrame(st.session_state.log)

    if os.path.exists(student_csv):
        existing = pd.read_csv(student_csv)
        combined = pd.concat([existing, log_df], ignore_index=True)
        combined.to_csv(student_csv, index=False)
    else:
        log_df.to_csv(student_csv, index=False)

    # Save logs to CSV
    # log_df = pd.DataFrame(st.session_state.log)
    # os.makedirs("logs", exist_ok=True)
    # log_df.to_csv(f"logs/session_{st.session_state.session_id}.csv", index=False)
    # check_for_bloom_badge(topic, bloom)
    


def display_topic_completion_summary(selected_topic):
    """Displays a summary when a topic is completed."""
    st.success(f"üéâ You've completed the topic: {selected_topic}!")
    st.balloons()
    
    st.markdown("### üìà Mastery Progress")
    mastery_df = pd.DataFrame(st.session_state.topic_mastery[selected_topic], index=["Mastery"]).T
    st.dataframe(mastery_df)
    
# --- MOTIVATION PANEL ---
def show_motivation_panel(topic):
    st.markdown("### üìà Your Progress")
    stats = st.session_state.score[topic]
    total_attempted = sum([stats[b]['total'] for b in stats])
    total_correct = sum([stats[b]['correct'] for b in stats])
    percent = (total_correct / total_attempted * 100) if total_attempted else 0

    st.progress(int(percent), text=f"{int(percent)}% Correct")

    # Bloom-level breakdown
    with st.expander("üß† Bloom Level Mastery"):
        for b in stats:
            correct = stats[b]["correct"]
            total = stats[b]["total"]
            pct = (correct / total * 100) if total else 0
            st.markdown(f"- **{b}**: {correct}/{total} ({int(pct)}%)")
            st.progress(int(pct))

# --- BLOOM BADGE CHECKER ---
def check_for_bloom_badge(topic, bloom_level):
    stats = st.session_state.score[topic][bloom_level]
    correct = stats["correct"]
    total = stats["total"]
    if total >= 3 and correct / total >= 0.8:
        if f"{topic}_{bloom_level}" not in st.session_state:
            st.success(f"üéâ Mastery Unlocked: `{bloom_level}` level in **{topic}**!")
            st.session_state[f"{topic}_{bloom_level}"] = True



# --- Main ---
def main():
    df = load_data()
    if df.empty:
        return
    initialize_session_state()
    render_student_view(df)



import glob
import matplotlib.pyplot as plt

def render_teacher_view():
    st.title("üë©‚Äçüè´ Teacher Dashboard")
    st.markdown("Explore learner performance across topics, Bloom levels, and time dimensions.")

    log_files = glob.glob("logs/session_*.csv")
    if not log_files:
        st.warning("No session logs found yet. Students must complete at least one session.")
        return

    df_logs = pd.concat([pd.read_csv(f) for f in log_files], ignore_index=True)
    # df_logs['timestamp'] = pd.to_datetime(df_logs['timestamp'], unit='s')
    # --- Timestamp normalization ---
    try:
        # Handle mixed formats: numeric epochs and human-readable strings
        df_logs['timestamp'] = pd.to_datetime(df_logs['timestamp'], errors='coerce', unit='s')
        if df_logs['timestamp'].isna().any():
            # Retry parsing those that failed (likely formatted datetimes)
            df_logs['timestamp'] = pd.to_datetime(df_logs['timestamp'], errors='coerce', infer_datetime_format=True)
    except Exception:
        df_logs['timestamp'] = pd.to_datetime(df_logs['timestamp'], errors='coerce', infer_datetime_format=True)

    # Drop any invalid timestamps
    df_logs = df_logs.dropna(subset=['timestamp'])

    
    df_logs = calculate_difficulty(df_logs)
    df_logs, gain = calculate_learning_gains(df_logs)


    # --- STUDENT FILTER ---
    st.sidebar.subheader("üßë‚Äçüéì Filter by Student ID")
    unique_students = df_logs['session_id'].unique().tolist()
    selected_student = st.sidebar.selectbox("Select a Student", ["All Students"] + unique_students)

    if selected_student != "All Students":
        df_logs = df_logs[df_logs['session_id'] == selected_student]
        st.info(f"Showing data for student session: `{selected_student}`")

    # --- BLOOM MASTER HEATMAP ---
    st.subheader("üìò Bloom Level Accuracy by Topic")
    if 'bloom_level' in df_logs.columns:
        pivot = df_logs.groupby(['topic', 'bloom_level'])['correct'].mean().unstack().fillna(0) * 100
        st.dataframe(pivot.style.background_gradient(cmap='YlGn').format("{:.0f}%"))

    # --- TOPIC COVERAGE ---
    st.subheader("üìä Topic Coverage (Questions Attempted)")
    topic_counts = df_logs.groupby('topic')['question_id'].nunique().sort_values(ascending=False)
    st.bar_chart(topic_counts)

    # --- CONFIDENCE VS ACCURACY ---
    st.subheader("üß† Confidence vs Accuracy Trend")
    df_logs['conf_bin'] = pd.cut(df_logs['confidence'], bins=[0,2,3,4,5], labels=["Low", "Medium", "High", "Very High"])
    conf_acc = df_logs.groupby(['conf_bin'])['correct'].mean() * 100
    st.line_chart(conf_acc)

    # --- MISCONCEPTION HEATMAP ---
    st.subheader("üéØ Misconception Heatmap ‚Äì Tricky Sub-Concepts")
    if 'sub_concept' in df_logs.columns:
        miscon_df = df_logs[df_logs['confidence'] >= 4]  # high confidence wrong answers
        miscon_df = miscon_df[miscon_df['correct'] == False]
        misconcept = miscon_df.groupby('sub_concept')['question_id'].count().sort_values(ascending=False).head(10)
        if not misconcept.empty:
            st.bar_chart(misconcept)
        else:
            st.info("No significant misconceptions detected yet.")

    # --- TIME ON TASK ---
    st.subheader("üïì Time-on-Task Analysis")
    df_logs = df_logs.sort_values(['session_id', 'timestamp'])
    df_logs['time_diff'] = df_logs.groupby('session_id')['timestamp'].diff().dt.total_seconds()
    time_summary = df_logs.groupby('session_id')['time_diff'].sum().fillna(0)
    st.write("Average session duration (mins):", round(time_summary.mean() / 60, 2))
    st.bar_chart(time_summary / 60)

    # --- BLOOM PROGRESS OVER TIME ---
    st.subheader("üìà Per-Bloom Progress Timeline")
    df_time_bloom = (
        df_logs.groupby(['bloom_level', pd.Grouper(key='timestamp', freq='1min')])['correct']
        .mean().unstack(fill_value=None) * 100
    )
    if not df_time_bloom.empty:
        st.line_chart(df_time_bloom)
    else:
        st.info("Insufficient data to generate timeline trends.")

    st.subheader("‚öñÔ∏è Item Difficulty Overview")
    difficulty_summary = df_logs.groupby("bloom_level")["difficulty_score"].mean().round(2)
    st.bar_chart(difficulty_summary)
    st.markdown("Higher bars = higher relative complexity (weighted by Bloom level + empirical error).")

    st.subheader("üìà Learning Gain per Bloom Level")
    st.markdown("Tracks student improvement across Bloom levels using rolling accuracy windows.")
    if not gain.empty:
        gain_summary = gain.groupby("bloom_level")["learning_gain"].mean().round(1)
        st.dataframe(gain_summary.rename("Avg Learning Gain (%)"))
        st.line_chart(gain_summary)
    else:
        st.info("Insufficient data for gain trend analysis.")


    st.subheader("üéØ Weighted Mastery Score (Cognitive Value Index)")
    df_logs["weighted_correct"] = df_logs["correct"] * df_logs["difficulty_score"]
    mastery = df_logs.groupby("session_id")["weighted_correct"].mean() * 100
    st.bar_chart(mastery)
    st.caption("This metric rewards success on harder questions more heavily.")


    # --- STUDENT SUMMARY TABLE ---
    st.subheader("üßæ Student Summary Overview")
    if "session_id" in df_logs.columns:
        student_summary = df_logs.groupby('session_id').agg({
            'question_id': 'count',
            'correct': 'mean',
            'confidence': 'mean',
            'time_diff': 'sum'
        }).rename(columns={
            'question_id': 'Questions',
            'correct': 'Accuracy',
            'confidence': 'Avg_Confidence',
            'time_diff': 'Time_Spent_Seconds'
        })
        student_summary['Time_Spent_Minutes'] = (student_summary['Time_Spent_Seconds'] / 60).round(2)
        st.dataframe(student_summary.style.format({
            "Accuracy": "{:.1%}",
            "Avg_Confidence": "{:.2f}",
            "Time_Spent_Minutes": "{:.2f}"
        }))



if __name__ == "__main__":
    main()
    
def run_student_mode():
    df = load_data()
    if df.empty:
        st.warning("No data available. Please check the CSV file.")
        return
    initialize_session_state()
    render_student_view(df)











# import streamlit as st
# import pandas as pd
# import time
# import os

# # --- BKT Model Parameters (Used only in advanced mode) ---
# P_L0 = 0.20  # Probability of initial knowledge
# P_T = 0.30   # Probability of transitioning to a learned state
# P_G = 0.25   # Probability of guessing correctly
# P_S = 0.10   # Probability of slipping (making a mistake when knowing)

# # --- Configuration and Data Loading ---
# st.set_page_config("Adaptive Learning Research Platform", layout="wide")

# # Inject CSS to remove syntax highlighting colors
# st.markdown(
#     """
#     <style>
#     /* Target the code blocks generated by st.code */
#     pre code {
#         color: unset !important; /* Remove specific text colors */
#         background-color: unset !important; /* Remove specific background colors */
#     }

#     /* Target individual tokens within the code block if needed */
#     pre code .token {
#         color: unset !important;
#     }
#     </style>
#     """,
#     unsafe_allow_html=True
# )



# @st.cache_data
# def load_data():
#     """Loads and prepares the question bank."""
#     try:
#         df = pd.read_csv("data/java_question_bank_with_topics_cleaned_gpt.csv", encoding="latin1")
#     except FileNotFoundError:
#         st.error("Error: The question bank file was not found.")
#         return pd.DataFrame()

#     topic_order = [
#         "Basic Syntax", "Data Types", "Variables", "Operators", "Control Flow",
#         "Loops", "Methods", "Arrays", "Object-Oriented Programming", "Inheritance",
#         "Polymorphism", "Abstraction", "Encapsulation", "Exception Handling",
#         "File I/O", "Multithreading", "Collections", "Generics"
#     ]
#     df['topic'] = pd.Categorical(df['topic'], categories=topic_order, ordered=True)
#     if 'bloom_level' in df.columns:
#         df['bloom_level'] = pd.Categorical(df['bloom_level'], categories=df['bloom_level'].unique(), ordered=True)
#     return df.sort_values(['topic', 'bloom_level'])

# # --- Session State Management ---
# def initialize_session_state(df, advanced_mode):
#     """Initializes session state based on the selected mode."""
#     if 'initialized' in st.session_state:
#         return

#     st.session_state.initialized = True
#     st.session_state.log = []
#     st.session_state.asked_qs = set()
#     st.session_state.submitted = False
#     st.session_state.current_question = None
#     st.session_state.frustration_counter = 0

#     if advanced_mode:
#         all_sub_concepts = df["sub_concept"].dropna().unique().tolist()
#         st.session_state.knowledge_state = {concept: P_L0 for concept in all_sub_concepts}
#     else: # Basic mode state
#         st.session_state.topic_mastery = {}
#         st.session_state.remediation_queue = [] # Simple list of wrong question IDs

# # --- BKT Advanced Logic ---
# def update_knowledge_state(sub_concept, is_correct):
#     # (BKT logic remains the same as previous version)
#     p_learn_prev = st.session_state.knowledge_state.get(sub_concept, P_L0)
#     if is_correct:
#         p_learn_if_obs = (p_learn_prev * (1 - P_S)) / (p_learn_prev * (1 - P_S) + (1 - p_learn_prev) * P_G)
#     else:
#         p_learn_if_obs = (p_learn_prev * P_S) / (p_learn_prev * P_S + (1 - p_learn_prev) * (1 - P_G))
#     p_learn_new = p_learn_if_obs + (1 - p_learn_if_obs) * P_T
#     st.session_state.knowledge_state[sub_concept] = p_learn_new

# def get_next_question_advanced(topic_df):
#     # (Advanced question selection logic remains the same)
#     # 1. Affective Intervention
#     if st.session_state.frustration_counter >= 3:
#         st.session_state.frustration_counter = 0
#         failed_concept = st.session_state.get('last_failed_concept')
#         if failed_concept and 'prerequisite_concept' in topic_df.columns:
#             prereq = topic_df[topic_df['sub_concept'] == failed_concept]['prerequisite_concept'].iloc[0]
#             if pd.notna(prereq):
#                 prereq_qs = topic_df[topic_df['sub_concept'] == prereq]
#                 if not prereq_qs.empty:
#                     return prereq_qs.sample(1).iloc[0], f"‚ö†Ô∏è Let's review a core concept: **{prereq}**"
    
#     # 2. Find Zone of Proximal Development
#     knowledge = st.session_state.knowledge_state
#     eligible_concepts = {c for c, p in knowledge.items() if 0.4 < p < 0.95 and c in topic_df['sub_concept'].unique()}
#     if not eligible_concepts:
#         eligible_concepts = {c for c, p in knowledge.items() if p < 0.95 and c in topic_df['sub_concept'].unique()}
#     if not eligible_concepts:
#         return None, "üéâ **Mastery Reached!** High proficiency in all concepts."

#     target_concept = min(eligible_concepts, key=knowledge.get)
#     candidate_qs = topic_df[(topic_df["sub_concept"] == target_concept) & (~topic_df["question_id"].isin(st.session_state.asked_qs))]
#     if not candidate_qs.empty:
#         return candidate_qs.sort_values('bloom_level').iloc[0], f"üß† Working on **{target_concept}** (Mastery: {knowledge[target_concept]:.0%})"
#     return None, "All questions for the current objective answered."

# # --- Basic Adaptive Logic (Fallback) ---
# def get_next_question_basic(topic_df, selected_topic):
#     """The reliable, Bloom's-level-based question selection logic."""
#     # Prioritize wrongly answered questions
#     if st.session_state.remediation_queue:
#         q_id = st.session_state.remediation_queue.pop(0)
#         question = topic_df[topic_df["question_id"] == q_id]
#         if not question.empty:
#             return question.iloc[0], "üîÅ Retrying a previously missed question."
    
#     # Progress through Bloom's Levels
#     mastery = st.session_state.topic_mastery.setdefault(selected_topic, {b: 0 for b in topic_df['bloom_level'].cat.categories})
#     for level in topic_df['bloom_level'].cat.categories:
#         if mastery.get(level, 0) < 2:
#             candidate_qs = topic_df[(topic_df["bloom_level"] == level) & (~topic_df["question_id"].isin(st.session_state.asked_qs))]
#             if not candidate_qs.empty:
#                 return candidate_qs.sample(1).iloc[0], f"üîç Moving to Bloom Level: **{level}**"
#             continue
#     return None, "üéâ Topic complete! All questions have been answered."

# # --- UI and Main Application ---
# def render_student_view(df, advanced_mode):
#     st.title("üéì Adaptive Java Learning")
#     topics = df["topic"].dropna().unique().tolist()
    
#     st.sidebar.title("üìö Java Practice")
#     selected_topic = st.sidebar.selectbox("üìò Choose a Topic", topics)
#     # ... (sidebar controls) ...

#     # Display live model if in advanced mode
#     if advanced_mode:
#         st.sidebar.subheader("Live Knowledge Model")
#         topic_sub_concepts = df[df['topic'] == selected_topic]['sub_concept'].unique()
#         knowledge_df = pd.DataFrame.from_dict(st.session_state.knowledge_state, orient='index', columns=['Mastery Probability'])
#         st.sidebar.dataframe(knowledge_df[knowledge_df.index.isin(topic_sub_concepts)])
#         st.sidebar.progress(knowledge_df.mean().iloc[0])

#     topic_df = df[df["topic"] == selected_topic]
#     if topic_df.empty:
#         st.warning("This topic has no questions yet.")
#         return

#     if st.session_state.current_question is None and not st.session_state.submitted:
#         if advanced_mode:
#             question, reason = get_next_question_advanced(topic_df)
#         else:
#             question, reason = get_next_question_basic(topic_df, selected_topic)
        
#         if question is not None:
#             st.session_state.current_question = question.to_dict()
#             st.session_state.asked_qs.add(question["question_id"])
#         st.session_state.current_reason = reason

#     if st.session_state.current_question:
#         display_question_interface(pd.Series(st.session_state.current_question), advanced_mode)
#     else:
#         st.success(st.session_state.current_reason)
#         st.balloons()


# def display_question_interface(q, advanced_mode):
#     st.info(st.session_state.current_reason)
#     if advanced_mode:
#         st.markdown(f"**Sub-Concept:** `{q.get('sub_concept', 'General')}`")
#     st.code(q['question_stem'], language='java')
    
#     choice = st.radio("Choose:", ["a", "b", "c", "d"], index=None,
#                       format_func=lambda x: f"{x.upper()}. {q.get(f'option_{x}', '')}",
#                       key=f"choice_{q['question_id']}")

#     submit = st.button("‚úÖ Submit Answer")

#     if submit and not st.session_state.submitted:
#         is_correct = (choice == q["correct_option"].strip().lower())
        
#         if advanced_mode:
#             update_knowledge_state(q['sub_concept'], is_correct)
#             if not is_correct:
#                 st.session_state.frustration_counter += 1
#                 st.session_state.last_failed_concept = q['sub_concept']
#             else:
#                 st.session_state.frustration_counter = 0
#         else: # Basic mode handling
#             if not is_correct:
#                 st.session_state.remediation_queue.append(q['question_id'])
#             else:
#                 mastery = st.session_state.topic_mastery[q['topic']]
#                 mastery[q['bloom_level']] = mastery.get(q['bloom_level'], 0) + 1
        
#         # Display feedback
#         if is_correct:
#             st.success("‚úÖ Correct!")
#         else:
#             st.error(f"‚ùå Incorrect. The correct answer was **{q['correct_option'].upper()}**.")
#             if advanced_mode and 'learning_resource_url' in q and pd.notna(q['learning_resource_url']):
#                 st.info(f"Struggling? [Click here to review the material.]({q['learning_resource_url']})")

#         st.session_state.submitted = True
#         st.rerun()

#     if st.session_state.submitted:
#         if st.button("‚û°Ô∏è Next Question"):
#             st.session_state.submitted = False
#             st.session_state.current_question = None
#             st.rerun()

# def main():
#     df = load_data()
#     if df.empty:
#         return

#     # **THE FIX: Detect mode based on data availability**
#     advanced_mode = 'sub_concept' in df.columns and 'prerequisite_concept' in df.columns
    
#     st.sidebar.info(f"Running in **{'Advanced' if advanced_mode else 'Basic'} Mode**.")
    
#     initialize_session_state(df, advanced_mode)
#     render_student_view(df, advanced_mode)

# if __name__ == "__main__":
#     main()

























# import streamlit as st
# import pandas as pd
# import random
# import time
# import os




# # --- Configuration and Data Loading ---

# st.set_page_config("Adaptive Java Learning", layout="wide")

# @st.cache_data  # Cache the data loading for better performance
# def load_data():
#     """Loads and preprocesses the question bank."""
#     try:
#         df = pd.read_csv("data/java_question_bank_with_topics_cleaned_gpt.csv", encoding="latin1")
        
#         # Define the order of topics for a structured learning path
#         topic_order = [
#             "Basic Syntax", "Data Types", "Variables", "Operators", "Control Flow",
#             "Loops", "Methods", "Arrays", "Object-Oriented Programming",
#             "Inheritance", "Polymorphism", "Abstraction", "Encapsulation",
#             "Exception Handling", "File I/O", "Multithreading", "Collections", "Generics"
#         ]
        
#         # Apply categorical ordering to topics and Bloom's levels
#         df['topic'] = pd.Categorical(df['topic'], categories=topic_order, ordered=True)
#         df['bloom_level'] = pd.Categorical(df['bloom_level'], ordered=True)
#         df = df.sort_values(['topic', 'bloom_level'])
#         return df
#     except FileNotFoundError:
#         st.error("The question bank file was not found. Please make sure the path is correct.")
#         return pd.DataFrame()

# df = load_data()




# # --- Session State Initialization ---

# def initialize_session_state():
#     """Initializes the session state with default values."""
#     defaults = {
#         "started": False,
#         "log": [],
#         "wrong_qs": [],
#         "bookmarked": set(),
#         "score": {},
#         "topic_mastery": {},
#         "asked_qs": set(),
#         "submitted": False,
#         "current_question": None,
#         "review_mode": False
#     }
#     for key, value in defaults.items():
#         if key not in st.session_state:
#             st.session_state[key] = value

# initialize_session_state()

# # --- UI Components ---

# # Inject CSS to remove syntax highlighting colors
# st.markdown(
#     """
#     <style>
#     /* Target the code blocks generated by st.code */
#     pre code {
#         color: unset !important; /* Remove specific text colors */
#         background-color: unset !important; /* Remove specific background colors */
#     }

#     /* Target individual tokens within the code block if needed */
#     pre code .token {
#         color: unset !important;
#     }
#     </style>
#     """,
#     unsafe_allow_html=True
# )


# def render_sidebar(topics):
#     """Renders the sidebar controls."""
#     st.sidebar.title("üìö Adaptive Java Practice")
#     role = st.sidebar.radio("Select Role", ["Student", "Teacher"])
#     selected_topic = st.sidebar.selectbox("üìò Choose a Topic", topics)

#     if st.sidebar.button("üîÑ Reset Session"):
#         for key in list(st.session_state.keys()):
#             del st.session_state[key]
#         st.rerun()

#     if st.sidebar.button("üîñ Review Bookmarked"):
#         st.session_state.review_mode = True
#         st.rerun()
        
#     return role, selected_topic

# def render_student_view(selected_topic):
#     """Renders the main view for the student."""
#     st.title("üéì Java Learning ‚Äì Student Mode")
#     st.subheader(f"üìò Topic: {selected_topic}")

#     if not st.session_state.started:
#         st.markdown("""
#         üëã **Welcome to your adaptive Java learning app!**

#         - Master each Bloom level before progressing.
#         - Missed questions will be repeated.
#         - Bookmark tricky ones for review.
#         """)
#         if st.button("üöÄ Start Learning"):
#             st.session_state.started = True
#             st.rerun()
#         return

#     # Initialize topic-specific state if not already present
#     if selected_topic not in st.session_state.topic_mastery:
#         st.session_state.topic_mastery[selected_topic] = {b: 0 for b in df['bloom_level'].cat.categories}
#     if selected_topic not in st.session_state.score:
#         st.session_state.score[selected_topic] = {b: {"correct": 0, "total": 0} for b in df['bloom_level'].cat.categories}
        
#     topic_df = df[df["topic"] == selected_topic]
#     if topic_df.empty:
#         st.warning("There are no questions available for this topic.")
#         return

#     # Question selection and display logic
#     if st.session_state.current_question is None and not st.session_state.submitted:
#         select_next_question(topic_df)

#     if st.session_state.current_question:
#         display_question(pd.Series(st.session_state.current_question), selected_topic)
#     else:
#         display_topic_completion_summary(selected_topic)

# def select_next_question(topic_df):
#     """Selects the next question based on the adaptive logic."""
#     if not st.session_state.review_mode:
#         # Determine the target Bloom's level
#         target_level = None
#         for level in df['bloom_level'].cat.categories:
#             if st.session_state.topic_mastery.get(topic_df['topic'].iloc[0], {}).get(level, 0) < 2:
#                 target_level = level
#                 break

#         if target_level:
#             candidate_qs = topic_df[topic_df["bloom_level"] == target_level]
#             available_qs = candidate_qs[~candidate_qs["question_id"].isin(st.session_state.asked_qs)]
#             if not available_qs.empty:
#                 q = available_qs.sample(1).iloc[0]
#                 st.session_state.current_question = q.to_dict()
#                 st.session_state.current_reason = f"üîç Bloom Level: **{target_level}**"
#                 return

#         if st.session_state.wrong_qs:
#             q_id = st.session_state.wrong_qs.pop(0)
#             q = topic_df[topic_df["question_id"] == q_id].iloc[0]
#             st.session_state.current_question = q.to_dict()
#             st.session_state.current_reason = "üîÅ Retrying a previously missed question."
#     else:
#         bookmarked_df = topic_df[topic_df["question_id"].isin(st.session_state.bookmarked)]
#         if not bookmarked_df.empty:
#             q = bookmarked_df.sample(1).iloc[0]
#             st.session_state.current_question = q.to_dict()
#             st.session_state.current_reason = "üîñ Reviewing bookmarked question."
#         else:
#             st.success("No bookmarked questions to review.")
#             st.session_state.review_mode = False

# def display_question(q, selected_topic):
#     """Displays the current question and handles user interaction."""
#     st.info(st.session_state.current_reason)
#     st.markdown(f"**üß† Bloom:** `{q['bloom_level']}` | **ID:** `{q['question_id']}`")
#     st.code(f"{q['question_stem']}")

#     options = ["a", "b", "c", "d"]
#     choice = st.radio(
#         "Choose:", options, index=None,
#         format_func=lambda x: f"{x.upper()}. {q[f'option_{x}']}",
#         key=f"choice_{q['question_id']}"
#     )

#     col1, col2, col3 = st.columns([1, 1, 1])
#     submit = col1.button("‚úÖ Submit Answer")
#     if col2.button("üìé Bookmark Question"):
#         st.session_state.bookmarked.add(q['question_id'])
#         st.success("üîñ Question bookmarked.")
        
#     col3.link_button(f"Read more about {selected_topic}", "https://www.w3schools.com/java/")

#     if submit and not st.session_state.submitted:
#         if choice is None:
#             st.warning("‚ö†Ô∏è Please select an option before submitting.")
#             return

#         handle_submission(q, choice)
#         st.session_state.submitted = True

#     if st.session_state.submitted:
#         if st.button("‚û°Ô∏è Next Question"):
#             st.session_state.submitted = False
#             st.session_state.current_question = None
#             st.rerun()

# def handle_submission(q, choice):
#     """Handles the logic after a user submits an answer."""
#     correct = q["correct_option"].strip().lower()
#     is_correct = (choice == correct)

#     if is_correct:
#         st.success("‚úÖ Correct!")
#         if not st.session_state.review_mode:
#             st.session_state.topic_mastery[q['topic']][q['bloom_level']] += 1
#     else:
#         st.error(f"‚ùå Incorrect. The correct answer is **{correct.upper()}**.")
#         if not st.session_state.review_mode:
#             st.session_state.wrong_qs.append(q["question_id"])

#     with st.expander("View Explanation"):
#         st.markdown(f"{q['main_explanation']}")

#     # Update scores and log
#     score = st.session_state.score[q['topic']][q['bloom_level']]
#     score['total'] += 1
#     if is_correct:
#         score['correct'] += 1

#     log_entry = {
#         "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
#         "topic": q["topic"],
#         "bloom_level": q["bloom_level"],
#         "question_id": q["question_id"],
#         "selected": choice,
#         "correct_option": correct,
#         "is_correct": is_correct
#     }
#     st.session_state.log.append(log_entry)
    
#     # Save log to file
#     if not os.path.exists("logs"):
#         os.makedirs("logs")
#     pd.DataFrame(st.session_state.log).to_csv("logs/session_log.csv", index=False)

# def display_topic_completion_summary(selected_topic):
#     """Displays a summary when a topic is completed."""
#     st.success(f"üéâ You've completed the topic: {selected_topic}!")
#     st.balloons()
    
#     st.markdown("### üìà Mastery Progress")
#     mastery_df = pd.DataFrame(st.session_state.topic_mastery[selected_topic], index=["Mastery"]).T
#     st.dataframe(mastery_df)
    
#     # ... (rest of the summary display) ...

# def render_teacher_view():
#     """Renders the dashboard for the teacher."""
#     st.title("üë©‚Äçüè´ Teacher Dashboard")
#     st.subheader("üìä Question Distribution by Topic and Bloom's Level")
    
#     if not df.empty:
#         dist = df.groupby(["topic", "bloom_level"]).size().unstack().fillna(0)
#         st.bar_chart(dist)

#     st.subheader("üë®‚Äçüéì Student Session Log")
#     if st.session_state.log:
#         log_df = pd.DataFrame(st.session_state.log)
#         st.dataframe(log_df)
#         st.download_button("üì• Download Session Log", log_df.to_csv(index=False), file_name="student_session_log.csv")
#     else:
#         st.info("No student session data has been recorded yet.")
        
# # --- Main App Logic ---

# def main():
#     """Main function to run the Streamlit app."""
#     if df.empty:
#         st.stop()
        
#     topics = df["topic"].dropna().unique().tolist()
#     role, selected_topic = render_sidebar(topics)

#     if role == "Student":
#         render_student_view(selected_topic)
#     else:
#         render_teacher_view()

# if __name__ == "__main__":
#     main()

















# import streamlit as st
# import pandas as pd
# import random
# import time
# import os

# # Load the cleaned question bank
# df = pd.read_csv("data/java_question_bank_with_topics_cleaned_gpt.csv", encoding="latin1")

# # Sort topics for better learning progression
# topic_order = [
#     "Basic Syntax", "Data Types", "Variables", "Operators", "Control Flow",
#     "Loops", "Methods", "Arrays", "Object-Oriented Programming",
#     "Inheritance", "Polymorphism", "Abstraction", "Encapsulation",
#     "Exception Handling", "File I/O", "Multithreading", "Collections", "Generics"
# ]
# df['topic'] = pd.Categorical(df['topic'], categories=topic_order, ordered=True)
# df['bloom_level'] = pd.Categorical(df['bloom_level'], ordered=True)
# df = df.sort_values(['topic', 'bloom_level'])

# # Page config
# st.set_page_config("Adaptive Java Learning", layout="wide")

# # Initialize session state
# for key, default in {
#     "started": False,
#     "log": [],
#     "wrong_qs": [],
#     "bookmarked": set(),
#     "score": {},
#     "topic_mastery": {},
#     "asked_qs": set(),
#     "submitted": False,
#     "current_question": None,
#     "review_mode": False
# }.items():
#     if key not in st.session_state:
#         st.session_state[key] = default

# # Sidebar controls
# st.sidebar.title("üìö Adaptive Java Practice")
# role = st.sidebar.radio("Select Role", ["Student", "Teacher"])
# topics = df["topic"].dropna().unique().tolist()
# selected_topic = st.sidebar.selectbox("üìò Choose a Topic", topics)

# if st.sidebar.button("üîÑ Reset Session"):
#     for key in list(st.session_state.keys()):
#         del st.session_state[key]
#     st.rerun()

# if st.sidebar.button("üîñ Review Bookmarked"):
#     st.session_state.review_mode = True
#     st.rerun()

# # Student View

# # Inject CSS to remove syntax highlighting colors
# st.markdown(
#     """
#     <style>
#     /* Target the code blocks generated by st.code */
#     pre code {
#         color: unset !important; /* Remove specific text colors */
#         background-color: unset !important; /* Remove specific background colors */
#     }

#     /* Target individual tokens within the code block if needed */
#     pre code .token {
#         color: unset !important;
#     }
#     </style>
#     """,
#     unsafe_allow_html=True
# )

# if role == "Student":
#     st.title("üéì Java Learning ‚Äì Student Mode")
#     st.subheader(f"üìò Topic: {selected_topic}")

#     if not st.session_state.started:
#         st.markdown("""
#         üëã **Welcome to your adaptive Java learning app!**

#         - Master each Bloom level before progressing.
#         - Missed questions will be repeated.
#         - Bookmark tricky ones for review.
#         """)
#         if st.button("üöÄ Start Learning"):
#             st.session_state.started = True
#             st.rerun()
#         st.stop()

#     if selected_topic not in st.session_state.topic_mastery:
#         st.session_state.topic_mastery[selected_topic] = {b: 0 for b in df['bloom_level'].cat.categories}
#     if selected_topic not in st.session_state.score:
#         st.session_state.score[selected_topic] = {b: {"correct": 0, "total": 0} for b in df['bloom_level'].cat.categories}

#     topic_df = df[df["topic"] == selected_topic]

#     if not st.session_state.review_mode:
#         for level in df['bloom_level'].cat.categories:
#             if st.session_state.topic_mastery[selected_topic][level] < 2:
#                 target_level = level
#                 break
#         else:
#             target_level = None

#         if not st.session_state.submitted and st.session_state.current_question is None:
#             if target_level:
#                 candidate_qs = topic_df[topic_df["bloom_level"] == target_level]
#                 available_qs = candidate_qs[~candidate_qs["question_id"].isin(st.session_state.asked_qs)]
#             else:
#                 available_qs = pd.DataFrame()

#             if not available_qs.empty:
#                 q = available_qs.sample(1).iloc[0]
#                 st.session_state.asked_qs.add(q["question_id"])
#                 st.session_state.current_question = q.to_dict()
#                 st.session_state.current_reason = f"üîç Bloom Level: **{target_level}**"
#             elif st.session_state.wrong_qs:
#                 q = topic_df[topic_df["question_id"] == st.session_state.wrong_qs.pop(0)].iloc[0]
#                 st.session_state.current_question = q.to_dict()
#                 st.session_state.current_reason = "üîÅ Retrying a previously missed question."
#             else:
#                 st.session_state.current_question = None
#     else:
#         bookmarked_df = topic_df[topic_df["question_id"].isin(st.session_state.bookmarked)]
#         if not bookmarked_df.empty:
#             q = bookmarked_df.sample(1).iloc[0]
#             st.session_state.current_question = q.to_dict()
#             st.session_state.current_reason = "üîñ Reviewing bookmarked question."
#         else:
#             st.success("No bookmarked questions to review.")
#             st.session_state.review_mode = False
#             st.stop()

#     if st.session_state.current_question is not None:
#         q = pd.Series(st.session_state.current_question)
#         st.info(st.session_state.current_reason)
#         st.markdown(f"**üß† Bloom:** `{q['bloom_level']}` | **ID:** `{q['question_id']}`")
#         st.code(f"{q['question_stem']}")

#         # if "explanation" in q and pd.notna(q["explanation"]):
#         #     st.markdown(f"üßæ *Hint/Explanation:* {q['explanation']}")
            
#         # if pd.notna(q["main_explanation"]):
#         #     st.markdown(f"üßæ *Hint/Explanation:* {q['main_explanation']}")

#         choice = st.radio(
#             "Choose:", ["a", "b", "c", "d"], index=None,
#             format_func=lambda x: {
#                 "a": f"A. {q['option_a']}",
#                 "b": f"B. {q['option_b']}",
#                 "c": f"C. {q['option_c']}",
#                 "d": f"D. {q['option_d']}"
#             }.get(x, x),
#             key=f"choice_{q['question_id']}"
#         )

#         col1, col2, col3 = st.columns([1, 1, 1])
#         with col1:
#             submit = st.button("‚úÖ Submit Answer")
#         with col2:
#             bookmark = st.button("üìé Bookmark Question")
        
#         with col3:
#             # bookmark = st.button(f"Read more about {selected_topic}")
#             bookmark = st.link_button(f"Read more about {selected_topic}", "https://www.example.com")


#         if submit and not st.session_state.submitted:
#             if choice not in ["a", "b", "c", "d"]:
#                 st.warning("‚ö†Ô∏è Please select an option before submitting.")
#                 st.stop()

#             correct = q["correct_option"].strip().lower()
#             is_correct = choice == correct

#             if is_correct:
#                 st.success("‚úÖ Correct!")
#                 if not st.session_state.review_mode:
#                     st.session_state.topic_mastery[selected_topic][q["bloom_level"]] += 1
#             else:
#                 st.error(f"‚ùå Incorrect") 
#                 # ‚ùì
#                 with st.expander("üó∏"):
#                     # st.markdown(f"üßæ Correct answer: **{correct.upper()}**\n*Explanation:* {q['main_explanation']}")
#                     st.markdown(f"üßæ *Correct answer:* **{correct.upper()}**", unsafe_allow_html=True)

#                 if not st.session_state.review_mode:
#                     st.session_state.wrong_qs.append(q["question_id"])

#             with st.expander("üìù"):
#                 st.markdown(f"*Explanation:* {q['main_explanation']}", unsafe_allow_html=True)

#             st.session_state.score[selected_topic][q["bloom_level"]]["total"] += 1
#             if is_correct:
#                 st.session_state.score[selected_topic][q["bloom_level"]]["correct"] += 1
                

#             st.session_state.log.append({
#                 "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
#                 "topic": q["topic"],
#                 "bloom_level": q["bloom_level"],
#                 "question_id": q["question_id"],
#                 "selected": choice,
#                 "correct_option": correct,
#                 "is_correct": is_correct
#             })

#             if not os.path.exists("logs"):
#                 os.makedirs("logs")
#             pd.DataFrame(st.session_state.log).to_csv("logs/session_log.csv", index=False)

#             st.session_state.submitted = True

#         if st.session_state.submitted:
#             if st.button("‚û°Ô∏è Next Question"):
#                 st.session_state.submitted = False
#                 st.session_state.current_question = None
#                 st.rerun()

#         if bookmark:
#             st.session_state.bookmarked.add(q["question_id"])
#             st.success("üîñ Question bookmarked.")

#     else:
#         st.success("üéâ Topic complete!")
#         st.markdown("### üìà Mastery Progress")
#         mastery_df = pd.DataFrame(st.session_state.topic_mastery[selected_topic], index=["Mastery"]).T
#         st.dataframe(mastery_df)

#         st.markdown("### üìä Accuracy by Bloom Level")
#         score_df = pd.DataFrame(st.session_state.score[selected_topic]).T
#         score_df["accuracy"] = (score_df["correct"] / score_df["total"]).fillna(0) * 100
#         st.dataframe(score_df)

#         max_possible = len(df['bloom_level'].cat.categories) * 2
#         progress_value = int(sum(st.session_state.topic_mastery[selected_topic].values()) / max(max_possible, 1) * 100)
#         st.progress(min(progress_value, 100))

#         log_df = pd.DataFrame(st.session_state.log)
#         st.download_button("üì• Download Your Log", log_df.to_csv(index=False), file_name="session_log.csv")

#         if st.session_state.bookmarked:
#             st.markdown("### üîñ Bookmarked Questions")
#             for b_id in st.session_state.bookmarked:
#                 bq = topic_df[topic_df['question_id'] == b_id].iloc[0]
#                 st.markdown(f"**ID {b_id}:** {bq['question_stem']}")

#         if st.session_state.wrong_qs:
#             if st.button("üîÅ Retry Missed Questions"):
#                 st.session_state.asked_qs.clear()
#                 st.rerun()

# # Teacher View
# if role == "Teacher":
#     st.title("üë©‚Äçüè´ Teacher Dashboard")
#     st.subheader("üìä Question Distribution")
#     dist = df.groupby(["topic", "bloom_level"]).size().unstack().fillna(0)
#     st.bar_chart(dist)

#     if st.session_state.log:
#         log_df = pd.DataFrame(st.session_state.log)
#         st.dataframe(log_df)
#         st.download_button("üì• Download Session Log", log_df.to_csv(index=False), file_name="student_session_log.csv")
#     else:
#         st.info("No session data yet.")