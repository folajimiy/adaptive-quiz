id,timestamp,concept,bloom_level,question_stem,option_a,option_b,option_c,option_d,correct_answer,a_explanation,b_explanation,c_explanation,d_explanation,main_explanation,raw_model_response,retrieved_chunks,eval_relevance,eval_bloom_alignment,eval_accuracy,eval_explainability,eval_justification
970bcc34-4d8e-40c4-8ba1-5ce2c1629c17,2025-11-25T11:07:51.217987,Java fundamentals,Remember,Which of the following is a Java reserved word (keyword) and cannot be used as an identifier?,class,welcome,system,scanner,A,"Correct. ""class"" is a reserved Java keyword and cannot be used as an identifier.","Incorrect. ""welcome"" is not a Java reserved word.","Incorrect. ""system"" is not a Java reserved word (the correct Java class is ""System"").","Incorrect. ""scanner"" is not a reserved word (the correct Java class is ""Scanner"").","Java has specific reserved words like ""class"" that cannot be used as identifiers. Identifiers must not be any reserved word in Java.","Question: Which of the following is a Java reserved word (keyword) and cannot be used as an identifier?

Options:
A) class
B) welcome
C) system
D) scanner

Correct Answer: A

Option A explanation: Correct. ""class"" is a reserved Java keyword and cannot be used as an identifier.
Option B explanation: Incorrect. ""welcome"" is not a Java reserved word.
Option C explanation: Incorrect. ""system"" is not a Java reserved word (the correct Java class is ""System"").
Option D explanation: Incorrect. ""scanner"" is not a reserved word (the correct Java class is ""Scanner"").

Main Explanation: Java has specific reserved words like ""class"" that cannot be used as identifiers. Identifiers must not be any reserved word in Java.

Tags: Java fundamentals, Remember","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,5,5,5,"This question directly assesses a fundamental Java concept—understanding reserved keywords and identifier naming rules. The correct answer (A) ""class"" is unambiguously a Java reserved word. The distractors are well-chosen: ""welcome"" and ""scanner"" are valid identifiers, while ""system"" is a clever distractor since ""System"" is a common Java class (testing whether students confuse case-sensitivity with reserved status). All explanations are accurate and clearly distinguish why each option is correct or incorrect. The question aligns perfectly with Bloom's ""Remember"" level, requiring students to recall which words are reserved in Java. The overall explanation reinforces the core concept effectively."
832a1914-0896-4b4f-bc2c-de899a59de0a,2025-11-25T11:08:00.583489,Java fundamentals,Remember,Which of the following is a Java reserved word (keyword) that cannot be used as an identifier?,class,count,number,input,A,"Correct. ""class"" is a reserved word in Java and cannot be used as an identifier.","Incorrect. ""count"" is not a Java reserved word and can be used as an identifier.","Incorrect. ""number"" is not a Java reserved word and can be used as an identifier.","Incorrect. ""input"" is not a Java reserved word and can be used as an identifier.","Java reserved words, such as ""class,"" have special meaning in the language and cannot be used as variable or method names, as stated in the lecture slides.","Question: Which of the following is a Java reserved word (keyword) that cannot be used as an identifier?

Options:
A) class
B) count
C) number
D) input

Correct Answer: A

Option A explanation: Correct. ""class"" is a reserved word in Java and cannot be used as an identifier.
Option B explanation: Incorrect. ""count"" is not a Java reserved word and can be used as an identifier.
Option C explanation: Incorrect. ""number"" is not a Java reserved word and can be used as an identifier.
Option D explanation: Incorrect. ""input"" is not a Java reserved word and can be used as an identifier.

Main Explanation: Java reserved words, such as ""class,"" have special meaning in the language and cannot be used as variable or method names, as stated in the lecture slides.

Tags: Java fundamentals, Remember","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,5,5,5,"This question directly assesses a fundamental Java concept—understanding reserved words and their role as non-identifiers. It is well-constructed with clear distractors (count, number, input) that are plausible variable names but not reserved words, making it appropriately challenging at the Remember level of Bloom's taxonomy. The correct answer is technically accurate: ""class"" is indeed a Java reserved word that cannot be used as an identifier. All explanations are clear and specific, correctly identifying why each option is right or wrong. The question effectively tests whether students can distinguish reserved words from regular identifiers, which is essential foundational knowledge for Java programming."
28a1b722-d356-498e-9b13-18de90751530,2025-11-25T11:08:13.922844,Java fundamentals,Understand,Which of the following is NOT a type of programming error described in the lecture slides?,Syntax Error,Runtime Error,Logic Error,Network Error,D,Incorrect. Syntax Errors are described as errors detected by the compiler.,Incorrect. Runtime Errors are mentioned as errors that cause the program to abort.,"Incorrect. Logic Errors are errors that produce incorrect results, as described in the slides.",Correct. Network Error is not mentioned as a type of programming error in the lecture slides.,"The lecture slides describe Syntax, Runtime, and Logic errors as types of programming errors, but do not mention Network Error.","Question: Which of the following is NOT a type of programming error described in the lecture slides?

Options:
A) Syntax Error
B) Runtime Error
C) Logic Error
D) Network Error

Correct Answer: D

Option A explanation: Incorrect. Syntax Errors are described as errors detected by the compiler.
Option B explanation: Incorrect. Runtime Errors are mentioned as errors that cause the program to abort.
Option C explanation: Incorrect. Logic Errors are errors that produce incorrect results, as described in the slides.
Option D explanation: Correct. Network Error is not mentioned as a type of programming error in the lecture slides.

Main Explanation: The lecture slides describe Syntax, Runtime, and Logic errors as types of programming errors, but do not mention Network Error.

Tags: Java fundamentals, Understand","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",2,3,4,3,"While this question tests knowledge of error types, it has limited relevance to Java fundamentals specifically—it's more about general programming concepts that apply across languages. The accuracy is solid; the three error types (Syntax, Runtime, Logic) are correctly defined and Network Error is a reasonable distractor not typically classified as a programming error type. However, explainability is moderate because the explanations are brief and don't clarify *why* Network Error isn't a programming error (it's an operational/infrastructure concern, not a code defect). Bloom alignment is weak for ""Understand""—this question primarily tests recall/recognition of definitions rather than demonstrating understanding of how these errors manifest or their implications. A stronger question would ask students to identify which error type a code snippet represents, requiring deeper comprehension."
103f85d0-1e93-40b7-bf1a-81bdc0d56121,2025-11-25T11:08:32.500130,Java fundamentals,Understand,Which of the following is a syntax error according to the Java fundamentals lecture?,Dividing by zero in your code,Using an identifier that is a reserved word,Printing incorrect results due to a logic mistake,Forgetting to close the Scanner object,B,"This is a runtime error, not a syntax error.",Correct. Using a reserved word as an identifier is a syntax error detected by the compiler.,"This is a logic error, not a syntax error.","Not closing Scanner is bad practice, but not a syntax error.","Syntax errors are detected by the compiler and include issues like using reserved words as identifiers, as shown in the lecture slides.","Question: Which of the following is a syntax error according to the Java fundamentals lecture?

Options:
A) Dividing by zero in your code
B) Using an identifier that is a reserved word
C) Printing incorrect results due to a logic mistake
D) Forgetting to close the Scanner object

Correct Answer: B

Option A explanation: This is a runtime error, not a syntax error.
Option B explanation: Correct. Using a reserved word as an identifier is a syntax error detected by the compiler.
Option C explanation: This is a logic error, not a syntax error.
Option D explanation: Not closing Scanner is bad practice, but not a syntax error.

Main Explanation: Syntax errors are detected by the compiler and include issues like using reserved words as identifiers, as shown in the lecture slides.

Tags: Java fundamentals, Understand","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,4,5,5,"The question directly assesses a fundamental Java concept—distinguishing syntax errors from other error types. All explanations are technically accurate: dividing by zero is indeed a runtime error (ArithmeticException), reserved words as identifiers cause compiler syntax errors, logic errors produce wrong output, and unclosed Scanners are resource management issues. The distractors are well-chosen and represent common misconceptions. Explanations are clear and specific. Bloom alignment is strong at the ""Understand"" level (distinguishing error categories), though it could arguably reach ""Apply"" if students had to identify errors in code snippets. The reference to ""Java fundamentals lecture"" and ""lecture slides"" adds appropriate context. Minor note: Option D could be slightly stronger as a distractor since resource leaks are sometimes treated as compile-time warnings in modern Java, but this doesn't significantly impact question quality."
417399f4-8c6b-4004-b949-262a625c2d2d,2025-11-25T11:08:42.863202,Java fundamentals,Apply,"Given the following code, what is printed to the console?

int x=10, y;
y = (x % 2 == 0)?1:0;
System.out.printf(""%d%n"", y);",0,1,10,2,B,Incorrect. y would be 0 only if x % 2 != 0.,"Correct. x % 2 == 0 is true, so y = 1.","Incorrect. 10 is the value of x, not y.",Incorrect. 2 is not assigned to y in any scenario.,"The ternary operator checks if x is even. Since x=10 is even, y becomes 1, and 1 is printed.","Question: Given the following code, what is printed to the console?

int x=10, y;
y = (x % 2 == 0)?1:0;
System.out.printf(""%d%n"", y);

Options:
A) 0
B) 1
C) 10
D) 2

Correct Answer: B

Option A explanation: Incorrect. y would be 0 only if x % 2 != 0.
Option B explanation: Correct. x % 2 == 0 is true, so y = 1.
Option C explanation: Incorrect. 10 is the value of x, not y.
Option D explanation: Incorrect. 2 is not assigned to y in any scenario.

Main Explanation: The ternary operator checks if x is even. Since x=10 is even, y becomes 1, and 1 is printed.

Tags: Java fundamentals, Apply","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,4,5,5,"This question directly assesses Java fundamentals including the modulo operator, ternary conditional operator, and printf formatting—all core concepts. The correct answer (B) is technically accurate: 10 % 2 == 0 evaluates to true, making y = 1. All distractors are reasonable and address common misconceptions (confusing the condition logic, selecting x's value, or misunderstanding operator precedence). Explanations are clear and specific, correctly identifying why each option is right or wrong. Bloom alignment is strong at the ""Apply"" level—students must apply knowledge of operators and conditional logic to trace code execution, though it borders on ""Understand"" since it's primarily execution tracing rather than problem-solving in a novel context. Overall, this is a well-constructed question with minor room for increased cognitive demand."
31f698b3-2441-4fcf-a117-3215cfd19fdb,2025-11-25T11:08:52.483321,Java fundamentals,Apply,"What will be the output of the following Java code?
```java
int x = 10, y;
y = (x % 2 == 0) ? 1 : 0;
System.out.printf(""%d%n"", y);
```",0,1,10,Compile-time error,B,"Incorrect. 0 would be printed if x was odd, but 10 is even.","Correct. Since 10 is even, x % 2 == 0 is true, so y is assigned 1.","Incorrect. 10 is the value of x, not y.",Incorrect. The code is valid and compiles successfully.,"The ternary operator checks if x is even (x % 2 == 0). Since 10 is even, y is set to 1, which is printed.","Question: What will be the output of the following Java code?
```java
int x = 10, y;
y = (x % 2 == 0) ? 1 : 0;
System.out.printf(""%d%n"", y);
```

Options:
A) 0
B) 1
C) 10
D) Compile-time error

Correct Answer: B

Option A explanation: Incorrect. 0 would be printed if x was odd, but 10 is even.
Option B explanation: Correct. Since 10 is even, x % 2 == 0 is true, so y is assigned 1.
Option C explanation: Incorrect. 10 is the value of x, not y.
Option D explanation: Incorrect. The code is valid and compiles successfully.

Main Explanation: The ternary operator checks if x is even (x % 2 == 0). Since 10 is even, y is set to 1, which is printed.

Tags: Java fundamentals, Apply","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,4,5,5,"This question directly assesses Java fundamentals including the ternary operator, modulo operator, and printf formatting—all core concepts. The correct answer (B) is accurate, and all distractors are reasonable and well-explained. Option A tests understanding of the condition, Option C tests variable tracking, and Option D tests syntax knowledge. Explanations are clear and specific for each option. The cognitive demand aligns well with ""Apply"" level—students must apply knowledge of operators and control flow to trace execution, though it borders on ""Understand"" since the logic is relatively straightforward. The question is well-constructed with no technical errors."
e714d341-50a6-46b1-a3a4-9c4aab663b84,2025-11-25T11:09:07.046372,Java fundamentals,Analyze,"Given the following code, what type of programming error will occur and why?

public class ShowRuntimeErrors {
    public static void main(String[] args) {
        System.out.println(1 / 0);
    }
}","Syntax error, because the code will not compile.","Runtime error, because division by zero occurs during execution.","Logic error, because the result is mathematically incorrect but the program runs.",No error; the code prints 0.,B,"Incorrect; there is no syntax error, and the code compiles.",Correct; division by zero causes a runtime error during execution.,"Incorrect; logic errors result in incorrect output, not abrupt program termination.","Incorrect; the program will not print 0, it will terminate abnormally.","Division by zero is not caught at compile time, but causes a runtime error (arithmetic exception) when the program is executed, matching the definition of runtime error in the lecture.","Question: Given the following code, what type of programming error will occur and why?

public class ShowRuntimeErrors {
    public static void main(String[] args) {
        System.out.println(1 / 0);
    }
}

Options:
A) Syntax error, because the code will not compile.
B) Runtime error, because division by zero occurs during execution.
C) Logic error, because the result is mathematically incorrect but the program runs.
D) No error; the code prints 0.

Correct Answer: B

Option A explanation: Incorrect; there is no syntax error, and the code compiles.
Option B explanation: Correct; division by zero causes a runtime error during execution.
Option C explanation: Incorrect; logic errors result in incorrect output, not abrupt program termination.
Option D explanation: Incorrect; the program will not print 0, it will terminate abnormally.

Main Explanation: Division by zero is not caught at compile time, but causes a runtime error (arithmetic exception) when the program is executed, matching the definition of runtime error in the lecture.

Tags: Java fundamentals, Analyze","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,3,5,5,"The question directly assesses Java fundamentals by testing understanding of error types (syntax, runtime, logic) and exception handling. The correct answer (B) and all distractors are technically accurate—division by zero genuinely throws ArithmeticException at runtime, the code does compile without syntax errors, and the explanations are clear and specific. However, the cognitive demand aligns more with Bloom's ""Understand"" or ""Remember"" (recognizing error types) rather than ""Analyze."" The question requires students to identify and classify an error type, which is lower-order thinking than analyzing code behavior or evaluating design choices. To reach ""Analyze"" level, the question would need to require comparing error types, explaining trade-offs, or reasoning through multiple scenarios."
3f2eb210-de73-45bf-93be-bb5605207737,2025-11-25T11:09:18.435981,Java fundamentals,Analyze,"Which of the following code snippets demonstrates a logic error, as described in the lecture slides?",System.out.println(1 / 0);,"System.out.println(""Welcome to Java);",System.out.println((9 / 5) * 35 + 32);,System.exit(0);,C,"Incorrect. This demonstrates a runtime error (division by zero), not a logic error.",Incorrect. This contains a syntax error (missing quote).,"Correct. This produces an incorrect result but compiles and runs, matching the lecture's logic error example.","Incorrect. This is valid code for terminating a program, not an error.","Logic errors occur when code compiles and runs but produces an incorrect result, as shown in option C from the lecture slides.","Question: Which of the following code snippets demonstrates a logic error, as described in the lecture slides?

Options:
A) System.out.println(1 / 0);
B) System.out.println(""Welcome to Java);
C) System.out.println((9 / 5) * 35 + 32);
D) System.exit(0);

Correct Answer: C

Option A explanation: Incorrect. This demonstrates a runtime error (division by zero), not a logic error.
Option B explanation: Incorrect. This contains a syntax error (missing quote).
Option C explanation: Correct. This produces an incorrect result but compiles and runs, matching the lecture's logic error example.
Option D explanation: Incorrect. This is valid code for terminating a program, not an error.

Main Explanation: Logic errors occur when code compiles and runs but produces an incorrect result, as shown in option C from the lecture slides.

Tags: Java fundamentals, Analyze","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",4,3,4,4,"The question directly assesses understanding of Java error types (logic vs. syntax vs. runtime), which is fundamental to Java programming. However, relevance is not perfect since it's more about error classification than core Java fundamentals like syntax or semantics.

Accuracy is strong: Option A correctly represents a runtime error, Option B correctly shows a syntax error, Option D is valid code, and Option C does demonstrate a logic error (the formula appears to be attempting Celsius-to-Fahrenheit conversion but uses integer division, losing precision). The explanations are technically sound.

Explainability is clear and well-structured, with specific reasoning for each option. However, it could be slightly stronger by explicitly showing what output Option C produces versus what was intended.

Bloom alignment is moderate (3/5). The question asks students to 'analyze' code snippets to identify error types, which fits the 'analyze' level. However, it's somewhat lower-order analysis since it primarily requires recognizing predefined error categories rather than deeper problem-solving or evaluation. A stronger 'analyze' question might require students to trace through logic or explain why the error occurs."
556bb438-dd16-4d93-9a7c-388073690505,2025-11-25T11:09:27.648901,Java fundamentals,Evaluate,"Given the following code, what type of error will occur?

public class ShowRuntimeErrors {
    public static void main(String[] args) {
        System.out.println(1 / 0);
    }
}",Syntax Error,Runtime Error,Logic Error,No Error,B,"Incorrect; a syntax error is detected by the compiler, but this code compiles.","Correct; dividing by zero causes a runtime error, aborting the program.","Incorrect; a logic error produces incorrect results, not program crashes.",Incorrect; the code will not execute without error.,"Dividing by zero is not caught by the compiler, but will cause the program to abort during execution, which is classified as a runtime error.","Question: Given the following code, what type of error will occur?

public class ShowRuntimeErrors {
    public static void main(String[] args) {
        System.out.println(1 / 0);
    }
}

Options:
A) Syntax Error
B) Runtime Error
C) Logic Error
D) No Error

Correct Answer: B

Option A explanation: Incorrect; a syntax error is detected by the compiler, but this code compiles.
Option B explanation: Correct; dividing by zero causes a runtime error, aborting the program.
Option C explanation: Incorrect; a logic error produces incorrect results, not program crashes.
Option D explanation: Incorrect; the code will not execute without error.

Main Explanation: Dividing by zero is not caught by the compiler, but will cause the program to abort during execution, which is classified as a runtime error.

Tags: Java fundamentals, Evaluate","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,2,5,5,"The question is highly relevant to Java fundamentals, specifically error types and exception handling. The accuracy is excellent—division by zero in Java throws an ArithmeticException at runtime, and all explanations are technically correct and well-reasoned. However, the Bloom's Taxonomy alignment is weak. The question asks students to ""identify what type of error occurs,"" which is a Remember/Understand level task (Bloom 1-2), not Evaluate (Bloom 5). To reach Evaluate level, the question would need to ask students to judge trade-offs between error types, assess code quality, or justify why certain error handling approaches are superior. The current question simply requires recognition of a straightforward runtime error scenario."
d940904b-6289-47fb-8a48-620919a3ff14,2025-11-25T11:09:37.064742,Java fundamentals,Evaluate,"Given the following code, which type of programming error will occur?

public class ShowRuntimeErrors {
    public static void main(String[] args) {
        System.out.println(1 / 0);
    }
}",Syntax Error,Runtime Error,Logic Error,No Error,B,"Incorrect. Syntax errors are detected by the compiler, but this code will compile.","Correct. Dividing by zero causes the program to abort at runtime, which is a runtime error.","Incorrect. Logic errors produce incorrect results, but do not cause the program to abort.",Incorrect. The program will fail at runtime due to division by zero.,"Dividing by zero is not detected by the compiler but causes a runtime error, which makes the program abort during execution.","Question: Given the following code, which type of programming error will occur?

public class ShowRuntimeErrors {
    public static void main(String[] args) {
        System.out.println(1 / 0);
    }
}

Options:
A) Syntax Error
B) Runtime Error
C) Logic Error
D) No Error

Correct Answer: B

Option A explanation: Incorrect. Syntax errors are detected by the compiler, but this code will compile.
Option B explanation: Correct. Dividing by zero causes the program to abort at runtime, which is a runtime error.
Option C explanation: Incorrect. Logic errors produce incorrect results, but do not cause the program to abort.
Option D explanation: Incorrect. The program will fail at runtime due to division by zero.

Main Explanation: Dividing by zero is not detected by the compiler but causes a runtime error, which makes the program abort during execution.

Tags: Java fundamentals, Evaluate","foo"");		
}		
if (x==true) {			
	System.out.printf(""bar"");		
}
?: Operator (Ternary)
Shortcut to an “if-else” expression
(condition)?(result if true):(result if false)
int x=10, y;		
if (x%2 == 0) {			
	y = 1;		
} else {			
	y = 0;		
}		
System.out.printf(""%d%n"", y);
int x=10, y;		
y = (x % 2 == 0)?1:0;		
System.out.printf(""%d%n"", y);
while Loops
while loops are used to repeat a set of statements while some condition is true

int x = 1, y = 1;		
while (x<100) {
x *= 2;			
y++;		
}
System.out.printf(""%d %d"", x, y);
do-while Loops
A while loop body might be executed zero times if the condition is never true
If you need to always execute the body at least once, use a do-while loop (remember the final ;)

int x;		
Scanner s = new Scanner(System.in);		
do {			
	System.out.printf(""Enter 1 to loop: "");	
	x = s.nextInt(); 
} while (x == 1);		
System.out.printf(""Freedom!%n"");
for Loops
Used as a shortcut for a commonly occurring pattern
Initialization (once before loop)
Condition (before each iteration)
Update (at the end of each loop body)
int i=0;		
while (i<10) {			
	System.out.printf(""%d%n"", i);
	i++;		
}
for (int i=0; i<10; i++) {	
	System.out.printf(""%d%n"", i);
}
for-each Loop

===== CHUNK BREAK =====

int x = 2;	

System.out.printf(""%d %d %d %d %d"",	a[3], a[x], a[x/2], 
	a[x+x], a[x-2]);
Arrays in Memory
Arrays are stored in memory so that all the elements are sequential, in order:

int[] counts;
counts = new int[8];
counts[3] = 10;


0
address
0
0
10
0
0
0
0
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
value
variable
…
counts[0]
counts[1]
counts[2]
counts[3]
counts[4]
counts[5]
counts[6]
counts[7]
Arrays of … Arrays (Twist!)
Multidimensional Arrays
int[][] m;		
m = new int[][] {{1, 2}, {3, 4}, {5, 6}};

int[][] m = new int[3][];
m[0] = new int[] {1, 2};
m[1] = new int[] {3, 4};
m[2] = new int[] {5, 6};

int[][] m = new int[3][2];		
m[0][0] = 1;		
m[0][1] = 2;		
m[1][0] = 3;		
m[1][1] = 4;		
m[2][0] = 5;	
m[2][1] = 6;
COMP1000 Topics
Computation/Programming
Variables, I/O
Expressions
Arrays
Control Flow, Conditionals, Loops
Methods
Exceptions, File I/O
Misc
Sequential Execution
Control flow is the order in which program statements are executed

Remember: the program starts at main() and executes line-by-line till either System.exit() or end of main()

However, some commands cause the execution to “hop” somewhere else
Conditionals, loops, exceptions
Conditional Statements

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

. For example, when the compiler sees the word class, it understands that the word after class is the name for the class.
Java Reserved Words / Keywords
An identifier cannot be a reserved word.
Blocks
A pair of braces in a program forms a block that groups components of a program.
Special Symbols
Braces { … 
Parentheses ( … )
Statement Terminator ; 
// Comments
“ String ”
Programming Errors
Syntax Errors
Detected by the compiler
Runtime Errors
Causes the program to abort
Logic Errors
Produces incorrect result
Syntax Errors
public class ShowSyntaxErrors {
public static main(String[] args) {
System.out.println(""Welcome to Java);
}
}
ShowSyntaxErrors
Runtime Errors
public class ShowRuntimeErrors {
public static void main(String[] args) {
System.out.println(1 / 0);
}
}
ShowRuntimeErrors
Logic Errors
public class ShowLogicErrors {
public static void main(String[] args) {
System.out.println(""Celsius 35 is Fahrenheit degree "");
System.out.println((9 / 5) * 35 + 32);
}
}
ShowLogicErrors
Reading Input From the Console
Create a Scanner object
Scanner input = new Scanner(System.in);
Use the method nextDouble() to obtain to a double value. For example,",5,2,5,5,"The question directly assesses Java fundamentals by distinguishing between error types (syntax, runtime, logic), which is core to understanding Java compilation and execution. However, the cognitive demand aligns with Bloom's ""Remember/Understand"" (level 1-2) rather than ""Evaluate"" (level 5). The question asks students to identify/classify an error type, not to evaluate trade-offs, judge quality, or make complex decisions. The correct answer (B) is technically accurate—division by zero throws ArithmeticException at runtime. All distractors are reasonable and well-explained: A correctly notes the code compiles, C correctly distinguishes logic errors, D provides a false alternative. Explanations are clear and specific, directly addressing why each option is correct or incorrect. The question is well-constructed for foundational Java knowledge but mislabeled in cognitive complexity."
8d13a018-4032-4d93-b48b-c70118312bc0,2025-11-25T11:09:47.198414,Objects and Classes,Remember,"In Java, what does a class define according to object-oriented programming (OOP)?",The template for an object's data fields and methods,The memory address of an object,Only the methods that objects can use,Only the data values of an object,A,Correct. A class is a template or blueprint that defines an object's data fields and methods.,"Incorrect. The memory address relates to an object's unique identity, not what a class defines.","Incorrect. A class defines both data fields and methods, not just methods.","Incorrect. A class defines data fields (types), not the data values themselves.","In OOP, a class acts as a blueprint that specifies both the properties (data fields) and behaviors (methods) that its object instances will have.","Question: In Java, what does a class define according to object-oriented programming (OOP)?

Options:
A) The template for an object's data fields and methods
B) The memory address of an object
C) Only the methods that objects can use
D) Only the data values of an object

Correct Answer: A

Option A explanation: Correct. A class is a template or blueprint that defines an object's data fields and methods.
Option B explanation: Incorrect. The memory address relates to an object's unique identity, not what a class defines.
Option C explanation: Incorrect. A class defines both data fields and methods, not just methods.
Option D explanation: Incorrect. A class defines data fields (types), not the data values themselves.

Main Explanation: In OOP, a class acts as a blueprint that specifies both the properties (data fields) and behaviors (methods) that its object instances will have.

Tags: Objects and Classes, Remember","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,4,5,5,"The question directly assesses understanding of the fundamental OOP concept that a class serves as a blueprint/template. All explanations are clear and technically accurate. Option B correctly distinguishes between class definition and object identity; Option C addresses a common misconception; Option D clarifies the distinction between data field types (defined in class) versus actual values (assigned to instances). The cognitive demand slightly exceeds ""Remember"" as it requires understanding the distinction between class definition and object instantiation, placing it closer to ""Understand"" on Bloom's taxonomy, though the core concept is foundational."
a4147ce4-d209-4ad1-8dba-766d7ca774dc,2025-11-25T11:09:57.495381,Objects and Classes,Remember,"In Java, what does an object represent according to object-oriented programming (OOP)?",A blueprint or template for creating data fields and methods,An entity in the real world that can be distinctly identified,A set of instructions only used for calculations,Only a variable without any behavior,B,"Incorrect; a class, not an object, serves as a blueprint or template.",Correct; an object represents an entity in the real world that can be distinctly identified.,"Incorrect; objects can have behavior, but they are not just instructions for calculations.",Incorrect; an object has both state (data fields) and behavior (methods).,"An object in OOP represents a real-world entity with unique identity, state (data fields), and behavior (methods), not just a variable or a set of instructions.","Question: In Java, what does an object represent according to object-oriented programming (OOP)?

Options:  
A) A blueprint or template for creating data fields and methods  
B) An entity in the real world that can be distinctly identified  
C) A set of instructions only used for calculations  
D) Only a variable without any behavior

Correct Answer: B

Option A explanation: Incorrect; a class, not an object, serves as a blueprint or template.  
Option B explanation: Correct; an object represents an entity in the real world that can be distinctly identified.  
Option C explanation: Incorrect; objects can have behavior, but they are not just instructions for calculations.  
Option D explanation: Incorrect; an object has both state (data fields) and behavior (methods).

Main Explanation: An object in OOP represents a real-world entity with unique identity, state (data fields), and behavior (methods), not just a variable or a set of instructions.

Tags: Objects and Classes, Remember","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",4,2,4,4,"The question directly assesses understanding of objects in OOP, which is core to the Objects and Classes concept (relevance=4). However, the cognitive demand exceeds ""Remember"" level—it requires comprehension and distinction between objects and classes, placing it at Bloom's ""Understand"" level (bloom=2, where 1=Remember, 2=Understand, etc.). The correct answer (B) is accurate and well-grounded in OOP principles. Distractors are reasonable: A confuses objects with classes (a common misconception), C and D represent incomplete/incorrect characterizations. Explanations are clear and specific, directly addressing why each option is correct or incorrect, with a helpful overall summary (explainability=4). Minor weakness: the question could be more precise by explicitly asking ""what does an object represent"" versus ""what is an object,"" though the current phrasing is acceptable."
068ce52b-32d6-47fc-ae97-848c97391ddf,2025-11-25T11:10:07.810519,Objects and Classes,Understand,Which of the following best describes the relationship between a class and an object in Java?,A class is a blueprint; an object is an instance of that blueprint.,An object defines the data fields and methods; a class only stores values.,An object is a template; a class is a variable of that template.,A class and an object are the same thing in Java.,A,"Correct. The slides state a class is a template (blueprint), and objects are instances of that class.","Incorrect. The class defines data fields and methods, not the object.","Incorrect. The class is the template, and the object is the variable (instance).","Incorrect. A class and an object are distinct; the class defines structure, the object is an instance.","In Java, a class is a blueprint or template that defines what data fields and methods its objects will have. Objects are actual instances created from the class, each with their own state and behavior.","Question: Which of the following best describes the relationship between a class and an object in Java?

Options:
A) A class is a blueprint; an object is an instance of that blueprint.
B) An object defines the data fields and methods; a class only stores values.
C) An object is a template; a class is a variable of that template.
D) A class and an object are the same thing in Java.

Correct Answer: A

Option A explanation: Correct. The slides state a class is a template (blueprint), and objects are instances of that class.
Option B explanation: Incorrect. The class defines data fields and methods, not the object.
Option C explanation: Incorrect. The class is the template, and the object is the variable (instance).
Option D explanation: Incorrect. A class and an object are distinct; the class defines structure, the object is an instance.

Main Explanation: In Java, a class is a blueprint or template that defines what data fields and methods its objects will have. Objects are actual instances created from the class, each with their own state and behavior.

Tags: Objects and Classes, Understand","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,4,5,5,"The question directly assesses the fundamental concept of classes and objects in Java, which is core to object-oriented programming. The correct answer (A) is accurate and uses standard terminology (blueprint/template and instance). All distractors are reasonable and address common misconceptions: B reverses the relationship, C inverts both terms, and D conflates the two concepts. Explanations are clear and specific, correctly identifying why each option is right or wrong with reference to foundational concepts. The cognitive demand aligns well with Bloom's ""Understand"" level—students must comprehend and distinguish between two related but distinct concepts rather than merely recall or apply them. The question is well-constructed for assessing conceptual understanding of OOP fundamentals."
4f8b7413-151e-4ee3-a0b4-7ea34e755036,2025-11-25T11:10:17.819676,Objects and Classes,Understand,Which of the following statements best describes the relationship between a class and an object in Java?,A class is an instance of an object.,An object is a blueprint that defines a class.,An object is an instance of a class.,A class and an object are the same thing.,C,Incorrect. A class is not an instance; it is a blueprint for objects.,Incorrect. A class is the blueprint; the object is created from it.,Correct. An object is an instance of a class.,"Incorrect. A class and an object are different; one is a blueprint, the other is an instance.","A class defines the structure and behavior (blueprint), while an object is a specific instance created from that class.","Question: Which of the following statements best describes the relationship between a class and an object in Java?

Options:
A) A class is an instance of an object.
B) An object is a blueprint that defines a class.
C) An object is an instance of a class.
D) A class and an object are the same thing.

Correct Answer: C

Option A explanation: Incorrect. A class is not an instance; it is a blueprint for objects.
Option B explanation: Incorrect. A class is the blueprint; the object is created from it.
Option C explanation: Correct. An object is an instance of a class.
Option D explanation: Incorrect. A class and an object are different; one is a blueprint, the other is an instance.

Main Explanation: A class defines the structure and behavior (blueprint), while an object is a specific instance created from that class.

Tags: Objects and Classes, Understand","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,4,5,5,"This question directly assesses the fundamental concept of classes and objects in Java, which is core to object-oriented programming. The correct answer (C) is technically accurate and well-established in Java terminology. All distractors are reasonable misconceptions that students commonly hold, making them effective for identifying misunderstandings. The explanations are clear and concise, directly addressing why each option is correct or incorrect with specific terminology (blueprint, instance). The question aligns well with Bloom's ""Understand"" level as it requires students to comprehend and distinguish between two related but distinct concepts. The only minor consideration is that this is a straightforward definitional question that sits slightly toward the lower end of ""Understand"" (recall-adjacent) rather than deeper comprehension tasks like applying or analyzing these concepts, which prevents a perfect Bloom score."
22633580-6ac2-4e09-9bfc-01528edd9ed9,2025-11-25T11:10:28.433936,Objects and Classes,Apply,"Given the class definition below, which statement will create a new Circle object with a radius of 10?

public class Circle {
    private double radius = 1.0;
    public Circle() {}
    public Circle(double r) { setRadius(r); }
    public void setRadius(double r) { if (r>0) radius = r; }
}",Circle c = new Circle(10);,Circle c = new Circle();,Circle c = Circle(10);,Circle c = new Circle.radius(10);,A,"Correct; this calls the constructor with a double argument, setting radius to 10.","Incorrect; this uses the no-arg constructor, so radius remains 1.0.","Incorrect; missing 'new' keyword, so this will not compile.",Incorrect; 'new Circle.radius(10)' is not valid Java syntax.,"To create a Circle object with a specific radius, use the constructor with a double parameter: new Circle(10); this sets the radius to 10 using the setRadius method.","Question: Given the class definition below, which statement will create a new Circle object with a radius of 10?

public class Circle {
    private double radius = 1.0;
    public Circle() {}
    public Circle(double r) { setRadius(r); }
    public void setRadius(double r) { if (r>0) radius = r; }
}

Options:
A) Circle c = new Circle(10);
B) Circle c = new Circle();
C) Circle c = Circle(10);
D) Circle c = new Circle.radius(10);

Correct Answer: A

Option A explanation: Correct; this calls the constructor with a double argument, setting radius to 10.
Option B explanation: Incorrect; this uses the no-arg constructor, so radius remains 1.0.
Option C explanation: Incorrect; missing 'new' keyword, so this will not compile.
Option D explanation: Incorrect; 'new Circle.radius(10)' is not valid Java syntax.

Main Explanation: To create a Circle object with a specific radius, use the constructor with a double parameter: new Circle(10); this sets the radius to 10 using the setRadius method.

Tags: Objects and Classes, Apply","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,4,5,5,"This question directly assesses understanding of object instantiation, constructors, and class design—core concepts in Objects and Classes. The correct answer (A) requires students to apply knowledge of constructor syntax and parameter passing. All distractors are technically sound and represent common mistakes: B tests understanding of default values, C tests syntax knowledge, and D tests invalid syntax recognition. Explanations are clear and specific, identifying exactly why each option succeeds or fails. The cognitive demand aligns well with ""Apply"" level—students must select the correct constructor invocation method rather than merely recall facts. The only minor consideration is that this could arguably reach ""Analyze"" level if students must compare constructor behaviors, but ""Apply"" is appropriate for the primary task of selecting correct syntax."
a92cb18d-e819-4a3d-87de-704e54132d09,2025-11-25T11:10:39.375626,Objects and Classes,Apply,"Given the following code, what is the output of System.out.println(c2.getRadius()); if c2 is created as new Circle(10);?",1.0,5.0,10.0,0.0,C,"Incorrect. 1.0 is the default radius, not the value set by the constructor.",Incorrect. 5.0 is not the value passed to the constructor for c2.,Correct. The constructor new Circle(10) sets the radius to 10.0.,Incorrect. There is no way the radius is set to 0.0 in this code.,"The constructor Circle(double r) sets the radius using setRadius(r), so calling getRadius() on c2 after new Circle(10) returns 10.0.","Question: Given the following code, what is the output of System.out.println(c2.getRadius()); if c2 is created as new Circle(10);?

Options:
A) 1.0
B) 5.0
C) 10.0
D) 0.0

Correct Answer: C

Option A explanation: Incorrect. 1.0 is the default radius, not the value set by the constructor.
Option B explanation: Incorrect. 5.0 is not the value passed to the constructor for c2.
Option C explanation: Correct. The constructor new Circle(10) sets the radius to 10.0.
Option D explanation: Incorrect. There is no way the radius is set to 0.0 in this code.

Main Explanation: The constructor Circle(double r) sets the radius using setRadius(r), so calling getRadius() on c2 after new Circle(10) returns 10.0.

Tags: Objects and Classes, Apply","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",4,3,3,2,"The question is highly relevant to Objects and Classes, testing understanding of constructors and getter methods. However, accuracy is compromised because the actual Circle class implementation is not provided—we must assume the constructor calls setRadius(r) based only on the explanation. This creates ambiguity; the constructor could theoretically do something different. Explainability is weak because explanations lack specificity about *how* the constructor works (e.g., ""The constructor new Circle(10) sets the radius to 10.0"" assumes implementation details not shown). The distractors are reasonable but somewhat generic. Bloom alignment is borderline between ""Understand"" (recall that constructors initialize objects) and ""Apply"" (applying knowledge of constructors to predict output), leaning toward lower-level understanding rather than true application."
1b88bea3-b2ef-43de-8e06-f380d3ca642a,2025-11-25T11:10:50.007186,Objects and Classes,Analyze,"Given the Circle class example, which statement best analyzes the relationship between a class and its objects in Java?","A class defines the structure and behavior of its objects, while objects are specific instances with unique data.","Objects define methods, and classes only provide storage for data fields.",An object’s data fields and methods are unrelated to its class.,A class can only have one object at a time.,A,"Correct; the class is the blueprint, and objects are instances with unique states.","Incorrect; classes define both data fields and methods, not just storage.",Incorrect; objects’ data and methods are defined by their class.,Incorrect; multiple objects can be created from a class.,"In Java, a class acts as a template (blueprint) defining data fields and methods, while objects are concrete instances that each have their own data but share the structure and behavior defined by the class.","Question: Given the Circle class example, which statement best analyzes the relationship between a class and its objects in Java?

Options:
A) A class defines the structure and behavior of its objects, while objects are specific instances with unique data.
B) Objects define methods, and classes only provide storage for data fields.
C) An object’s data fields and methods are unrelated to its class.
D) A class can only have one object at a time.

Correct Answer: A

Option A explanation: Correct; the class is the blueprint, and objects are instances with unique states.
Option B explanation: Incorrect; classes define both data fields and methods, not just storage.
Option C explanation: Incorrect; objects’ data and methods are defined by their class.
Option D explanation: Incorrect; multiple objects can be created from a class.

Main Explanation: In Java, a class acts as a template (blueprint) defining data fields and methods, while objects are concrete instances that each have their own data but share the structure and behavior defined by the class.

Tags: Objects and Classes, Analyze","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,4,5,5,"The question directly assesses the fundamental concept of classes and objects in Java, which is core to object-oriented programming. All options address this relationship clearly. The correct answer (A) accurately describes the blueprint/instance relationship. Distractors (B, C, D) are all technically incorrect and represent common misconceptions—B reverses the relationship, C denies the connection, and D misunderstands instantiation cardinality. Explanations are concise and specific, correctly identifying why each option is right or wrong. For Bloom's ""Analyze,"" the question asks students to examine the relationship between two concepts and distinguish between correct and incorrect characterizations, which aligns well with analysis-level thinking. A minor note: the question could push higher on Bloom's scale (Evaluate/Create) by asking students to apply this understanding to a code scenario, but the current framing solidly meets the analysis level."
2bad5e8b-938d-4998-9587-085b370b6dc1,2025-11-25T11:10:59.701437,Objects and Classes,Analyze,"Given the lecture's Circle class example, which statement best analyzes the relationship between a class and its objects?","A class is a blueprint, and each object is a distinct instance with its own state.",Objects and classes are the same and used interchangeably in Java.,An object defines the data fields and methods for its class.,"A class is a variable, while the object is its data type.",A,Correct; the lecture states a class is a template and each object is an instance with its own state.,Incorrect; the slides distinguish clearly between classes (templates) and objects (instances).,"Incorrect; the class defines data fields and methods, not the object.","Incorrect; the lecture states the class is like a data type, and the object is a variable of that type.","The lecture content emphasizes that a class provides the blueprint for objects, and each object has its own identity and state, making option A the correct analysis.","Question: Given the lecture's Circle class example, which statement best analyzes the relationship between a class and its objects?

Options:
A) A class is a blueprint, and each object is a distinct instance with its own state.
B) Objects and classes are the same and used interchangeably in Java.
C) An object defines the data fields and methods for its class.
D) A class is a variable, while the object is its data type.

Correct Answer: A

Option A explanation: Correct; the lecture states a class is a template and each object is an instance with its own state.
Option B explanation: Incorrect; the slides distinguish clearly between classes (templates) and objects (instances).
Option C explanation: Incorrect; the class defines data fields and methods, not the object.
Option D explanation: Incorrect; the lecture states the class is like a data type, and the object is a variable of that type.

Main Explanation: The lecture content emphasizes that a class provides the blueprint for objects, and each object has its own identity and state, making option A the correct analysis.

Tags: Objects and Classes, Analyze","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,4,5,5,"The question directly assesses the fundamental relationship between classes and objects, a core OOP concept. All options are technically accurate and represent common misconceptions (B, C, D) or correct understanding (A). Explanations are clear and reference the lecture content appropriately. The question requires analysis by asking students to evaluate different statements about the class-object relationship, though it leans slightly toward comprehension since recognizing the correct blueprint-instance relationship is somewhat foundational. The distractors effectively target common confusion points (interchangeability, role reversal, variable/type confusion), making this a well-constructed question suitable for assessing OOP conceptual understanding."
addba012-d414-45e9-ab0b-2daa05d0ed27,2025-11-25T11:11:13.097918,Objects and Classes,Evaluate,"Given the lecture’s discussion, which statement best evaluates the relationship between a class and an object in Java?",A class is an instance of an object.,An object is a template used to create classes.,A class is a template; an object is a variable of that type.,An object defines the methods that a class can use.,C,Incorrect; a class is not an instance of an object.,Incorrect; an object is not a template.,"Correct; the lecture states a class is a template, and an object is a variable of that type.","Incorrect; classes define methods, not objects.","The lecture specifies that a class is a template or blueprint, while an object is an instance or variable of that class, making option C correct.","Question: Given the lecture’s discussion, which statement best evaluates the relationship between a class and an object in Java?

Options:
A) A class is an instance of an object.
B) An object is a template used to create classes.
C) A class is a template; an object is a variable of that type.
D) An object defines the methods that a class can use.

Correct Answer: C

Option A explanation: Incorrect; a class is not an instance of an object.
Option B explanation: Incorrect; an object is not a template.
Option C explanation: Correct; the lecture states a class is a template, and an object is a variable of that type.
Option D explanation: Incorrect; classes define methods, not objects.

Main Explanation: The lecture specifies that a class is a template or blueprint, while an object is an instance or variable of that class, making option C correct.

Tags: Objects and Classes, Evaluate","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,2,5,5,"The question directly assesses the fundamental concept of classes and objects in Java (relevance: excellent). The correct answer (C) and distractors are technically accurate and represent common misconceptions (accuracy: excellent). Explanations are clear and specific, directly addressing why each option is correct or incorrect (explainability: excellent). However, the cognitive demand does not match the stated Bloom level of ""Evaluate."" The question asks students to identify/recognize the correct relationship (Bloom Level 1-2: Remember/Understand), not to evaluate, judge, or critically assess competing claims. To align with ""Evaluate,"" the question would need to ask students to assess trade-offs, justify design choices, or critique different approaches to class/object design. The question is well-constructed but misaligned with its stated Bloom objective."
b568d99b-a98a-4be8-b145-222ceeed5abe,2025-11-25T11:11:25.335097,Objects and Classes,Evaluate,"Given the following code, which statement best evaluates the relationship between objects and classes in Java?

public class Circle {
    private double radius = 1.0;
    // Constructors and methods omitted for brevity
}
Circle c1 = new Circle(5);",c1 is an object and Circle is its class.,Circle is an object and c1 is its class.,Both c1 and Circle are objects.,Both c1 and Circle are classes.,A,"Correct. c1 is an object (instance), and Circle is its class (blueprint/template).","Incorrect. Circle is the class, not the object.",Incorrect. Only c1 is the object; Circle is the class.,Incorrect. Only Circle is a class; c1 is an object.,"In Java, a class is a blueprint (Circle), and an object (c1) is an instance of that class, matching the relationship described in the lecture content.","Question: Given the following code, which statement best evaluates the relationship between objects and classes in Java?

public class Circle {
    private double radius = 1.0;
    // Constructors and methods omitted for brevity
}
Circle c1 = new Circle(5);

Options:
A) c1 is an object and Circle is its class.
B) Circle is an object and c1 is its class.
C) Both c1 and Circle are objects.
D) Both c1 and Circle are classes.

Correct Answer: A

Option A explanation: Correct. c1 is an object (instance), and Circle is its class (blueprint/template).
Option B explanation: Incorrect. Circle is the class, not the object.
Option C explanation: Incorrect. Only c1 is the object; Circle is the class.
Option D explanation: Incorrect. Only Circle is a class; c1 is an object.

Main Explanation: In Java, a class is a blueprint (Circle), and an object (c1) is an instance of that class, matching the relationship described in the lecture content.

Tags: Objects and Classes, Evaluate","{
int next = fin.nextInt();
if (next % 2 == 1) {
fout.printf(""%d%n"", next);
}
}
} catch (FileNotFoundException ex) {
System.out.printf(""File not found!%n"");
System.exit(0);
} catch (IOException ex) {
System.out.printf(""IO error occurred!%n"");
System.exit(0);
}
Take Home Points
If all of this made sense, you are ready for COMP1050
Note: most OOP content was ignored – that’s this class!

If you had troubles, the complete set of COMP1000 slides are on Blackboard, including exercises for you to try
Also feel free to talk with me!

School of Computing & Data Science
Professor Folajimi
Welcome to COMP1050!
School of Computing & Data Science
Objects and Classes
School of Computing & Data Science
OOP Concepts
COMP1050
10
Professor Folajimi
Object-oriented programming (OOP) involves programming using objects.
» An object represents an entity in the real world that can be distinctly identified, such as a desk, a button, a car, etc.
An object has…
» Unique identity (think memory address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general

===== CHUNK BREAK =====

Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {
private double radius = 1.0;

public Circle() {
}

public Circle(double r) { setRadius(r);
}
public double getRadius() { return radius;
}
public void setRadius(double r) { if (r>0) {
radius = r;
}
}
public double getArea() {
return Math.PI * radius * radius;
}
}
Circle.java
Anywhere
School of Computing & Data Science
Output: Circles
COMP1050
10
Professor Folajimi
School of Computing & Data Science
UML: Circles
c1: Circle
radius = 5
c2: Circle
radius = 10
c3: Circle
radius = 5
c4: Circle
radius = 1
COMP1050
10
Professor Folajimi
School of Computing & Data Science
Constructors
COMP1050
10
Professor Folajimi
A constructor is a special type of method that is invoked to construct an object from its class
All classes have at least one constructor
All constructor(s) for a class…
» Have the same name as the class
» Have no return type (not even void)
» A constructor with no parameters is referred to as a no-arg constructor",5,2,5,5,"The question directly assesses understanding of the fundamental object-class relationship in Java, which is highly relevant. However, the cognitive demand does NOT match the stated Bloom level of ""Evaluate."" This question requires only ""Remember"" or ""Understand"" (Bloom levels 1-2)—students must simply recall or recognize the definition of objects versus classes, not evaluate, analyze, or make judgments about complex scenarios. The correct answer (A) and distractors are technically accurate and clearly explained. The explanations effectively distinguish between the concepts and reference the blueprint/template metaphor. To align with ""Evaluate,"" the question would need to ask students to judge trade-offs, assess design decisions, or critique code based on object-oriented principles."
f8e6bdbf-e5d0-49bc-924c-71f66275cd65,2025-11-25T11:11:35.939491,Inheritance,Remember,"In Java, which class is the root superclass of all other classes?",Object,Pet,Main,String,A,Correct. The Object class is the root superclass of all Java classes.,"Incorrect. Pet is a user-defined class, not the root superclass.",Incorrect. Main is a common class name but not a superclass of all classes.,"Incorrect. String is a commonly used class, but it is not the root superclass.","According to the slides, the Object class is the root superclass from which all other Java classes implicitly extend, unless another class is explicitly extended.","Question: In Java, which class is the root superclass of all other classes?

Options:
A) Object
B) Pet
C) Main
D) String

Correct Answer: A

Option A explanation: Correct. The Object class is the root superclass of all Java classes.
Option B explanation: Incorrect. Pet is a user-defined class, not the root superclass.
Option C explanation: Incorrect. Main is a common class name but not a superclass of all classes.
Option D explanation: Incorrect. String is a commonly used class, but it is not the root superclass.

Main Explanation: According to the slides, the Object class is the root superclass from which all other Java classes implicitly extend, unless another class is explicitly extended.

Tags: Inheritance, Remember","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,5,5,5,"This is an excellent foundational question on Java inheritance. (1) Relevance: Directly assesses understanding of the inheritance hierarchy and the Object class as the universal superclass—core to inheritance concepts. (2) Accuracy: All components are technically correct. Object is indeed the implicit superclass of all Java classes. Distractors are well-chosen: Pet is clearly user-defined, Main is a common but irrelevant class name, and String is a real class but not a superclass. (3) Explainability: Explanations are clear and concise. The overall explanation correctly references implicit extension and provides context. Each option explanation directly addresses why it is correct or incorrect. (4) Bloom Alignment: This question perfectly targets the ""Remember"" level—it asks students to recall a fundamental fact about Java's class hierarchy, which is appropriate for foundational knowledge assessment. The question uses straightforward recall language ('which class') without requiring analysis or application."
6046d841-6f89-4f53-ab0f-c0adfcd8a636,2025-11-25T11:11:44.788741,Inheritance,Remember,"In Java, what is the root superclass that every class implicitly extends unless it explicitly extends another class?",Object,Main,Pet,String,A,Correct. The Object class is the root superclass of all Java classes.,"Incorrect. ""Main"" is not a superclass in Java; it's just a class name.","Incorrect. ""Pet"" is an example class from the slides, not the root superclass.","Incorrect. ""String"" is a class but not the superclass of all classes.","According to the slides, ""The Object class is the root superclass of all Java classes. Every class in Java implicitly extends Object, unless it explicitly extends another class.""","Question: In Java, what is the root superclass that every class implicitly extends unless it explicitly extends another class?

Options:
A) Object
B) Main
C) Pet
D) String

Correct Answer: A

Option A explanation: Correct. The Object class is the root superclass of all Java classes.
Option B explanation: Incorrect. ""Main"" is not a superclass in Java; it's just a class name.
Option C explanation: Incorrect. ""Pet"" is an example class from the slides, not the root superclass.
Option D explanation: Incorrect. ""String"" is a class but not the superclass of all classes.

Main Explanation: According to the slides, ""The Object class is the root superclass of all Java classes. Every class in Java implicitly extends Object, unless it explicitly extends another class.""

Tags: Inheritance, Remember","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,5,5,5,"This question directly assesses a fundamental concept in Java inheritance by testing whether students understand the implicit inheritance hierarchy. The correct answer (Object) is accurate and universally true in Java. The distractors are well-chosen: ""Main"" is a plausible distractor for beginners unfamiliar with Java terminology, ""Pet"" is contextually relevant (from course materials), and ""String"" is a real Java class that could confuse students. All explanations are clear and specific, correctly identifying why each option is right or wrong. The cognitive demand perfectly matches Bloom's ""Remember"" level—it requires students to recall a foundational definition directly stated in course materials. The question is well-constructed with no technical errors."
995b14ea-32e8-493b-8045-144f43007cfb,2025-11-25T11:11:54.771681,Inheritance,Understand,Which statement best describes the relationship between Java classes and the Object class with respect to inheritance?,Every class in Java implicitly extends the Object class unless it explicitly extends another class.,Only classes that do not extend any class explicitly inherit from the Object class.,Classes in Java can choose whether or not to inherit from the Object class.,Only abstract classes in Java extend the Object class by default.,A,"Correct; the slides state that every class in Java implicitly extends Object, unless it explicitly extends another class.","Incorrect; even if a class extends another, the inheritance chain eventually leads to Object.",Incorrect; inheritance from Object is implicit for all classes.,Incorrect; there is no distinction for abstract classes regarding implicit inheritance from Object.,"All Java classes inherit from Object directly or indirectly, as Object is the root superclass. This is a fundamental aspect of inheritance in Java.","Question: Which statement best describes the relationship between Java classes and the Object class with respect to inheritance?

Options:
A) Every class in Java implicitly extends the Object class unless it explicitly extends another class.
B) Only classes that do not extend any class explicitly inherit from the Object class.
C) Classes in Java can choose whether or not to inherit from the Object class.
D) Only abstract classes in Java extend the Object class by default.

Correct Answer: A

Option A explanation: Correct; the slides state that every class in Java implicitly extends Object, unless it explicitly extends another class.
Option B explanation: Incorrect; even if a class extends another, the inheritance chain eventually leads to Object.
Option C explanation: Incorrect; inheritance from Object is implicit for all classes.
Option D explanation: Incorrect; there is no distinction for abstract classes regarding implicit inheritance from Object.

Main Explanation: All Java classes inherit from Object directly or indirectly, as Object is the root superclass. This is a fundamental aspect of inheritance in Java.

Tags: Inheritance, Understand","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,4,5,5,"The question directly assesses understanding of Java's inheritance hierarchy and the Object class's role as the root superclass, which is core to inheritance concepts. Option A is correct and well-supported; the distractors effectively target common misconceptions (conditional inheritance, choice-based inheritance, abstract class distinction). Explanations are clear and specific, addressing why each option is correct or incorrect. The cognitive demand aligns well with ""Understand"" level (Bloom's revised taxonomy), as it requires students to comprehend the implicit inheritance mechanism rather than merely recall facts. The question could arguably push toward ""Apply"" if it required identifying Object methods in a code scenario, but the current framing is solidly at the Understand level, which is appropriate and well-executed."
c8c2ec00-cf56-42ae-ab9d-cc773d95137d,2025-11-25T11:12:02.815145,Inheritance,Understand,Which statement about Java inheritance is correct?,Every class in Java implicitly extends Object unless it explicitly extends another class.,Only abstract classes can be superclasses in Java.,A subclass can override a final method from its superclass.,The Object class is a subclass of all classes in Java.,A,Correct; all Java classes implicitly extend Object unless another superclass is specified.,"Incorrect; any class, not just abstract ones, can be a superclass.",Incorrect; final methods cannot be overridden.,"Incorrect; Object is the root superclass, not a subclass.","In Java, Object is the root superclass, and every class implicitly extends it unless another superclass is specified. This is fundamental to Java's inheritance model.","Question: Which statement about Java inheritance is correct?

Options:
A) Every class in Java implicitly extends Object unless it explicitly extends another class.
B) Only abstract classes can be superclasses in Java.
C) A subclass can override a final method from its superclass.
D) The Object class is a subclass of all classes in Java.

Correct Answer: A

Option A explanation: Correct; all Java classes implicitly extend Object unless another superclass is specified.
Option B explanation: Incorrect; any class, not just abstract ones, can be a superclass.
Option C explanation: Incorrect; final methods cannot be overridden.
Option D explanation: Incorrect; Object is the root superclass, not a subclass.

Main Explanation: In Java, Object is the root superclass, and every class implicitly extends it unless another superclass is specified. This is fundamental to Java's inheritance model.

Tags: Inheritance, Understand","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,4,5,5,"The question directly assesses core inheritance concepts (Object as root superclass, implicit extension, final method immutability, and superclass eligibility). All explanations are technically accurate and clear. Option B and D are strong distractors that test common misconceptions. The cognitive demand slightly exceeds basic ""Understand"" level—it requires students to recall and distinguish between multiple inheritance rules simultaneously, approaching ""Apply"" on Bloom's taxonomy, though the question format remains recognition-based rather than requiring application to new scenarios."
3c0522c1-1d94-460d-ba82-6f9bf3cdd5ba,2025-11-25T11:12:13.948911,Inheritance,Apply,"Given the following code, what will be printed to the console?

class Pet {
    String name, id;
    public Pet(String name, String id) { this.name = name; this.id = id; }
    @Override
    public String toString() { return name + "" ("" + id + "")""; }
}
public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234"");
        System.out.println(pet1);
    }
}",Spot (1234),Pet@70dea4e,name (id),"""Spot"", ""1234""",A,"Correct; Pet overrides toString() to return ""name (id)"", so Spot (1234) is printed.",Incorrect; this would be printed if toString() was not overridden.,"Incorrect; this is a generic placeholder, not the actual output.",Incorrect; this is not how toString() returns the object’s state.,"The code overrides the toString() method in Pet to output ""name (id)"", so when pet1 is printed, it displays Spot (1234).","Question: Given the following code, what will be printed to the console?

class Pet {
    String name, id;
    public Pet(String name, String id) { this.name = name; this.id = id; }
    @Override
    public String toString() { return name + "" ("" + id + "")""; }
}
public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234"");
        System.out.println(pet1);
    }
}

Options:
A) Spot (1234)
B) Pet@70dea4e
C) name (id)
D) ""Spot"", ""1234""

Correct Answer: A

Option A explanation: Correct; Pet overrides toString() to return ""name (id)"", so Spot (1234) is printed.
Option B explanation: Incorrect; this would be printed if toString() was not overridden.
Option C explanation: Incorrect; this is a generic placeholder, not the actual output.
Option D explanation: Incorrect; this is not how toString() returns the object’s state.

Main Explanation: The code overrides the toString() method in Pet to output ""name (id)"", so when pet1 is printed, it displays Spot (1234).

Tags: Inheritance, Apply","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",2,3,5,5,"While this question tests method overriding (a key OOP concept), it only tangentially relates to inheritance. The question primarily assesses understanding of the toString() override mechanism and how System.out.println() calls it, rather than inheritance principles like polymorphism across class hierarchies or parent-child relationships. The correct answer and distractors are technically accurate—Option B correctly shows what the default Object.toString() produces, and other options represent plausible misconceptions. Explanations are clear and specific, correctly identifying why each option is right or wrong. However, Bloom alignment is slightly below ""Apply"" level; this is closer to ""Understand"" (recognizing what overridden toString() does) rather than ""Apply"" (using inheritance/polymorphism in a novel context). To better assess ""Apply,"" the question could require students to predict output across multiple classes in an inheritance hierarchy or determine which class's toString() executes in a polymorphic scenario."
dadbdb0f-cdad-43d0-9d1f-0fd3c0a19738,2025-11-25T11:12:27.014827,Inheritance,Apply,"Given class Pet and its subclass Dog4, which statement correctly demonstrates polymorphism and inheritance?","Pet2 myPet = new Dog4(""Spot"", ""1234"");","Dog4 myDog = new Pet2(""Spot"", ""1234"");","Pet2 myPet = new Pet2(""Spot"", ""1234"");","Object myObj = new Pet2(""Spot"", ""1234"");",A,"Correct; a Pet2 variable can refer to a Dog4 object, demonstrating polymorphism and inheritance.",Incorrect; you cannot assign a superclass object (Pet2) to a subclass variable (Dog4) without an explicit cast.,"Incorrect; while valid, this does not demonstrate inheritance or polymorphism (no subclass involved).","Incorrect; while valid due to inheritance, this demonstrates upcasting to Object, not specifically inheritance between Pet2 and Dog4.","Inheritance allows a variable of a superclass type to refer to an object of its subclass, enabling polymorphism. Option A demonstrates this principle.","Question: Given class Pet and its subclass Dog4, which statement correctly demonstrates polymorphism and inheritance?

Options:
A) Pet2 myPet = new Dog4(""Spot"", ""1234"");
B) Dog4 myDog = new Pet2(""Spot"", ""1234"");
C) Pet2 myPet = new Pet2(""Spot"", ""1234"");
D) Object myObj = new Pet2(""Spot"", ""1234"");

Correct Answer: A

Option A explanation: Correct; a Pet2 variable can refer to a Dog4 object, demonstrating polymorphism and inheritance.
Option B explanation: Incorrect; you cannot assign a superclass object (Pet2) to a subclass variable (Dog4) without an explicit cast.
Option C explanation: Incorrect; while valid, this does not demonstrate inheritance or polymorphism (no subclass involved).
Option D explanation: Incorrect; while valid due to inheritance, this demonstrates upcasting to Object, not specifically inheritance between Pet2 and Dog4.

Main Explanation: Inheritance allows a variable of a superclass type to refer to an object of its subclass, enabling polymorphism. Option A demonstrates this principle.
 
Tags: Inheritance, Apply","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",4,3,4,3,"The question directly assesses inheritance and polymorphism concepts (high relevance), though the phrasing could be more precise. The correct answer and explanations are technically accurate—Option A correctly demonstrates polymorphism via upcasting, and the distractors are properly rejected with valid reasoning. However, there are minor issues: (1) Option B's explanation could clarify that downcasting without a cast operator is a compile error, (2) Option D's explanation somewhat dismisses a valid demonstration of inheritance (Object is the ultimate superclass), and (3) the question conflates ""Pet"" with ""Pet2"" in the stem, creating potential confusion. The cognitive demand sits between ""Understand"" and ""Apply""—students must recognize correct polymorphic assignment patterns, which requires some application of concepts but is somewhat formulaic. The question would benefit from clearer class naming consistency and more nuanced discussion of why Option D, while valid, is less ideal than Option A for demonstrating the Pet2-Dog4 relationship specifically."
b470f73e-33b8-4ed7-887e-af545792c61a,2025-11-25T11:12:39.479381,Inheritance,Analyze,"Given the following code, which statement best explains the relationship between Pet and Object based on Java inheritance?

class Pet {
    String name, id;
}","Pet explicitly extends Object, so it is a subclass of Object.","Pet implicitly extends Object, so it is a subclass of Object.",Pet does not extend Object and has no superclass.,Pet must extend another user-defined class before it can use Object methods.,B,Incorrect. Pet does not explicitly extend Object in the code.,Correct. All classes in Java implicitly extend Object unless they extend another class.,"Incorrect. In Java, all classes have Object as a superclass unless specified otherwise.",Incorrect. Pet can use Object methods without extending another user-defined class.,"In Java, every class implicitly extends Object if no other superclass is specified, making Pet a subclass of Object even without explicit extension.","Question: Given the following code, which statement best explains the relationship between Pet and Object based on Java inheritance?

class Pet {
    String name, id;
}

Options:
A) Pet explicitly extends Object, so it is a subclass of Object.
B) Pet implicitly extends Object, so it is a subclass of Object.
C) Pet does not extend Object and has no superclass.
D) Pet must extend another user-defined class before it can use Object methods.

Correct Answer: B

Option A explanation: Incorrect. Pet does not explicitly extend Object in the code.
Option B explanation: Correct. All classes in Java implicitly extend Object unless they extend another class.
Option C explanation: Incorrect. In Java, all classes have Object as a superclass unless specified otherwise.
Option D explanation: Incorrect. Pet can use Object methods without extending another user-defined class.

Main Explanation: In Java, every class implicitly extends Object if no other superclass is specified, making Pet a subclass of Object even without explicit extension.

Tags: Inheritance, Analyze","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,3,5,5,"The question directly assesses understanding of Java inheritance, specifically the implicit extension of Object class. All explanations are technically accurate and clearly distinguish between explicit and implicit inheritance. Option A correctly identifies explicit extension doesn't occur, Option C correctly notes all classes have Object as superclass, and Option D correctly clarifies that direct user-defined extension isn't required. However, the cognitive demand aligns more with Bloom's ""Understand"" (level 2) rather than ""Analyze"" (level 4), as it primarily tests recall and comprehension of a Java language rule rather than requiring analysis of relationships, comparison of inheritance mechanisms, or evaluation of design patterns. The question asks students to identify and explain a fundamental concept rather than break it down, examine its components, or apply it to complex scenarios."
d3c5fd7e-1cc2-419e-9efc-5dca6f782205,2025-11-25T11:12:50.589425,Inheritance,Analyze,"Given that every class in Java implicitly extends Object, which of the following statements about inheritance is TRUE?",All Java classes inherit methods from Object unless they explicitly extend another class.,A subclass can override static methods from Object.,Only classes that directly extend Object inherit its methods.,Inheritance in Java prevents overriding of superclass methods.,A,Correct; every Java class inherits methods from Object unless it explicitly extends another class.,Incorrect; static methods cannot be overridden.,"Incorrect; all Java classes, even if they extend another class, ultimately inherit from Object.",Incorrect; overriding is a key feature of inheritance.,"Inheritance ensures all classes receive Object’s methods, and overriding (except for static/final methods) is allowed in subclasses.","Question: Given that every class in Java implicitly extends Object, which of the following statements about inheritance is TRUE?

Options:
A) All Java classes inherit methods from Object unless they explicitly extend another class.
B) A subclass can override static methods from Object.
C) Only classes that directly extend Object inherit its methods.
D) Inheritance in Java prevents overriding of superclass methods.

Correct Answer: A

Option A explanation: Correct; every Java class inherits methods from Object unless it explicitly extends another class.
Option B explanation: Incorrect; static methods cannot be overridden.
Option C explanation: Incorrect; all Java classes, even if they extend another class, ultimately inherit from Object.
Option D explanation: Incorrect; overriding is a key feature of inheritance.

Main Explanation: Inheritance ensures all classes receive Object’s methods, and overriding (except for static/final methods) is allowed in subclasses.

Tags: Inheritance, Analyze","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,3,4,4,"The question directly assesses inheritance concepts (Object class, implicit extension, method inheritance). Accuracy is strong overall—A is correct and B, C, D are legitimate distractors—though the phrasing ""unless they explicitly extend another class"" in option A could be slightly clearer (all classes still ultimately inherit from Object). Explainability is clear with specific technical details (static methods cannot be overridden, overriding is allowed). However, Bloom alignment is lower than ""Analyze""—the question primarily requires students to recall/understand that all classes inherit from Object and recognize true statements, which aligns better with Bloom's ""Understand"" (level 2) rather than ""Analyze"" (level 4). To reach ""Analyze,"" the question would need to ask students to compare inheritance mechanisms, evaluate scenarios, or explain consequences of design choices."
76a1c724-f4d4-4984-a317-3193313131b1,2025-11-25T11:13:04.272686,Inheritance,Evaluate,"Given that all classes in Java implicitly extend Object, which statement best evaluates the relationship between Dog4, Pet2, and Object?","Dog4 is a subtype of Pet2, and both are subtypes of Object.","Pet2 is a subtype of Dog4, and Dog4 is a subtype of Object.","Object is a subtype of Pet2, which is a subtype of Dog4.",Only Dog4 extends Object; Pet2 does not.,A,"Correct. Dog4 is a subtype of Pet2, and both ultimately inherit from Object, the root class.","Incorrect. Pet2 is the superclass of Dog4, not the other way around.","Incorrect. Object is the root superclass, not a subtype of any user-defined class.",Incorrect. All Java classes (including Pet2) implicitly extend Object unless they extend another class.,"In Java's inheritance hierarchy, every class extends Object either directly or indirectly. Dog4 extends Pet2, and both are subtypes of Object, the root of all classes.","Question: Given that all classes in Java implicitly extend Object, which statement best evaluates the relationship between Dog4, Pet2, and Object?

Options:
A) Dog4 is a subtype of Pet2, and both are subtypes of Object.
B) Pet2 is a subtype of Dog4, and Dog4 is a subtype of Object.
C) Object is a subtype of Pet2, which is a subtype of Dog4.
D) Only Dog4 extends Object; Pet2 does not.

Correct Answer: A

Option A explanation: Correct. Dog4 is a subtype of Pet2, and both ultimately inherit from Object, the root class.
Option B explanation: Incorrect. Pet2 is the superclass of Dog4, not the other way around.
Option C explanation: Incorrect. Object is the root superclass, not a subtype of any user-defined class.
Option D explanation: Incorrect. All Java classes (including Pet2) implicitly extend Object unless they extend another class.

Main Explanation: In Java's inheritance hierarchy, every class extends Object either directly or indirectly. Dog4 extends Pet2, and both are subtypes of Object, the root of all classes.

Tags: Inheritance, Evaluate","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,2,5,5,"The question directly assesses understanding of Java inheritance and the Object class hierarchy, making it highly relevant. However, the cognitive demand is primarily at the Understand/Remember level (Bloom 2), not Evaluate (Bloom 5) as claimed. Students need to recall that all classes extend Object and recognize the inheritance chain, but they are not evaluating trade-offs, making judgments about quality, or critically analyzing competing claims—all of which would constitute evaluation. The correct answer and distractors are technically accurate and represent common misconceptions (e.g., confusing subtype/supertype relationships, misunderstanding implicit Object inheritance). Explanations are clear and specific, directly addressing why each option is correct or incorrect with precise terminology."
f23de673-c36b-4153-a02e-43ccea837353,2025-11-25T11:13:15.247286,Inheritance,Evaluate,"Given the class definition 'class Pet { ... }' and knowing 'Object' is the superclass of all Java classes, which statement best evaluates the relationship between 'Pet' and 'Object'?",Pet explicitly extends Object and inherits its methods.,Pet implicitly extends Object and inherits its methods.,Pet does not inherit from Object unless stated explicitly.,Pet is unrelated to Object unless it overrides Object's methods.,B,Incorrect; Pet does not need to explicitly extend Object to inherit from it.,Correct; every class in Java implicitly extends Object and inherits its methods.,"Incorrect; inheritance from Object is implicit, not explicit.",Incorrect; relationship exists regardless of overriding methods.,"In Java, every class implicitly extends Object unless another superclass is specified, so Pet automatically inherits Object's methods.","Question: Given the class definition 'class Pet { ... }' and knowing 'Object' is the superclass of all Java classes, which statement best evaluates the relationship between 'Pet' and 'Object'?

Options:
A) Pet explicitly extends Object and inherits its methods.
B) Pet implicitly extends Object and inherits its methods.
C) Pet does not inherit from Object unless stated explicitly.
D) Pet is unrelated to Object unless it overrides Object's methods.

Correct Answer: B

Option A explanation: Incorrect; Pet does not need to explicitly extend Object to inherit from it.
Option B explanation: Correct; every class in Java implicitly extends Object and inherits its methods.
Option C explanation: Incorrect; inheritance from Object is implicit, not explicit.
Option D explanation: Incorrect; relationship exists regardless of overriding methods.

Main Explanation: In Java, every class implicitly extends Object unless another superclass is specified, so Pet automatically inherits Object's methods.

Tags: Inheritance, Evaluate","plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

"", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

ther class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

    @Override
    public String toString() { return name + "" ("" + id + "")""; }

    @Override
    public boolean equals(Object obj) { return obj instanceof Pet && this.id.equals(((Pet) obj).id); }
}

public class Main {
    public static void main(String[] args) {
        Pet pet1 = new Pet(""Spot"", ""1234""), pet2 = new Pet(""Rover"", ""1234"");
        System.out.println(pet1); // Output: Spot (1234)
        System.out.println(pet1.equals(pet2)); // Output: true
    }
}
Dynamic Binding
When an object’s method is invoked, the implementation that is used will be determined by the JVM at runtime – this capability is known as dynamic binding
The JVM searches the implementations for the method from the most specific to the most general
Once an implementation is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general",5,2,5,5,"The question directly assesses understanding of Java inheritance and the implicit Object superclass relationship, making it highly relevant. However, the cognitive demand falls short of ""Evaluate"" level—the question asks students to identify/understand a fact about Java's class hierarchy rather than evaluate, judge, or make decisions based on criteria. This is closer to Bloom's ""Understand"" (level 2) than ""Evaluate"" (level 5). The correct answer is accurate, and all distractors are reasonable misconceptions. The explanations are clear and specific, correctly identifying why each option is right or wrong. To better align with Bloom's ""Evaluate,"" the question could ask students to judge design decisions, compare inheritance approaches, or assess code quality implications."
f7289554-e371-4d72-ae52-ec67545ac130,2025-11-25T11:13:36.941919,Polymorphism,Remember,"In Java, what is polymorphism as described in the lecture slides?",A variable of a supertype can refer to a subtype object.,A subclass can have multiple superclasses.,Only final methods can be overridden.,Variables cannot reference objects of their own class.,A,Correct; the slides state that polymorphism allows a variable of a supertype to refer to a subtype object.,Incorrect; Java does not support multiple inheritance for classes.,"Incorrect; final methods cannot be overridden, as stated in the slides.",Incorrect; this is not related to polymorphism and is not stated in the slides.,"Polymorphism in Java refers to the ability of a supertype variable to reference objects of its subtypes, enabling more flexible and reusable code.","Question: In Java, what is polymorphism as described in the lecture slides?

Options:
A) A variable of a supertype can refer to a subtype object.
B) A subclass can have multiple superclasses.
C) Only final methods can be overridden.
D) Variables cannot reference objects of their own class.

Correct Answer: A

Option A explanation: Correct; the slides state that polymorphism allows a variable of a supertype to refer to a subtype object.
Option B explanation: Incorrect; Java does not support multiple inheritance for classes.
Option C explanation: Incorrect; final methods cannot be overridden, as stated in the slides.
Option D explanation: Incorrect; this is not related to polymorphism and is not stated in the slides.

Main Explanation: Polymorphism in Java refers to the ability of a supertype variable to reference objects of its subtypes, enabling more flexible and reusable code.

Tags: Polymorphism, Remember",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,2,4,4,"The question directly assesses polymorphism, which is the core concept. Option A correctly identifies the key definition of polymorphism in Java. The distractors are reasonable and address common misconceptions (B: multiple inheritance, C: final methods, D: unrelated statement). Explanations are clear and specific. However, Bloom alignment is weak—this question only requires remembering a definition from lecture slides rather than understanding, applying, or analyzing polymorphism. The cognitive demand is at the ""Remember"" level, not higher-order thinking. Accuracy is strong (4/5) because while the explanations are sound, Option C's explanation could be slightly more precise about the relationship between final methods and overriding."
90308c9e-3c59-45a2-92f3-3212d15d359b,2025-11-25T11:13:47.697468,Polymorphism,Remember,"In Java, what is polymorphism as described in the slides?",A variable of a supertype can refer to a subtype object,A class can only refer to objects of its own type,Only methods with different names can exist in subclasses,Variables cannot refer to objects of subclasses,A,Correct; polymorphism allows a supertype variable to refer to a subtype object.,Incorrect; polymorphism specifically allows reference to subtype objects.,Incorrect; this statement is unrelated to polymorphism.,Incorrect; variables can refer to subclass objects due to polymorphism.,"Polymorphism is when a variable of a supertype can refer to a subtype object, enabling flexible and reusable code structures.","Question: In Java, what is polymorphism as described in the slides?

Options:
A) A variable of a supertype can refer to a subtype object
B) A class can only refer to objects of its own type
C) Only methods with different names can exist in subclasses
D) Variables cannot refer to objects of subclasses

Correct Answer: A

Option A explanation: Correct; polymorphism allows a supertype variable to refer to a subtype object.
Option B explanation: Incorrect; polymorphism specifically allows reference to subtype objects.
Option C explanation: Incorrect; this statement is unrelated to polymorphism.
Option D explanation: Incorrect; variables can refer to subclass objects due to polymorphism.

Main Explanation: Polymorphism is when a variable of a supertype can refer to a subtype object, enabling flexible and reusable code structures.

Tags: Polymorphism, Remember",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,2,4,4,"The question directly assesses polymorphism as a core OOP concept. Option A correctly identifies the fundamental definition of polymorphism (supertype variable referencing subtype object). Distractors B, C, and D are all clearly incorrect and test understanding of what polymorphism is NOT. However, the cognitive demand exceeds ""Remember""—it requires understanding the relationship between supertypes and subtypes, which aligns more with Bloom's ""Understand"" level rather than simple recall. The explanations are clear and specific, though they could be slightly more detailed about runtime behavior and method overriding. Accuracy is strong overall, though the question could be enhanced by including a code example or asking about method invocation behavior to better assess deeper polymorphic understanding."
6a6454d7-8a5f-4744-a9fb-b0dc254b9af3,2025-11-25T11:14:01.513173,Polymorphism,Understand,"In the lecture, Dog4 is described as a subtype of Pet2. What does this mean in terms of polymorphism?",A variable of type Pet2 can refer to a Dog4 object.,A variable of type Dog4 can refer to a Pet2 object.,Dog4 cannot override any methods from Pet2.,Pet2 is a subtype of Dog4.,A,"Correct. In polymorphism, a supertype variable (Pet2) can refer to a subtype object (Dog4).",Incorrect. A Dog4 variable cannot refer to a Pet2 object; this is not allowed.,Incorrect. Dog4 can override methods from Pet2.,"Incorrect. Pet2 is the supertype, not the subtype.","Polymorphism allows a supertype reference (like Pet2) to point to objects of any subtype (like Dog4), enabling flexible and reusable code.","Question: In the lecture, Dog4 is described as a subtype of Pet2. What does this mean in terms of polymorphism?

Options:
A) A variable of type Pet2 can refer to a Dog4 object.
B) A variable of type Dog4 can refer to a Pet2 object.
C) Dog4 cannot override any methods from Pet2.
D) Pet2 is a subtype of Dog4.

Correct Answer: A

Option A explanation: Correct. In polymorphism, a supertype variable (Pet2) can refer to a subtype object (Dog4).
Option B explanation: Incorrect. A Dog4 variable cannot refer to a Pet2 object; this is not allowed.
Option C explanation: Incorrect. Dog4 can override methods from Pet2.
Option D explanation: Incorrect. Pet2 is the supertype, not the subtype.

Main Explanation: Polymorphism allows a supertype reference (like Pet2) to point to objects of any subtype (like Dog4), enabling flexible and reusable code.

Tags: Polymorphism, Understand",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,5,5,"The question directly assesses polymorphism through the lens of subtype relationships and variable assignment, which is a core polymorphic concept. All options are technically accurate—A correctly describes Liskov Substitution Principle, B correctly identifies an invalid assignment, C correctly notes that subtypes can override methods, and D correctly identifies the reversed relationship. Explanations are clear and concise, with proper terminology. The cognitive demand slightly exceeds ""Understand"" (Bloom 2) by requiring application of the subtype concept to determine valid variable assignments, placing it closer to ""Apply"" (Bloom 3), though it remains primarily conceptual understanding. This is a well-constructed question with strong pedagogical value."
6dbcc832-af0d-4927-8670-9e032db09584,2025-11-25T11:14:15.835687,Polymorphism,Understand,"Given Dog4 is a subtype of Pet2, which statement best describes polymorphism as used in the code?",A Pet2 variable can refer to a Dog4 object.,A Dog4 variable can refer to a Pet2 object.,Pet2 objects cannot be used in arrays with Dog4 and Cat4 objects.,Only Dog4 methods can be called on a Pet2 variable.,A,Correct; polymorphism allows a supertype variable (Pet2) to refer to subtype objects (Dog4).,Incorrect; a subtype variable (Dog4) cannot refer to a supertype object (Pet2).,Incorrect; the slides show Pet2[] arrays holding Dog4 and Cat4 objects.,"Incorrect; methods available depend on the reference type, not just the object's class.","Polymorphism allows a variable of a superclass type (Pet2) to refer to objects of its subclasses (Dog4, Cat4), enabling generalized code using a common supertype.","Question: Given Dog4 is a subtype of Pet2, which statement best describes polymorphism as used in the code?

Options:
A) A Pet2 variable can refer to a Dog4 object.
B) A Dog4 variable can refer to a Pet2 object.
C) Pet2 objects cannot be used in arrays with Dog4 and Cat4 objects.
D) Only Dog4 methods can be called on a Pet2 variable.

Correct Answer: A

Option A explanation: Correct; polymorphism allows a supertype variable (Pet2) to refer to subtype objects (Dog4).
Option B explanation: Incorrect; a subtype variable (Dog4) cannot refer to a supertype object (Pet2).
Option C explanation: Incorrect; the slides show Pet2[] arrays holding Dog4 and Cat4 objects.
Option D explanation: Incorrect; methods available depend on the reference type, not just the object's class.

Main Explanation: Polymorphism allows a variable of a superclass type (Pet2) to refer to objects of its subclasses (Dog4, Cat4), enabling generalized code using a common supertype.

Tags: Polymorphism, Understand",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,5,5,"The question directly assesses polymorphism through subtype-supertype relationships, which is the core concept. All options are technically accurate and well-reasoned distractors that address common misconceptions (B reverses the relationship, C tests knowledge of arrays, D confuses reference type with object type). Explanations are clear and specific, with the overall explanation effectively summarizing the polymorphic principle. Bloom alignment is strong at ""Understand"" level—students must comprehend how polymorphism works rather than merely recall it, though it stops short of ""Apply"" (designing polymorphic code) or ""Analyze"" (comparing different polymorphic scenarios). The question is well-constructed overall."
dfdda1ea-1e5f-43d6-b357-5768d8793ce3,2025-11-25T11:14:29.325269,Polymorphism,Apply,"Given the following code, what is the output?
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Cat4(""Mittens"", ""5432"", true)
};
for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}","Spot (1234) says 'woof'
   Mittens (5432) says 'meow'","Dog4 says 'woof'
   Cat4 says 'meow'","Spot says 'woof'
   Mittens says 'meow'","Spot (1234) says 'meow'
   Mittens (5432) says 'woof'",A,Correct; the output matches the example from the lecture slides and uses dynamic binding via polymorphism.,"Incorrect; the output includes object string representations, not just class names.","Incorrect; the output includes IDs in parentheses, which are missing here.",Incorrect; the animal sounds are reversed.,"Polymorphism ensures that the correct subclass implementation of says() is called, and the object’s string representation includes both the name and ID as shown in the lecture output.","Question: Given the following code, what is the output?
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Cat4(""Mittens"", ""5432"", true)
};
for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}

Options:
A) Spot (1234) says 'woof'
   Mittens (5432) says 'meow'
B) Dog4 says 'woof'
   Cat4 says 'meow'
C) Spot says 'woof'
   Mittens says 'meow'
D) Spot (1234) says 'meow'
   Mittens (5432) says 'woof'

Correct Answer: A

Option A explanation: Correct; the output matches the example from the lecture slides and uses dynamic binding via polymorphism.
Option B explanation: Incorrect; the output includes object string representations, not just class names.
Option C explanation: Incorrect; the output includes IDs in parentheses, which are missing here.
Option D explanation: Incorrect; the animal sounds are reversed.

Main Explanation: Polymorphism ensures that the correct subclass implementation of says() is called, and the object’s string representation includes both the name and ID as shown in the lecture output.
Tags: Polymorphism, Apply",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,3,3,"The question directly assesses polymorphism by requiring students to understand dynamic binding and method overriding in a inheritance hierarchy. However, accuracy is compromised because the question cannot be evaluated without seeing the actual class implementations (Pet2, Dog4, Cat4, their toString() methods, and says() implementations). The correct answer depends entirely on code not provided. Option A assumes specific toString() formatting and says() implementations that aren't shown. Explainability is limited because the explanations reference ""lecture slides"" and ""lecture output"" rather than explaining the underlying polymorphic principles or the actual code behavior. The explanations would be stronger if they explicitly traced through the polymorphic calls and explained why dynamic binding selects Dog4.says() and Cat4.says(). Bloom alignment is appropriate for ""Apply"" level—students must apply polymorphism concepts to predict output—though it borders on ""Understand"" since it's primarily about recognizing behavior rather than solving a novel problem. The question would be significantly stronger if all necessary class definitions were included."
22e37dbb-b6a5-4618-9a16-ba76c5cba76f,2025-11-25T11:14:45.910498,Polymorphism,Apply,"Given the following code, what is printed for each object in the loop?

Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Cat4(""Mittens"", ""5432"", true)
};
for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}",Spot (1234) says 'woof' \n Mittens (5432) says 'meow',Dog4 says 'woof' \n Cat4 says 'meow',Spot says 'woof' \n Mittens says 'meow',Pet2 says 'woof' \n Pet2 says 'meow',A,Correct; the objects' toString and says methods are called polymorphically as shown in the slides.,"Incorrect; the class name is not printed, but the object's toString method output is.","Incorrect; the toString output includes both name and ID, not just name.","Incorrect; Pet2 is the superclass, but the subclass implementations are used.","Due to polymorphism, the method calls to toString and says use the actual object's class (Dog4 or Cat4). This results in output matching Option A, as per the slide example.","Question: Given the following code, what is printed for each object in the loop?

Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Cat4(""Mittens"", ""5432"", true)
};
for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}

Options:
A) Spot (1234) says 'woof' \n Mittens (5432) says 'meow'
B) Dog4 says 'woof' \n Cat4 says 'meow'
C) Spot says 'woof' \n Mittens says 'meow'
D) Pet2 says 'woof' \n Pet2 says 'meow'

Correct Answer: A

Option A explanation: Correct; the objects' toString and says methods are called polymorphically as shown in the slides.
Option B explanation: Incorrect; the class name is not printed, but the object's toString method output is.
Option C explanation: Incorrect; the toString output includes both name and ID, not just name.
Option D explanation: Incorrect; Pet2 is the superclass, but the subclass implementations are used.

Main Explanation: Due to polymorphism, the method calls to toString and says use the actual object's class (Dog4 or Cat4). This results in output matching Option A, as per the slide example.

Tags: Polymorphism, Apply",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,4,4,"The question directly assesses polymorphism by requiring students to predict which overridden methods (toString and says) will be called at runtime based on actual object types rather than reference types. This is a core polymorphism concept.

Bloom alignment is strong (Apply level) - students must apply their understanding of polymorphism to predict output, though it borders on Analyze since they must trace execution flow.

Accuracy is very good. Option A is correct assuming standard implementations where Dog4/Cat4 override toString to include name and ID. Options B, C, and D effectively target common misconceptions (using class name, incomplete toString output, using superclass methods). However, slight concern: the question assumes specific toString implementations not shown in the code snippet, which could be ambiguous if implementations differ from expectations.

Explainability is clear and well-structured. Explanations correctly identify why each option is wrong and reinforce the polymorphism concept. The reference to 'slides' is somewhat vague for standalone assessment, but the core reasoning is sound.

Minor weaknesses: (1) The code snippet doesn't show the actual toString/says implementations, requiring students to infer or rely on prior context; (2) Option A's format ""(1234)"" is assumed without seeing the code; (3) The question woul"
98e3b305-8d95-4146-9026-c56b04cc3ee6,2025-11-25T11:15:03.701804,Polymorphism,Analyze,"Given the following code, what will be printed for each pet in the loop?

Pet2[] pets = {
    new Dog4(""Spot"", ""1234""),
    new Cat4(""Mittens"", ""5432"", true)
};
for (Pet2 p : pets) {
    System.out.printf(""%s says '%s'%n"", p, p.says());
}","Spot (1234) says 'woof'
   Mittens (5432) says 'meow'","Spot (1234) says 'meow'
   Mittens (5432) says 'woof'","Spot (1234) says 'meow'
   Mittens (5432) says 'meow'","Spot (1234) says 'woof'
   Mittens (5432) says 'woof'",A,"Correct. Dog4’s says() returns 'woof', Cat4’s says() returns 'meow', and polymorphism ensures the proper method is called.",Incorrect. Dog4 does not say 'meow' and Cat4 does not say 'woof'.,"Incorrect. Only Cat4 says 'meow', not Dog4.","Incorrect. Only Dog4 says 'woof', not Cat4.","Polymorphism allows the loop to call the correct says() implementation for each subclass; thus, Dog4 outputs 'woof' and Cat4 outputs 'meow'.","Question: Given the following code, what will be printed for each pet in the loop?

Pet2[] pets = {
    new Dog4(""Spot"", ""1234""),
    new Cat4(""Mittens"", ""5432"", true)
};
for (Pet2 p : pets) {
    System.out.printf(""%s says '%s'%n"", p, p.says());
}

Options:
A) Spot (1234) says 'woof'
   Mittens (5432) says 'meow'
B) Spot (1234) says 'meow'
   Mittens (5432) says 'woof'
C) Spot (1234) says 'meow'
   Mittens (5432) says 'meow'
D) Spot (1234) says 'woof'
   Mittens (5432) says 'woof'

Correct Answer: A

Option A explanation: Correct. Dog4’s says() returns 'woof', Cat4’s says() returns 'meow', and polymorphism ensures the proper method is called.
Option B explanation: Incorrect. Dog4 does not say 'meow' and Cat4 does not say 'woof'.
Option C explanation: Incorrect. Only Cat4 says 'meow', not Dog4.
Option D explanation: Incorrect. Only Dog4 says 'woof', not Cat4.

Main Explanation: Polymorphism allows the loop to call the correct says() implementation for each subclass; thus, Dog4 outputs 'woof' and Cat4 outputs 'meow'.

Tags: Polymorphism, Analyze",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,4,4,"The question directly and clearly assesses polymorphism by requiring students to understand that the correct overridden method is called based on the runtime type of each object. The correct answer (A) is accurate and well-explained. The distractors are reasonable and target common misconceptions (swapped outputs, wrong animal sounds). The explanations are clear and specific about why each option is correct or incorrect. The cognitive demand aligns well with ""Analyze"" level—students must trace execution, understand method overriding, and predict polymorphic behavior. Minor deduction from accuracy (4 instead of 5) because the code references classes (Dog4, Cat4, Pet2) and methods (says(), toString()) that aren't shown, creating slight ambiguity about whether toString() actually produces the expected format; however, the question context makes reasonable assumptions. Minor deduction from Bloom (4 instead of 5) because while analysis is required, the question is somewhat straightforward once polymorphism is understood—it doesn't require deep synthesis or evaluation."
8e084ef1-3b21-411a-b8c6-12e3be6aee65,2025-11-25T11:15:22.870578,Polymorphism,Analyze,"Given Pet2[] pets containing Dog4 and Cat4 objects, what will the following loop print for each element?  
for (Pet2 p : pets) { System.out.printf(""%s says '%s'%n"", p, p.says()); }","It prints ""woof"" or ""meow"" according to the actual object's type.",It always prints the same string regardless of the object.,It causes a compile-time error due to type mismatch.,It throws a runtime exception for Cat4 objects.,A,"Correct. Due to polymorphism and dynamic binding, the overridden says() method of the actual object (Dog4 or Cat4) is called.","Incorrect. The output depends on the actual object type, not just the variable type.",Incorrect. No compile-time error occurs; Pet2 can refer to Dog4 or Cat4.,Incorrect. No runtime exception occurs; says() is defined for both Dog4 and Cat4.,"Polymorphism allows the supertype reference (Pet2) to call the appropriate overridden says() method for Dog4 and Cat4 at runtime, producing type-specific output.","Question: Given Pet2[] pets containing Dog4 and Cat4 objects, what will the following loop print for each element?  
for (Pet2 p : pets) { System.out.printf(""%s says '%s'%n"", p, p.says()); }

Options:
A) It prints ""woof"" or ""meow"" according to the actual object's type.
B) It always prints the same string regardless of the object.
C) It causes a compile-time error due to type mismatch.
D) It throws a runtime exception for Cat4 objects.

Correct Answer: A

Option A explanation: Correct. Due to polymorphism and dynamic binding, the overridden says() method of the actual object (Dog4 or Cat4) is called.
Option B explanation: Incorrect. The output depends on the actual object type, not just the variable type.
Option C explanation: Incorrect. No compile-time error occurs; Pet2 can refer to Dog4 or Cat4.
Option D explanation: Incorrect. No runtime exception occurs; says() is defined for both Dog4 and Cat4.

Main Explanation: Polymorphism allows the supertype reference (Pet2) to call the appropriate overridden says() method for Dog4 and Cat4 at runtime, producing type-specific output.

Tags: Polymorphism, Analyze",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,5,5,"The question directly and effectively assesses polymorphism and dynamic method dispatch—core OOP concepts. It requires students to understand that a supertype reference (Pet2) calls the correct overridden method based on the actual runtime object type. The scenario is realistic and well-constructed. All explanations are technically accurate: Option A correctly identifies polymorphic behavior, Options B–D are plausible misconceptions (static binding, type safety, runtime errors) that effectively test understanding. The overall explanation clearly connects the loop, polymorphism, and dynamic binding. Bloom alignment is strong at the ""Analyze"" level—students must trace execution, distinguish between compile-time and runtime behavior, and reason about method resolution. The only minor limitation is that the question doesn't explicitly require students to *predict* or *justify* the mechanism (which would push toward ""Evaluate""), but analyzing the polymorphic behavior satisfies the Analyze cognitive level well."
088a1e11-428f-489e-a1ed-2f373b3207d4,2025-11-25T11:15:44.074211,Polymorphism,Evaluate,"Given the code snippet below, what output will be printed when executing the main method?

public class A {
    protected int i = 7;
    public A() {
        setI(20);
        System.out.printf(""A(): i=%d%n"", i);
    }
    public void setI(int i) {
        System.out.printf(""A.setI(%d)%n"", i);
        this.i = 2 * i;
    }
}
public class B extends A {
    public B() {
        System.out.printf(""B(): i=%d%n"", i);
    }
    public void setI(int i) {
        System.out.printf(""B.setI(%d)%n"", i);
        this.i = 3 * i;
    }
}
public static void main(String[] args) {
    new A();
    new B();
}","A.setI(20)
A(): i=40
B.setI(20)
B(): i=60","A.setI(20)
A(): i=40
A.setI(20)
A(): i=40","B.setI(20)
A(): i=60
B(): i=60","A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60",D,Incorrect. It misses the output of A(): i=60 after B.setI(20).,Incorrect. It doesn't account for subclass B's overridden setI method and constructor output.,"Incorrect. A's constructor calls setI, but output is incomplete and order is wrong.",Correct. This matches the output shown in the lecture slides when both new A() and new B() are called.,"When B is instantiated, A's constructor runs first and calls setI(20). Because of dynamic binding, B's setI(int) is called, setting i=60. Then A(): i=60 is printed, followed by B(): i=60. The full output is as shown in option D.","Question: Given the code snippet below, what output will be printed when executing the main method?

public class A {
    protected int i = 7;
    public A() {
        setI(20);
        System.out.printf(""A(): i=%d%n"", i);
    }
    public void setI(int i) {
        System.out.printf(""A.setI(%d)%n"", i);
        this.i = 2 * i;
    }
}
public class B extends A {
    public B() {
        System.out.printf(""B(): i=%d%n"", i);
    }
    public void setI(int i) {
        System.out.printf(""B.setI(%d)%n"", i);
        this.i = 3 * i;
    }
}
public static void main(String[] args) {
    new A();
    new B();
}

Options:
A) 
A.setI(20)
A(): i=40
B.setI(20)
B(): i=60

B) 
A.setI(20)
A(): i=40
A.setI(20)
A(): i=40

C) 
B.setI(20)
A(): i=60
B(): i=60

D) 
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60

Correct Answer: D

Option A explanation: Incorrect. It misses the output of A(): i=60 after B.setI(20).
Option B explanation: Incorrect. It doesn't account for subclass B's overridden setI method and constructor output.
Option C explanation: Incorrect. A's constructor calls setI, but output is incomplete and order is wrong.
Option D explanation: Correct. This matches the output shown in the lecture slides when both new A() and new B() are called.

Main Explanation: When B is instantiated, A's constructor runs first and calls setI(20). Because of dynamic binding, B's setI(int) is called, setting i=60. Then A(): i=60 is printed, followed by B(): i=60. The full output is as shown in option D.

Tags: Polymorphism, Evaluate",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,4,5,4,"This question directly and comprehensively assesses polymorphism (dynamic method dispatch/binding), which is a core OOP concept. It requires students to trace execution through inheritance hierarchies and understand that overridden methods are called on the actual runtime type, not the compile-time type.

Accuracy is strong: The correct answer (D) is technically accurate. The explanation correctly identifies that when B() is instantiated, A's constructor executes first via implicit super() call, and the setI(20) call within A's constructor invokes B's overridden setI due to dynamic binding, resulting in i=60. All distractors are plausible mistakes students commonly make (missing the polymorphic call, not understanding constructor chaining, etc.).

Explainability is good but could be slightly stronger. The overall explanation correctly identifies the key mechanism (dynamic binding), but the phrase ""as shown in the lecture slides"" is vague and doesn't add pedagogical value. A more detailed walkthrough of the constructor call chain (B() → super() → A() → setI() resolves to B.setI()) would enhance clarity.

Bloom alignment is solid at the 'Evaluate' level, though it borders on 'Analyze'. Students must trace complex execution flow and evaluate multiple competing outputs,"
4f8b7a70-b403-4f4e-94ef-12166ed39fe5,2025-11-25T11:16:00.462508,Polymorphism,Evaluate,"Given Pet2[] pets = { new Dog4(""Spot"", ""1234""), new Cat4(""Mittens"", ""5432"", true) }; and the loop for (Pet2 p : pets) { System.out.printf(""%s says '%s'%n"", p, p.says()); }, what principle allows this code to call the correct says() method for each object?",Encapsulation,Polymorphism,Abstraction,Overloading,B,"Incorrect. Encapsulation is about hiding data, not dynamic method selection.",Correct. Polymorphism allows a supertype reference to call overridden methods on subtype objects.,"Incorrect. Abstraction refers to exposing only essential features, not runtime method dispatch.","Incorrect. Overloading is about multiple methods with the same name but different signatures, not about dynamic binding.","Polymorphism enables a Pet2 variable to refer to both Dog4 and Cat4, and ensures the overridden says() method appropriate to the actual object type is called at runtime.","Question: Given Pet2[] pets = { new Dog4(""Spot"", ""1234""), new Cat4(""Mittens"", ""5432"", true) }; and the loop for (Pet2 p : pets) { System.out.printf(""%s says '%s'%n"", p, p.says()); }, what principle allows this code to call the correct says() method for each object?

Options:
A) Encapsulation
B) Polymorphism
C) Abstraction
D) Overloading

Correct Answer: B

Option A explanation: Incorrect. Encapsulation is about hiding data, not dynamic method selection.
Option B explanation: Correct. Polymorphism allows a supertype reference to call overridden methods on subtype objects.
Option C explanation: Incorrect. Abstraction refers to exposing only essential features, not runtime method dispatch.
Option D explanation: Incorrect. Overloading is about multiple methods with the same name but different signatures, not about dynamic binding.

Main Explanation: Polymorphism enables a Pet2 variable to refer to both Dog4 and Cat4, and ensures the overridden says() method appropriate to the actual object type is called at runtime.

Tags: Polymorphism, Evaluate",""", ""6789"")
};

Cat[] cats = {
	new Cat(""Mittens"", ""5432"", true),
	new Cat(""Garfield"", ""8765"", false)
};

for (Dog d : dogs) {
	System.out.printf(""%s says '%s'%n"", d, d.says());
}

for (Cat c : cats) {
	System.out.printf(""%s says '%s'"", c, c.says());
	if (c.hasHairBalls()) {
		System.out.printf("" :: CLEARS THROAT ::"");
	}
	System.out.printf(""%n"");
}
Vet.java
TODO
Update for Cat4/Dog4
Wouldn’t it be nice if we didn’t have to have as much separate code for cats/dogs?
Polymorphism
Polymorphism: a variable of a supertype can refer to a subtype object
A class defines a type
A type defined by a subclass is called a subtype; a type defined by its superclass is called a supertype
Example: Dog4 is a subtype of Pet2; Pet2 is a supertype of Cat4
Object is the supertype of all classes

Casting Objects (1)
Casting can used to convert an object of one class type to another within an inheritance hierarchy
Like with primitive variables, there is implicit and explicit casting
double x = 5; // implicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers

===== CHUNK BREAK =====

System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}
public static void main(String[] args) {
	new A();
	new B();
}
A.setI(20)
A(): i=40
B.setI(20)
A(): i=60
B(): i=60
The instanceof Operator
Use the instanceof operator to test whether an object is an instance of a class

Object o1 = ""howdy"";
boolean isS = o1 instanceof String; // true
boolean isD = o1 instanceof Double; // false
A More Complex Example
public class C1 {
}

public class C2 extends C1 {
	@Override
	public String toString() {
		return ""C2.toString()"";
	}
}

public class C3 extends C2 {
}
public static void main(String[] args) {
	final Object o1 = new C1();	
	final Object o2 = new C2();
	final Object o3 = new C3();
	System.out.printf(""%b %b %b %b%n"", 
		o1 instanceof Object,
		o1 instanceof C1, 
		o1 instanceof C2, 
		o1 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o2 instanceof Object,
		o2 instanceof C1, 
		o2 instanceof C2, 
		o2 instanceof C3);
	System.out.printf(""%b %b %b %b%n"", 
		o3 instanceof Object,
		o3 instanceof C1, 
		o3 instanceof C2, 
		o3 instanceof C3);
}
true true false false
true true true false
true true true true
Cat-Specific Method Calls in Vet2
Pet2[] pets = {

===== CHUNK BREAK =====

plicit
double y = (double) 5; // explicit
int z = (int) 3.14; // explicit
In general we must cast explicitly when moving from general to specific
All integers are doubles, not all doubles are integers
In the case of objects, from superclass to subclass
Casting Objects (2)
The following implicit cast will compile
Object o1 = ""foo""; // all strings are objects
The following will fail to compile
String s1 = o1; // not all objects are strings
So we must explicitly cast
String s1 = (String) o1;
The conversion is checked at runtime – if it was invalid, a ClassCastException will be thrown
String s2 = (String) (Object) 5;


Updating Variables in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
}
Overriding
Overriding is the process of redefining a method in a subclass that already exists in its parent class.
Key Rules:
Method name, return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.

===== CHUNK BREAK =====

is found, the search stops and the first-found implementation is invoked

Dynamic Binding Visually
An instance of C1 is an instance of C1 and Object
C1 is the most specific
Object is the most general
An instance of C2 is an instance of C2, C1 and Object
C2 is the most specific
Object is the most general
An instance of C3 is an instance of C3, C2, C1, and Object
C3 is the most specific
Object the most general
Updating Method Calls in Vet2
Pet2[] pets = {
	new Dog4(""Spot"", ""1234""),
	new Dog4(""Rover"", ""6789""),
	new Cat4(""Mittens"", ""5432"", true),	
	new Cat4(""Garfield"", ""8765"", false)
};

for (Pet2 p : pets) {
	System.out.printf(""%s says '%s'%n"", p, p.says());
}
Spot (1234) says 'woof'
Rover (6789) says 'woof'
Mittens (5432) says 'meow'
Garfield (8765) says 'meow'
Exercise – Output?
public class A {
	protected int i = 7;

	public A() {
		setI(20);
		System.out.printf(""A(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""A.setI(%d)%n"", i);
		this.i = 2 * i;
	}
}

public class B extends A {
	public B() {
		System.out.printf(""B(): i=%d%n"", i);
	}

	public void setI(int i) {
		System.out.printf(""B.setI(%d)%n"", i);
		this.i = 3 * i;
	}
}",5,3,5,5,"The question directly and unambiguously assesses polymorphism through a concrete code scenario involving a supertype reference (Pet2) calling overridden methods on subtype objects (Dog4, Cat4). The correct answer is technically sound—polymorphism is indeed the principle enabling runtime method dispatch. All distractors are reasonable and well-distinguished: encapsulation addresses data hiding, abstraction addresses interface design, and overloading addresses compile-time method resolution. Explanations are clear and specific, correctly identifying why each option is right or wrong. However, the cognitive demand falls short of Bloom's ""Evaluate"" level (which requires making judgments based on criteria). This question primarily requires students to **identify** or **understand** which principle applies—a lower-order task (Bloom 2-3: Understand/Apply). To reach ""Evaluate,"" the question would need to ask students to judge trade-offs, critique implementations, or defend design choices. The question is excellent for assessing polymorphism comprehension but misaligned with its stated Bloom level."
64718bc4-1443-464a-af3b-8f4d283c18a0,2025-11-25T11:16:09.368267,Abstract Classes,Remember,Which of the following is TRUE about abstract classes in Java according to the lecture content?,Abstract classes can provide default behavior through concrete methods.,Abstract classes can be instantiated directly.,A class can extend multiple abstract classes.,Abstract classes can only contain abstract methods.,A,Correct; lecture states concrete methods in abstract classes supply default behavior.,Incorrect; abstract classes cannot be instantiated.,"Incorrect; Java allows only single inheritance, so a class cannot extend multiple abstract classes.",Incorrect; abstract classes can have both abstract and concrete methods.,"Abstract classes in Java can include concrete methods for default behavior, but cannot be instantiated and are subject to single inheritance.","Question: Which of the following is TRUE about abstract classes in Java according to the lecture content?

Options:
A) Abstract classes can provide default behavior through concrete methods.
B) Abstract classes can be instantiated directly.
C) A class can extend multiple abstract classes.
D) Abstract classes can only contain abstract methods.

Correct Answer: A

Option A explanation: Correct; lecture states concrete methods in abstract classes supply default behavior.
Option B explanation: Incorrect; abstract classes cannot be instantiated.
Option C explanation: Incorrect; Java allows only single inheritance, so a class cannot extend multiple abstract classes.
Option D explanation: Incorrect; abstract classes can have both abstract and concrete methods.

Main Explanation: Abstract classes in Java can include concrete methods for default behavior, but cannot be instantiated and are subject to single inheritance.

Tags: Abstract Classes, Remember","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,2,5,5,"The question directly assesses core concepts of abstract classes in Java (relevance is high). All options and explanations are technically accurate—A correctly identifies that abstract classes can have concrete methods, B-D correctly identify common misconceptions. Explanations are clear and specific, referencing lecture content and Java's single inheritance rule. However, Bloom alignment is weak: the question requires Understanding/Comprehension (level 2) rather than Remember (level 1), as students must distinguish between multiple true/false statements about abstract class behavior, not simply recall a definition. The cognitive demand exceeds basic recall."
7b7450f5-6f31-4505-b93c-1b9f52422738,2025-11-25T11:16:25.899517,Abstract Classes,Remember,Which statement about abstract classes in Java is correct?,Abstract classes can provide default behavior through concrete methods.,Abstract classes can be instantiated directly.,Java allows a class to extend multiple abstract classes.,Abstract classes can only contain abstract methods.,A,Correct. Abstract classes can supply default behavior via concrete methods.,Incorrect. Abstract classes cannot be instantiated.,"Incorrect. Java allows only single inheritance for classes, including abstract classes.",Incorrect. Abstract classes can have both abstract and concrete methods.,"Abstract classes in Java may contain concrete methods to provide default behavior, but cannot be instantiated and only support single inheritance.","Question: Which statement about abstract classes in Java is correct?

Options:
A) Abstract classes can provide default behavior through concrete methods.
B) Abstract classes can be instantiated directly.
C) Java allows a class to extend multiple abstract classes.
D) Abstract classes can only contain abstract methods.

Correct Answer: A

Option A explanation: Correct. Abstract classes can supply default behavior via concrete methods.
Option B explanation: Incorrect. Abstract classes cannot be instantiated.
Option C explanation: Incorrect. Java allows only single inheritance for classes, including abstract classes.
Option D explanation: Incorrect. Abstract classes can have both abstract and concrete methods.

Main Explanation: Abstract classes in Java may contain concrete methods to provide default behavior, but cannot be instantiated and only support single inheritance.

Tags: Abstract Classes, Remember","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,2,5,5,"The question directly assesses core concepts of abstract classes in Java (relevance=5). All statements are technically accurate: A is correct (abstract classes can have concrete methods), B is correct (they cannot be instantiated), C is correct (Java only supports single inheritance), and D is correct (abstract classes can mix abstract and concrete methods) (accuracy=5). Explanations are clear, specific, and directly address why each option is correct or incorrect (explainability=5). However, the cognitive demand exceeds ""Remember"" level—it requires understanding multiple properties of abstract classes and distinguishing between them, which aligns better with ""Understand"" (Bloom level 2) rather than simple recall (bloom=2)."
6267cc39-5b0f-48bc-bd6b-e53404442bae,2025-11-25T11:16:37.019366,Abstract Classes,Understand,Which statement best describes a key limitation of abstract classes in Java?,A class can only extend one abstract class.,"Abstract classes can contain only method signatures, no concrete methods.",Abstract classes can be instantiated directly.,Abstract classes cannot provide any default behavior to subclasses.,A,"Correct. Java restricts a class to single inheritance, so it can only extend one abstract class.",Incorrect. Abstract classes can include concrete methods with default behavior.,Incorrect. Abstract classes cannot be instantiated directly.,Incorrect. Abstract classes can provide concrete methods with default behavior.,"In Java, a class can only have one parent class (single inheritance), which applies to both concrete and abstract classes. This is a key limitation of abstract classes compared to interfaces, which allow multiple inheritance via implementation.","Question: Which statement best describes a key limitation of abstract classes in Java?

Options:
A) A class can only extend one abstract class.
B) Abstract classes can contain only method signatures, no concrete methods.
C) Abstract classes can be instantiated directly.
D) Abstract classes cannot provide any default behavior to subclasses.

Correct Answer: A

Option A explanation: Correct. Java restricts a class to single inheritance, so it can only extend one abstract class.
Option B explanation: Incorrect. Abstract classes can include concrete methods with default behavior.
Option C explanation: Incorrect. Abstract classes cannot be instantiated directly.
Option D explanation: Incorrect. Abstract classes can provide concrete methods with default behavior.

Main Explanation: In Java, a class can only have one parent class (single inheritance), which applies to both concrete and abstract classes. This is a key limitation of abstract classes compared to interfaces, which allow multiple inheritance via implementation.

Tags: Abstract Classes, Understand","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,3,5,5,"The question directly assesses understanding of abstract classes in Java. The correct answer (A) accurately identifies single inheritance as a key limitation. All distractors are technically sound and address common misconceptions about abstract classes. Explanations are clear and specific, correctly distinguishing what abstract classes can and cannot do. However, Bloom alignment is slightly elevated—the question requires more than basic understanding (""Understand"" level); it requires students to compare abstract classes with interfaces and recognize design constraints, which approaches ""Analyze"" level (Bloom 3-4). The question is well-constructed overall with strong accuracy and explainability."
5e44fe2b-da7e-4c26-b9fa-703580d895df,2025-11-25T11:17:02.039558,Abstract Classes,Understand,What is a key limitation of abstract classes in Java as described in the lecture?,Abstract classes cannot have any methods implemented.,A class can extend only one abstract class (single inheritance).,Abstract classes can only contain static methods.,Abstract classes cannot define any data fields.,B,Incorrect. Abstract classes can include concrete (implemented) methods to supply default behavior.,"Correct. Java only allows single inheritance, so a class can extend just one abstract class.",Incorrect. Abstract classes can contain both static and non-static methods.,Incorrect. Abstract classes can define data fields (properties).,"The lecture highlights that Java limits classes to single inheritance, meaning a class can only have one abstract parent class, but it can implement multiple interfaces.","Question: What is a key limitation of abstract classes in Java as described in the lecture?

Options:
A) Abstract classes cannot have any methods implemented.
B) A class can extend only one abstract class (single inheritance).
C) Abstract classes can only contain static methods.
D) Abstract classes cannot define any data fields.

Correct Answer: B

Option A explanation: Incorrect. Abstract classes can include concrete (implemented) methods to supply default behavior.
Option B explanation: Correct. Java only allows single inheritance, so a class can extend just one abstract class.
Option C explanation: Incorrect. Abstract classes can contain both static and non-static methods.
Option D explanation: Incorrect. Abstract classes can define data fields (properties).

Main Explanation: The lecture highlights that Java limits classes to single inheritance, meaning a class can only have one abstract parent class, but it can implement multiple interfaces.

Tags: Abstract Classes, Understand","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,4,5,5,"The question directly assesses understanding of abstract classes in Java, specifically their inheritance limitations. All options and explanations are technically accurate—abstract classes do support concrete methods, data fields, and mixed static/non-static methods, while Java enforces single inheritance. The explanations are clear and specific, correctly distinguishing abstract classes from interfaces. The cognitive demand aligns well with ""Understand"" (Bloom Level 2), though it borders on ""Remember"" since it tests recall of a specific lecture point rather than deeper conceptual analysis or application. The question effectively targets a genuine limitation of abstract classes that is pedagogically important."
46f9dd83-64ed-4cee-86c9-2ab7a3a036cc,2025-11-25T11:17:12.451141,Abstract Classes,Apply,Suppose you want to avoid code duplication in multiple subclasses by providing default behavior. Which feature of abstract classes allows you to achieve this?,Defining concrete methods in the abstract class,Implementing multiple abstract classes,Declaring only abstract methods in the abstract class,Instantiating the abstract class directly,A,Correct; concrete methods in abstract classes supply default behavior for subclasses.,Incorrect; Java does not support multiple inheritance with abstract classes.,Incorrect; abstract classes can have both abstract and concrete methods.,Incorrect; abstract classes cannot be instantiated directly.,"Abstract classes allow concrete methods that provide default behavior, helping subclasses avoid code duplication. Java only supports single inheritance with abstract classes.","Question: Suppose you want to avoid code duplication in multiple subclasses by providing default behavior. Which feature of abstract classes allows you to achieve this?

Options:
A) Defining concrete methods in the abstract class
B) Implementing multiple abstract classes
C) Declaring only abstract methods in the abstract class
D) Instantiating the abstract class directly

Correct Answer: A

Option A explanation: Correct; concrete methods in abstract classes supply default behavior for subclasses.
Option B explanation: Incorrect; Java does not support multiple inheritance with abstract classes.
Option C explanation: Incorrect; abstract classes can have both abstract and concrete methods.
Option D explanation: Incorrect; abstract classes cannot be instantiated directly.

Main Explanation: Abstract classes allow concrete methods that provide default behavior, helping subclasses avoid code duplication. Java only supports single inheritance with abstract classes.

Tags: Abstract Classes, Apply","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,3,5,5,"The question directly and clearly assesses understanding of abstract classes and their role in providing default behavior to avoid code duplication. All explanations are technically accurate and well-reasoned. Option A is unambiguously correct—concrete methods in abstract classes are the standard mechanism for sharing default implementation across subclasses. The distractors are all reasonable and address common misconceptions (multiple inheritance limitations, abstract-only methods, instantiation rules). However, the cognitive demand falls short of ""Apply"" level—this is primarily a factual recall/comprehension question about what abstract classes can do, rather than requiring students to apply the concept to solve a problem or analyze a code scenario. To reach Bloom's ""Apply"" level, the question would need to present a code scenario requiring students to identify or construct the appropriate use of concrete methods in an abstract class."
9028e1ec-f3b9-43c8-88e0-0654ccd1033c,2025-11-25T11:17:22.022601,Abstract Classes,Apply,Suppose you want to provide default behavior for a method so subclasses can avoid code duplication. Which Java feature from the slides should you use?,Abstract class with a concrete method,Interface with only method signatures,Class with only static methods,Interface with only constants,A,Correct; abstract classes can supply concrete methods with default behavior to avoid code duplication.,Incorrect; interfaces with only method signatures cannot provide default behavior.,Incorrect; static methods in a class are not inherited as instance methods for default behavior.,Incorrect; constants in interfaces do not provide method behavior.,"Abstract classes allow concrete methods, supplying default behavior for subclasses and avoiding code duplication, as described in the lecture content.","Question: Suppose you want to provide default behavior for a method so subclasses can avoid code duplication. Which Java feature from the slides should you use?

Options:
A) Abstract class with a concrete method
B) Interface with only method signatures
C) Class with only static methods
D) Interface with only constants

Correct Answer: A

Option A explanation: Correct; abstract classes can supply concrete methods with default behavior to avoid code duplication.
Option B explanation: Incorrect; interfaces with only method signatures cannot provide default behavior.
Option C explanation: Incorrect; static methods in a class are not inherited as instance methods for default behavior.
Option D explanation: Incorrect; constants in interfaces do not provide method behavior.

Main Explanation: Abstract classes allow concrete methods, supplying default behavior for subclasses and avoiding code duplication, as described in the lecture content.

Tags: Abstract Classes, Apply","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,3,4,4,"The question directly assesses understanding of abstract classes and their role in providing default behavior (relevance=5). However, the cognitive demand is primarily at the ""Understand"" level rather than ""Apply"" - it asks students to recall/recognize a feature rather than apply it to solve a problem (bloom=3). Accuracy is strong overall, though Option B is slightly incomplete since Java 8+ interfaces can now include default methods, which could make the distinction less clear to modern students (accuracy=4). Explanations are clear and specific, directly addressing why each option is correct or incorrect (explainability=4). The question would be stronger if it presented a concrete scenario requiring students to choose and justify the appropriate feature."
98e52f0f-206a-493d-ac64-5577d032e78a,2025-11-25T11:17:33.677233,Abstract Classes,Analyze,Analyze why Java uses abstract classes to supply default behavior and how this compares to interfaces according to the lecture.,"Abstract classes can provide concrete methods, preventing code duplication, while interfaces could not until Java 8.","Abstract classes can be instantiated directly, while interfaces cannot.","Abstract classes allow multiple inheritance, while interfaces do not.","Abstract classes cannot have any method implementations, while interfaces can.",A,"Correct. The lecture states abstract classes can supply default behavior with concrete methods, avoiding duplication; interfaces could not until Java 8's default methods.","Incorrect. Abstract classes cannot be instantiated, similar to interfaces.","Incorrect. Java allows only single inheritance for classes, but multiple interfaces can be implemented.",Incorrect. Abstract classes can have concrete methods; interfaces (before Java 8) could not.,"Abstract classes supply default behavior using concrete methods, helping subclasses avoid duplicating code. Interfaces could not have default method implementations until Java 8, making this a key distinction.","Question: Analyze why Java uses abstract classes to supply default behavior and how this compares to interfaces according to the lecture.

Options:
A) Abstract classes can provide concrete methods, preventing code duplication, while interfaces could not until Java 8.
B) Abstract classes can be instantiated directly, while interfaces cannot.
C) Abstract classes allow multiple inheritance, while interfaces do not.
D) Abstract classes cannot have any method implementations, while interfaces can.

Correct Answer: A

Option A explanation: Correct. The lecture states abstract classes can supply default behavior with concrete methods, avoiding duplication; interfaces could not until Java 8's default methods.
Option B explanation: Incorrect. Abstract classes cannot be instantiated, similar to interfaces.
Option C explanation: Incorrect. Java allows only single inheritance for classes, but multiple interfaces can be implemented.
Option D explanation: Incorrect. Abstract classes can have concrete methods; interfaces (before Java 8) could not.

Main Explanation: Abstract classes supply default behavior using concrete methods, helping subclasses avoid duplicating code. Interfaces could not have default method implementations until Java 8, making this a key distinction.
 
Tags: Abstract Classes, Analyze","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,4,5,5,"The question directly assesses abstract classes and their role in providing default behavior, with clear comparison to interfaces as specified. Option A is technically accurate and represents the genuine distinction between abstract classes and interfaces pre-Java 8. All distractors are reasonable misconceptions (instantiation, inheritance models, method implementations). Explanations are precise and reference the lecture context. Bloom alignment is strong—the question requires analysis of *why* abstract classes are used and *how* they compare, moving beyond simple recall. The only minor consideration is that the question's relevance to modern Java (post-Java 8) is somewhat dated, though this appears intentional given the lecture focus. The question effectively distinguishes between similar concepts and requires understanding of design principles."
39dff267-a83c-48ad-b0d1-1890315aef9c,2025-11-25T11:17:44.927361,Abstract Classes,Analyze,"When designing a Java class hierarchy, why might you choose to use an abstract class instead of an interface?",To allow subclasses to inherit default behavior and avoid code duplication,To allow a class to implement multiple types of functionality,To enforce that all variables are public static final,To permit only method signatures with no code,A,"Correct—abstract classes can provide concrete methods with default behavior, reducing code duplication for subclasses.","Incorrect—interfaces, not abstract classes, allow a class to implement multiple types of functionality due to multiple inheritance support.","Incorrect—this applies to interfaces, where all variables are public static final.","Incorrect—interfaces contain only method signatures with no code, but abstract classes can have both signatures and code.","Abstract classes support default method implementations, which help subclasses avoid duplicating code, whereas interfaces in Java are used more for multiple inheritance and do not provide shared code before Java 8.","Question: When designing a Java class hierarchy, why might you choose to use an abstract class instead of an interface?

Options:
A) To allow subclasses to inherit default behavior and avoid code duplication
B) To allow a class to implement multiple types of functionality
C) To enforce that all variables are public static final
D) To permit only method signatures with no code

Correct Answer: A

Option A explanation: Correct—abstract classes can provide concrete methods with default behavior, reducing code duplication for subclasses.
Option B explanation: Incorrect—interfaces, not abstract classes, allow a class to implement multiple types of functionality due to multiple inheritance support.
Option C explanation: Incorrect—this applies to interfaces, where all variables are public static final.
Option D explanation: Incorrect—interfaces contain only method signatures with no code, but abstract classes can have both signatures and code.

Main Explanation: Abstract classes support default method implementations, which help subclasses avoid duplicating code, whereas interfaces in Java are used more for multiple inheritance and do not provide shared code before Java 8.

Tags: Abstract Classes, Analyze","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,4,4,4,"The question directly assesses understanding of abstract classes and their design purpose, making it highly relevant. The correct answer (A) accurately captures the primary advantage of abstract classes—providing default implementations. The distractors are well-crafted and technically sound, though Option B's explanation could be more precise (interfaces support multiple inheritance of type, not functionality before Java 8). The explanations are clear and specific, effectively distinguishing abstract classes from interfaces. Bloom alignment is strong at the ""Analyze"" level, as students must compare abstract classes against interfaces and evaluate trade-offs, though it slightly approaches ""Understand"" territory since the distinction is somewhat foundational. Minor deduction: the overall explanation could acknowledge Java 8+ default methods in interfaces to reflect current language capabilities, though this doesn't affect the correctness of the answer for traditional abstract class use cases."
9e97dd4c-ccff-452b-834c-a13728f53ff4,2025-11-25T11:17:58.358233,Abstract Classes,Evaluate,"Given Java's restriction on single inheritance, evaluate when it is appropriate to use an abstract class over an interface.","When modeling a strong ""is-a"" relationship, such as Employee is-a Person",When a class needs to implement multiple types of behaviors,When all methods must have code (concrete implementations),When you want to avoid using the super keyword,A,"Correct; abstract classes are suitable for strong is-a relationships, as stated in the slides.",Incorrect; interfaces are designed for situations where a class implements multiple behaviors.,Incorrect; abstract classes can have abstract methods without implementations.,Incorrect; the use of the super keyword is unrelated to the choice between abstract classes and interfaces.,"Abstract classes should be chosen for strong is-a relationships, according to the slides, while interfaces are better for representing capabilities or multiple behaviors.","Question: Given Java's restriction on single inheritance, evaluate when it is appropriate to use an abstract class over an interface.

Options:
A) When modeling a strong ""is-a"" relationship, such as Employee is-a Person
B) When a class needs to implement multiple types of behaviors
C) When all methods must have code (concrete implementations)
D) When you want to avoid using the super keyword

Correct Answer: A

Option A explanation: Correct; abstract classes are suitable for strong is-a relationships, as stated in the slides.
Option B explanation: Incorrect; interfaces are designed for situations where a class implements multiple behaviors.
Option C explanation: Incorrect; abstract classes can have abstract methods without implementations.
Option D explanation: Incorrect; the use of the super keyword is unrelated to the choice between abstract classes and interfaces.

Main Explanation: Abstract classes should be chosen for strong is-a relationships, according to the slides, while interfaces are better for representing capabilities or multiple behaviors.

Tags: Abstract Classes, Evaluate","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",4,3,4,4,"The question is highly relevant to abstract classes, directly addressing when to use them versus interfaces. Accuracy is strong—option A correctly identifies the is-a relationship principle, and distractors are technically sound (B correctly notes interfaces for multiple behaviors, C correctly notes abstract classes can have abstract methods, D correctly identifies an unrelated concern). Explainability is clear with specific examples and reasoning. However, Bloom alignment is moderate rather than strong: while the question uses ""evaluate,"" it primarily asks students to recall/understand a design principle from slides rather than genuinely evaluate tradeoffs. A stronger ""evaluate"" question would require students to analyze a scenario and justify their choice by weighing multiple competing factors, rather than selecting a memorized rule. The question leans toward Bloom's ""Understand"" level despite the verb choice."
ffbdba94-46b7-47b0-a139-a11afea8ca54,2025-11-25T11:18:12.809558,Abstract Classes,Evaluate,"Given Java's single inheritance limitation, in which scenario should you choose an abstract class over an interface?",When you want to provide some default behavior to subclasses and enforce a strong is-a relationship.,When you want a class to implement multiple types of behavior with no code duplication.,When all fields must be public static final and all methods public.,When you want to create a contract with only method signatures and constants.,A,Correct; abstract classes are used for strong is-a relationships and can provide default behavior to avoid code duplication.,Incorrect; interfaces are used for multiple behaviors and code sharing is done via default methods in interfaces.,"Incorrect; this describes interface properties, not abstract classes.","Incorrect; this is the typical use of interfaces, not abstract classes.","Abstract classes in Java are chosen for strong is-a relationships and allow subclasses to inherit default behavior, whereas interfaces are for looser relationships and multiple behaviors.","Question: Given Java's single inheritance limitation, in which scenario should you choose an abstract class over an interface?

Options:
A) When you want to provide some default behavior to subclasses and enforce a strong is-a relationship.
B) When you want a class to implement multiple types of behavior with no code duplication.
C) When all fields must be public static final and all methods public.
D) When you want to create a contract with only method signatures and constants.

Correct Answer: A

Option A explanation: Correct; abstract classes are used for strong is-a relationships and can provide default behavior to avoid code duplication.
Option B explanation: Incorrect; interfaces are used for multiple behaviors and code sharing is done via default methods in interfaces.
Option C explanation: Incorrect; this describes interface properties, not abstract classes.
Option D explanation: Incorrect; this is the typical use of interfaces, not abstract classes.

Main Explanation: Abstract classes in Java are chosen for strong is-a relationships and allow subclasses to inherit default behavior, whereas interfaces are for looser relationships and multiple behaviors.

Tags: Abstract Classes, Evaluate","e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

address)
» State, consisting of a set of data fields (also known as properties) with their current values
» Behavior, defined by a set of methods
School of Computing & Data Science
Classes
COMP1050
10
Professor Folajimi
A class is a template, blue-print, or contract that defines what an object’s data fields and methods will be
»Typically in its own file (name of the file = name of the class)
Every object is an instance of some class
»Think of the class as the data type, whereas an object is a variable of that type
School of Computing & Data Science
Example: Circles
COMP1050
10
Professor Folajimi
Class: Circle
» All circles have…
A radius
» All circles can…
Tell you their area
Get/set radius
Some example circles…
» c1: radius=5
» c2: radius=10
» c3: radius=5
Distinct from c1!
» c4: radius=1
Class: Circle
Data Fields:
radius
Methods:
getArea()
getRadius()
setRadius(r)
Object: c1
Class: Circle

Data Fields:
radius=5
Object: c2
Class: Circle

Data Fields:
radius=10
Object: c3
Class: Circle

Data Fields:
radius=5
Object: c4
Class: Circle

Data Fields:
radius=1
School of Computing & Data Science
	Code: Circles	
COMP1050
10
Professor Folajimi
public class Circle {

===== CHUNK BREAK =====

return type, and parameters must be the same.
The overridden method in the subclass cannot have a more restrictive access modifier than in the superclass.
Final & static methods cannot be overridden.
Super Keyword is used to call the parent class method inside the subclass.
While overloading can be achieved at compile-time, overriding must occur at run-time 



Example (1)
public class Polly {
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
Polly@70dea4e
Example (2)
public class Polly {
	@Override
	public String toString() {
		return ""wants a cracker"";
	}
}
public static void p(Object o) {
	System.out.printf(""%s%n"", o.toString());
}

public static void main(String[] args) {
	p(new Polly());
}

Polly.java
wants a cracker
The Object Class
The Object class is the root superclass of all Java classes.
Every class in Java implicitly extends Object, unless it explicitly extends another class.
It provides common methods that all Java objects inherit and can override.
class Pet {
    String name, id;
    
    public Pet(String name, String id) { this.name = name; this.id = id; }

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,3,4,4,"The question directly targets abstract classes and their appropriate use cases, making it highly relevant. However, the Bloom level is closer to ""Understand/Apply"" rather than ""Evaluate""—students must recall when to use abstract classes, not critically evaluate trade-offs or analyze complex scenarios. Accuracy is strong; option A is correct and distractors are reasonable, though option B could be slightly misleading since interfaces now support default methods (Java 8+), making the distinction less clear-cut in modern Java. Option C accurately describes interface constraints. Explanations are clear and specific, correctly identifying why each option is right or wrong. The question would be stronger if it presented competing valid scenarios requiring deeper analysis rather than straightforward recall of abstract class characteristics."
bb32ff20-5464-41a9-af3c-42fb75d70dc9,2025-11-25T11:18:21.887429,Interfaces,Remember,Which statement about Java interfaces is correct according to the lecture?,"Interfaces can contain only method signatures, constants, and nested types.",Interfaces can be instantiated directly.,Interfaces require all variables to be private.,A class can implement only one interface.,A,"Correct; interfaces can contain only method signatures, constants, and nested types, as stated in the lecture.",Incorrect; interfaces cannot be instantiated.,"Incorrect; all variables in interfaces are public static final, not private.",Incorrect; a class can implement any number of interfaces.,"According to the lecture, interfaces in Java can include method signatures, constants, and nested types, but cannot be instantiated and allow multiple implementations per class.","Question: Which statement about Java interfaces is correct according to the lecture?

Options:
A) Interfaces can contain only method signatures, constants, and nested types.
B) Interfaces can be instantiated directly.
C) Interfaces require all variables to be private.
D) A class can implement only one interface.

Correct Answer: A

Option A explanation: Correct; interfaces can contain only method signatures, constants, and nested types, as stated in the lecture.
Option B explanation: Incorrect; interfaces cannot be instantiated.
Option C explanation: Incorrect; all variables in interfaces are public static final, not private.
Option D explanation: Incorrect; a class can implement any number of interfaces.

Main Explanation: According to the lecture, interfaces in Java can include method signatures, constants, and nested types, but cannot be instantiated and allow multiple implementations per class.

Tags: Interfaces, Remember","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,2,5,5,"The question directly assesses understanding of Java interfaces, making it highly relevant. All options and explanations are technically accurate—interfaces cannot be instantiated, variables are implicitly public static final (not private), and classes can implement multiple interfaces. Explanations are clear and specific, referencing the lecture appropriately. However, Bloom alignment is weak: the question asks students to ""remember"" facts from the lecture rather than demonstrate higher-order thinking. A ""Remember"" level question should focus on basic recall (e.g., ""What can interfaces contain?""), but this question requires distinguishing between multiple plausible statements, which approaches ""Understand"" level (Bloom 2-3). The cognitive demand slightly exceeds simple memorization, though it remains relatively low-level."
f7035c6d-941e-484c-b526-bb254699992f,2025-11-25T11:18:34.854977,Interfaces,Remember,Which statement about interfaces in Java is correct based on the lecture slides?,Interfaces can be used to express contracts and support multiple inheritance.,Interfaces can be instantiated directly.,All variables in an interface are private.,Interfaces cannot contain method signatures.,A,"Correct; interfaces express contracts and allow a class to implement multiple interfaces, supporting multiple inheritance.",Incorrect; interfaces cannot be instantiated directly.,"Incorrect; all variables in an interface are public static final, not private.",Incorrect; interfaces define method signatures.,"Interfaces are used for expressing contracts and allow multiple inheritance in Java, making them flexible and essential in object-oriented code.","Question: Which statement about interfaces in Java is correct based on the lecture slides?

Options:
A) Interfaces can be used to express contracts and support multiple inheritance.
B) Interfaces can be instantiated directly.
C) All variables in an interface are private.
D) Interfaces cannot contain method signatures.

Correct Answer: A

Option A explanation: Correct; interfaces express contracts and allow a class to implement multiple interfaces, supporting multiple inheritance.
Option B explanation: Incorrect; interfaces cannot be instantiated directly.
Option C explanation: Incorrect; all variables in an interface are public static final, not private.
Option D explanation: Incorrect; interfaces define method signatures.

Main Explanation: Interfaces are used for expressing contracts and allow multiple inheritance in Java, making them flexible and essential in object-oriented code.

Tags: Interfaces, Remember","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,2,5,5,"The question directly assesses core interface concepts (contracts, multiple inheritance, instantiation, variables, method signatures), making it highly relevant. All explanations are technically accurate and clear—Option A correctly identifies interfaces' dual purpose, while distractors accurately reflect common misconceptions. However, the cognitive demand exceeds Bloom's ""Remember"" level; it requires understanding and application of multiple interface properties rather than simple recall. The question effectively distinguishes between correct and incorrect statements about interfaces, making it suitable for comprehension/application levels rather than basic knowledge recall."
5fdc30d4-a8d7-4419-b624-eb1f379de535,2025-11-25T11:18:46.089172,Interfaces,Understand,Which statement about Java interfaces is CORRECT according to the lecture slides?,A class can implement multiple interfaces in Java.,Interfaces can be instantiated directly.,Interfaces can contain private instance variables.,All methods in an interface must have implementations.,A,Correct; the lecture states that a class can implement any number of interfaces.,"Incorrect; interfaces cannot be instantiated directly, as noted in the slides.","Incorrect; all variables in an interface are public static final, not private instance variables.","Incorrect; interfaces contain only method signatures, not implementations (except default/static methods as of Java 8).","Java interfaces allow a class to implement multiple contracts, which is used extensively due to Java's single inheritance limitation. Interfaces cannot be instantiated and only contain public static final variables and method signatures by default.","Question: Which statement about Java interfaces is CORRECT according to the lecture slides?

Options:
A) A class can implement multiple interfaces in Java.
B) Interfaces can be instantiated directly.
C) Interfaces can contain private instance variables.
D) All methods in an interface must have implementations.

Correct Answer: A

Option A explanation: Correct; the lecture states that a class can implement any number of interfaces.
Option B explanation: Incorrect; interfaces cannot be instantiated directly, as noted in the slides.
Option C explanation: Incorrect; all variables in an interface are public static final, not private instance variables.
Option D explanation: Incorrect; interfaces contain only method signatures, not implementations (except default/static methods as of Java 8).

Main Explanation: Java interfaces allow a class to implement multiple contracts, which is used extensively due to Java's single inheritance limitation. Interfaces cannot be instantiated and only contain public static final variables and method signatures by default.

Tags: Interfaces, Understand","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,4,4,4,"The question directly assesses core interface concepts and is highly relevant. Accuracy is strong overall—option A is correct and well-supported. However, option D's explanation is slightly incomplete: it mentions ""except default/static methods as of Java 8"" but doesn't clarify that default/static methods DO have implementations, which could confuse students about what ""method signatures"" means. Option C's explanation is accurate but could note that interfaces CAN have private static final variables (Java 9+), making it slightly outdated. Explanations are clear and specific, effectively distinguishing each option. Bloom alignment sits between ""Understand"" and ""Apply""—students must recall definitions and distinguish between similar concepts, which is solid comprehension-level work, though not purely definitional recall."
6af8d496-f10d-41b5-a0d6-e5d1e20fe3a6,2025-11-25T11:18:57.967919,Interfaces,Understand,"Which statement best describes the primary purpose of interfaces in Java, according to the lecture?",Interfaces express weaker relationships and allow a class to do something or have a property.,Interfaces are used to express strong is-a relationships between classes.,Interfaces can be instantiated directly to create objects.,"Interfaces cannot define method signatures, only constants.",A,"Correct; the lecture states interfaces are for weaker relationships, such as a class being able to do something or possessing a property.","Incorrect; strong is-a relationships are for abstract classes, not interfaces.",Incorrect; interfaces cannot be instantiated directly.,Incorrect; interfaces do define method signatures.,"According to the lecture, interfaces are designed for weaker relationships, allowing classes to indicate capabilities or properties, unlike abstract classes which define strong is-a relationships.","Question: Which statement best describes the primary purpose of interfaces in Java, according to the lecture?

Options:
A) Interfaces express weaker relationships and allow a class to do something or have a property.
B) Interfaces are used to express strong is-a relationships between classes.
C) Interfaces can be instantiated directly to create objects.
D) Interfaces cannot define method signatures, only constants.

Correct Answer: A

Option A explanation: Correct; the lecture states interfaces are for weaker relationships, such as a class being able to do something or possessing a property.
Option B explanation: Incorrect; strong is-a relationships are for abstract classes, not interfaces.
Option C explanation: Incorrect; interfaces cannot be instantiated directly.
Option D explanation: Incorrect; interfaces do define method signatures.

Main Explanation: According to the lecture, interfaces are designed for weaker relationships, allowing classes to indicate capabilities or properties, unlike abstract classes which define strong is-a relationships.

Tags: Interfaces, Understand","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,4,5,5,"The question directly assesses understanding of interfaces' primary purpose, which is highly relevant. All options are technically accurate and represent common misconceptions (confusing interfaces with abstract classes, misunderstanding instantiation rules, and misremembering interface capabilities). Explanations are clear and specific, referencing the lecture and contrasting interfaces with abstract classes. Bloom alignment is strong at the ""Understand"" level—it asks students to identify and describe the purpose rather than merely recall. The question could be rated Bloom level 4 (rather than 3) because it requires students to distinguish between related concepts (interfaces vs. abstract classes), which involves some analytical thinking beyond simple comprehension."
cc843712-9e8c-4de4-b25c-f16bd90b1c5d,2025-11-25T11:19:07.670895,Interfaces,Apply,Which of the following best demonstrates when to use an interface instead of an abstract class in Java?,"When a class ""is-a"" specific type, like Employee is-a Person.","When a class ""can do"" something, like being able to handle events.",When you want to prevent subclassing in your API.,When you need to store mutable instance variables.,B,"Incorrect; abstract classes are preferred for strong ""is-a"" relationships.","Correct; interfaces are used for weaker relationships, like when a class ""can do"" something.",Incorrect; interfaces do not prevent subclassing.,Incorrect; interfaces cannot have mutable instance variables (only public static final).,"Interfaces should be used for weaker relationships such as ""can do"" (e.g., handling events), while abstract classes are for strong ""is-a"" relationships. This distinction is highlighted in the provided lecture slides.","Question: Which of the following best demonstrates when to use an interface instead of an abstract class in Java?

Options:
A) When a class ""is-a"" specific type, like Employee is-a Person.
B) When a class ""can do"" something, like being able to handle events.
C) When you want to prevent subclassing in your API.
D) When you need to store mutable instance variables.

Correct Answer: B

Option A explanation: Incorrect; abstract classes are preferred for strong ""is-a"" relationships.
Option B explanation: Correct; interfaces are used for weaker relationships, like when a class ""can do"" something.
Option C explanation: Incorrect; interfaces do not prevent subclassing.
Option D explanation: Incorrect; interfaces cannot have mutable instance variables (only public static final).

Main Explanation: Interfaces should be used for weaker relationships such as ""can do"" (e.g., handling events), while abstract classes are for strong ""is-a"" relationships. This distinction is highlighted in the provided lecture slides.

Tags: Interfaces, Apply","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,4,5,5,"The question directly assesses understanding of when to use interfaces versus abstract classes, a core OOP concept. The correct answer (B) accurately reflects the ""can do"" (capability/behavior) principle for interfaces versus ""is-a"" (inheritance hierarchy) for abstract classes. All distractors are technically sound and address common misconceptions: A tests understanding of ""is-a"" relationships, C tests knowledge that interfaces don't prevent subclassing, and D tests knowledge of interface constraints. Explanations are clear and specific, referencing the conceptual distinction between interface and abstract class purposes. The cognitive demand aligns well with ""Apply"" level—students must apply knowledge of interface design principles to choose the appropriate tool. The only minor consideration is that this could arguably reach ""Analyze"" level by requiring students to distinguish between relationship types, but ""Apply"" is reasonable for a straightforward scenario-matching question."
96c8c826-7cc2-4a32-b30c-24fff6e960b2,2025-11-25T11:19:20.584546,Interfaces,Apply,"Given the code below, which statement best explains why interfaces are used in event-driven JavaFX programming?",Interfaces allow a class to handle multiple types of events because a class can implement multiple interfaces.,Interfaces are used because Java allows multiple inheritance with interfaces and abstract classes.,Interfaces define concrete behavior for event handling by default.,Interfaces can be instantiated to directly respond to events.,A,Correct; interfaces enable a class to handle different event types because Java permits implementing multiple interfaces.,"Incorrect; Java does not allow multiple inheritance of classes, only multiple interfaces.","Incorrect; interfaces do not provide concrete behavior unless using default methods, but event handling usually requires custom code.",Incorrect; interfaces cannot be instantiated directly.,"In JavaFX event-driven programming, interfaces are used because a class can implement multiple interfaces, supporting flexible event handling without single inheritance limitations.","Question: Given the code below, which statement best explains why interfaces are used in event-driven JavaFX programming?

Options:
A) Interfaces allow a class to handle multiple types of events because a class can implement multiple interfaces.
B) Interfaces are used because Java allows multiple inheritance with interfaces and abstract classes.
C) Interfaces define concrete behavior for event handling by default.
D) Interfaces can be instantiated to directly respond to events.

Correct Answer: A

Option A explanation: Correct; interfaces enable a class to handle different event types because Java permits implementing multiple interfaces.

Option B explanation: Incorrect; Java does not allow multiple inheritance of classes, only multiple interfaces.

Option C explanation: Incorrect; interfaces do not provide concrete behavior unless using default methods, but event handling usually requires custom code.

Option D explanation: Incorrect; interfaces cannot be instantiated directly.

Main Explanation: In JavaFX event-driven programming, interfaces are used because a class can implement multiple interfaces, supporting flexible event handling without single inheritance limitations.

Tags: Interfaces, Apply","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",4,2,4,3,"The question is highly relevant to interfaces in JavaFX (relevance=4), though it conflates two concepts: interfaces as a language feature and their specific role in event-driven programming. The accuracy is strong (accuracy=4)—all options are technically sound, and Option A correctly identifies that multiple interface implementation enables flexible event handling. However, the cognitive demand is primarily recall/comprehension rather than application (bloom=2); students need to know that classes can implement multiple interfaces, not apply this knowledge to solve a problem. The explainability is adequate but could be stronger (explainability=3)—while the overall explanation is clear, it doesn't provide concrete examples (e.g., implementing both EventHandler and Serializable) or explain *why* this matters in practice (e.g., how a single class might handle mouse events AND keyboard events). The question would be more robust if it presented a code scenario requiring students to apply interface concepts to a specific event-handling challenge."
b8218281-9f45-4408-b475-99509d1c591d,2025-11-25T11:19:32.884558,Interfaces,Analyze,"In Java, when designing a class that must handle events and be compared to other classes, which approach best leverages interfaces according to the lecture?",Implement multiple interfaces such as EventHandler and Comparable in the class,Use an abstract class to inherit event handling and comparison behavior,Extend multiple parent classes to inherit all needed behaviors,Avoid interfaces and use only concrete classes for event handling,A,"Correct; interfaces are used for weaker relationships like handling events and comparing objects, and multiple interfaces can be implemented.","Incorrect; abstract classes are suited for strong is-a relationships, not for handling multiple weak behaviors.",Incorrect; Java does not support multiple inheritance of classes.,Incorrect; interfaces are recommended for event handling and comparison as per the lecture.,"According to the lecture, interfaces should be used for weaker relationships, and Java allows implementing multiple interfaces for properties like event handling and comparison.","Question: In Java, when designing a class that must handle events and be compared to other classes, which approach best leverages interfaces according to the lecture?

Options:
A) Implement multiple interfaces such as EventHandler and Comparable in the class
B) Use an abstract class to inherit event handling and comparison behavior
C) Extend multiple parent classes to inherit all needed behaviors
D) Avoid interfaces and use only concrete classes for event handling

Correct Answer: A

Option A explanation: Correct; interfaces are used for weaker relationships like handling events and comparing objects, and multiple interfaces can be implemented.
Option B explanation: Incorrect; abstract classes are suited for strong is-a relationships, not for handling multiple weak behaviors.
Option C explanation: Incorrect; Java does not support multiple inheritance of classes.
Option D explanation: Incorrect; interfaces are recommended for event handling and comparison as per the lecture.

Main Explanation: According to the lecture, interfaces should be used for weaker relationships, and Java allows implementing multiple interfaces for properties like event handling and comparison.
 
Tags: Interfaces, Analyze","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,3,5,4,"The question directly assesses understanding of interfaces and their appropriate use cases (relevance=5). The correct answer and distractors are technically accurate—Option A correctly identifies multiple interface implementation, Option B correctly notes abstract classes suit strong relationships, Option C correctly states Java lacks multiple class inheritance, and Option D correctly identifies interfaces as recommended (accuracy=5). Explanations are clear and reference the lecture context, though they could be slightly more detailed about *why* interfaces represent weaker relationships (explainability=4). However, the cognitive demand falls short of ""Analyze"" level—the question primarily asks students to recall and understand the lecture's distinction between interfaces and abstract classes rather than analyze a complex scenario, apply concepts to novel situations, or evaluate trade-offs (bloom=3, closer to Understand/Remember). To reach Analyze level, the question could present a design scenario requiring students to evaluate multiple approaches or justify design decisions."
89dceb38-d6de-4723-bbef-6b63cb466389,2025-11-25T11:19:43.795545,Interfaces,Analyze,"When designing a Java class to handle GUI events in JavaFX, why is using an interface preferred over an abstract class?","Interfaces allow multiple inheritance, so a class can handle events and inherit from another class.","Abstract classes can only contain abstract methods, while interfaces can contain code.",Interfaces are instantiated directly to handle events in JavaFX.,Abstract classes are not allowed in JavaFX event-driven programming.,A,"Correct; interfaces enable a class to implement multiple contracts (e.g., event handling) alongside single class inheritance, as per the slides.","Incorrect; both abstract classes and interfaces can have abstract methods, and interfaces can't have code except for static/default methods.",Incorrect; interfaces cannot be instantiated directly.,"Incorrect; abstract classes can be used in JavaFX, but interfaces are preferred for event handling.","Java allows only single inheritance for classes, but a class can implement multiple interfaces. This flexibility is crucial in GUI programming where classes may need to handle several unrelated behaviors, making interfaces the preferred choice.","Question: When designing a Java class to handle GUI events in JavaFX, why is using an interface preferred over an abstract class?

Options:
A) Interfaces allow multiple inheritance, so a class can handle events and inherit from another class.
B) Abstract classes can only contain abstract methods, while interfaces can contain code.
C) Interfaces are instantiated directly to handle events in JavaFX.
D) Abstract classes are not allowed in JavaFX event-driven programming.

Correct Answer: A

Option A explanation: Correct; interfaces enable a class to implement multiple contracts (e.g., event handling) alongside single class inheritance, as per the slides.

Option B explanation: Incorrect; both abstract classes and interfaces can have abstract methods, and interfaces can't have code except for static/default methods.

Option C explanation: Incorrect; interfaces cannot be instantiated directly.

Option D explanation: Incorrect; abstract classes can be used in JavaFX, but interfaces are preferred for event handling.

Main Explanation: Java allows only single inheritance for classes, but a class can implement multiple interfaces. This flexibility is crucial in GUI programming where classes may need to handle several unrelated behaviors, making interfaces the preferred choice.

Tags: Interfaces, Analyze","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",4,3,4,3,"The question directly addresses interfaces vs. abstract classes in a GUI context, which is relevant to interface design principles (relevance=4). However, the cognitive demand is primarily at the ""Understand"" or ""Apply"" level rather than ""Analyze""—students need to recall why interfaces are preferred rather than analyze trade-offs or evaluate design decisions (bloom=3). Accuracy is strong: Option A is correct, and distractors are reasonable misconceptions, though Option B's explanation could be clearer about default methods in interfaces (accuracy=4). Explanations are generally clear but could better elaborate on *why* multiple inheritance of type matters in event-driven programming beyond stating the rule (explainability=3). The question would be stronger if it asked students to analyze a specific scenario or compare design trade-offs rather than recall a preference."
9a5ce05e-a3ec-4176-a145-7520ebcefff8,2025-11-25T11:19:52.927369,Interfaces,Evaluate,"Given a Java class that needs to be both compared to other instances and handle events, which mechanism is most appropriate for expressing these ""can do"" relationships?",Implement multiple interfaces relevant to the behaviors,Inherit from multiple abstract classes,Use composition instead of inheritance or interfaces,Extend a single abstract class for all behaviors,A,"Correct; interfaces are for weaker ""can do"" relationships and allow implementing multiple behaviors.",Incorrect; Java does not support multiple inheritance of abstract classes.,"Incorrect; the slides emphasize interfaces for these cases, not composition.","Incorrect; a single abstract class is for a strong is-a relationship, not multiple weak ones.","Interfaces allow a class to express multiple ""can do"" relationships (e.g., handling events, being compared) without single inheritance limitations, as stated in the lecture slides.","Question: Given a Java class that needs to be both compared to other instances and handle events, which mechanism is most appropriate for expressing these ""can do"" relationships?

Options:
A) Implement multiple interfaces relevant to the behaviors
B) Inherit from multiple abstract classes
C) Use composition instead of inheritance or interfaces
D) Extend a single abstract class for all behaviors

Correct Answer: A

Option A explanation: Correct; interfaces are for weaker ""can do"" relationships and allow implementing multiple behaviors.
Option B explanation: Incorrect; Java does not support multiple inheritance of abstract classes.
Option C explanation: Incorrect; the slides emphasize interfaces for these cases, not composition.
Option D explanation: Incorrect; a single abstract class is for a strong is-a relationship, not multiple weak ones.

Main Explanation: Interfaces allow a class to express multiple ""can do"" relationships (e.g., handling events, being compared) without single inheritance limitations, as stated in the lecture slides.

Tags: Interfaces, Evaluate","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",5,3,5,4,"The question directly assesses understanding of interfaces and their role in expressing multiple behaviors, which is highly relevant. The correct answer and distractors are technically accurate—Java does prohibit multiple inheritance of classes, interfaces do support multiple implementation, and composition is a valid alternative (though not the focus here). Explanations are clear and specific, correctly identifying why each option is right or wrong. However, Bloom alignment falls short of ""Evaluate"" level; the question primarily asks students to identify/recognize the appropriate mechanism (Bloom: Understand/Apply), rather than evaluate tradeoffs, justify design decisions, or critique multiple valid approaches. The question would better align with ""Evaluate"" if it presented competing valid solutions and asked students to assess their merits."
9bb754db-2155-4ce9-8256-dd26f1b8c0b4,2025-11-25T11:20:02.468784,Interfaces,Evaluate,"Which scenario best justifies using a Java interface rather than an abstract class, based on the lecture?",When a class can handle events in a GUI application.,"When representing an ""Employee is-a Person"" relationship.",When providing default behavior to subclasses to avoid code duplication.,When enforcing single inheritance of parent classes.,A,"Correct; interfaces should be used for weaker relationships, such as ""can handle events.""",Incorrect; this strong is-a relationship is suited for abstract classes.,Incorrect; abstract classes provide default behavior to subclasses.,"Incorrect; interfaces allow multiple implementations, not single inheritance.","According to the lecture, interfaces are ideal for weaker relationships (e.g., ""can handle events""), while abstract classes suit strong is-a relationships and code reuse.","Question: Which scenario best justifies using a Java interface rather than an abstract class, based on the lecture?

Options:
A) When a class can handle events in a GUI application.
B) When representing an ""Employee is-a Person"" relationship.
C) When providing default behavior to subclasses to avoid code duplication.
D) When enforcing single inheritance of parent classes.

Correct Answer: A

Option A explanation: Correct; interfaces should be used for weaker relationships, such as ""can handle events.""
Option B explanation: Incorrect; this strong is-a relationship is suited for abstract classes.
Option C explanation: Incorrect; abstract classes provide default behavior to subclasses.
Option D explanation: Incorrect; interfaces allow multiple implementations, not single inheritance.

Main Explanation: According to the lecture, interfaces are ideal for weaker relationships (e.g., ""can handle events""), while abstract classes suit strong is-a relationships and code reuse.

Tags: Interfaces, Evaluate","a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …
Interfaces define data types, and thus can be used very similarly in polymorphic code
Take Home Points
Both interfaces and abstract classes are used to express contracts (or APIs)
Due to single inheritance, interfaces are quite commonly used for weaker class relationships
Functional interfaces have a single abstract method, and provide support for lambda expressions 

Professor Folajimi
Welcome to COMP1050!
Introduction to JavaFX
JavaFX is a powerful, rich-client application platform for Java.
It replaces the older Swing and AWT libraries.
It is widely used for developing desktop applications and internet-based rich-client applications



Key Features
Rich UI Controls: 
Supports modern UI controls such as sliders, charts, and tables.
CSS Styling: 
Allows developers to style UI elements using CSS, similar to web development.
FXML: 
Provides an XML-based language for defining the UI, making the separation of design and logic easier.
Media Support:

===== CHUNK BREAK =====

e Points (2)
The JCF has many useful data structures
Choosing the correct interface and concrete implementation requires you to understand your data, the important operations, and efficiency tradeoffs
November 15, 2024
Collections & Maps
36

Professor Folajimi
Welcome to COMP1050!
Event-Driven Programming
Recall: JavaFX Basics
So far we’ve learned about some of the basic GUI classes (e.g. shapes, buttons) and how to arrange them in window(s)
A big missing piece: interaction
To have a GUI interact with a user, we have elements respond to user actions, or event-driven programming
Big Picture
When GUI elements want to implement event-driven programming, they will offer ways to ""handle"" an event via a class that implements an interface
Typical sequence:
Create GUI
""Register"" a class to handle event(s), sometimes referred to as a ""listener""
Implement handling code in the listener
A Simple Example (1)
Make a new JavaFX project
Create a GUI with three buttons
final HBox pane = new HBox(100); 
pane.setAlignment(Pos.CENTER);
final Button btnP = new Button(""Papa"");
final Button btnM = new Button(""Mama"");
final Button btnB = new Button(""Baby"");

pane.getChildren().addAll(btnP, btnM, btnB);

===== CHUNK BREAK =====

e, concrete methods supply some nice default behavior (so subclasses can avoid code duplication)
Any limitations?
How many ""parent"" classes can a class have…? Multiple inheritance?
Enter the Interface
In Java, an interface is similar to an abstract class
Creates a “contract” (methods that must exist)
Cannot be instantiated
However, whereas Java limits you to single inheritance, a class can implement any number of interfaces
Because of this flexibility, it is used extensively in object-oriented code
Example: you’ll need them for responding to events in your GUIs
What’s in an Interface?
Can contain only…
Constants, nested types (e.g. classes/interfaces)
Method signatures (no code, like abstract methods)
As of Java 8… static methods, default methods (like concrete methods in superclasses)
All variables are public static final
So you may omit these
All methods are public
So you may omit this
Example
public interface Drawable {
	void draw();
}
public class Rose implements Drawable {
	@Override
	public void draw() {
		System.out.printf(""@}-,-`-"");
	}
}
Drawable.java
Rose.java
Foo.java
public class Foo {
	public static void main(String[] args) {
		final Drawable d = new Rose();

===== CHUNK BREAK =====

stem.out.printf(""%d :"", i);
			if (var.test(i)) {
				System.out.printf("")"");
			} else {
				System.out.printf(""("");
			}
			System.out.printf(""%n"");
		}
	}

	public static void main(String[] args) {
		happyOrSad(new IsEven());
	}
}
I1.java
Foo.java
Example: Anonymous Class
@FunctionalInterface
public interface I1 {
	boolean test(int x);
}
public static void happyOrSad(I1 var) {
	for (int i=0; i<10; i++) {
		System.out.printf(""%d :"", i);
		if (var.test(i)) {
			System.out.printf("")"");			} else {
			System.out.printf(""("");
		}
		System.out.printf(""%n"");
	}
}

public static void main(String[] args) {
	happyOrSad(new I1() {
		@Override
		public boolean test(int p) {
			return p%2 == 0;	
		}
	});
}
I1.java
Foo.java
Notes
Existed before Java 8
Works to create any single-use class (e.g. subclass, non-functional interface)
Interface vs. Abstract Class
Due to single inheritance, abstract classes should be used for strong is-a relationships
Example: Employee is-a Person
Interfaces should be used for weaker relationships – a class can do something, or has a particular property
Example: MyClass can handle events, be compared to MyClass, has a favorite color, …",4,2,4,3,"The question directly assesses interface vs. abstract class concepts, which is relevant to understanding interfaces. However, the cognitive demand is primarily at the ""Understand"" or ""Apply"" level (recognizing when to use interfaces) rather than ""Evaluate"" as claimed—students must identify the correct use case but not critically evaluate trade-offs or judge competing solutions. The correct answer and distractors are technically sound: Option A correctly identifies interfaces for weak relationships (capability-based), while B, C, and D appropriately represent abstract class use cases. Explanations are concise but could be more detailed—they reference ""the lecture"" without elaborating on why event handling specifically exemplifies a weak relationship, and don't explain why multiple inheritance of type (interfaces) differs from code reuse (abstract classes). The question would benefit from more explicit reasoning about the distinction between ""can-do"" (interface) vs. ""is-a"" (abstract class) relationships."
78dd8e56-e23a-4faf-88e2-d2c02a6b9c60,2025-11-25T11:20:11.808748,Generics,Remember,What is the main purpose of using generics in Java?,To allow code re-use while providing compile-time type safety,To enable Java code to run faster,To allow the use of primitive types directly in collections,To eliminate the need for constructors,A,Correct; generics allow code re-use and catch type errors at compile time.,Incorrect; generics do not directly impact code performance.,Incorrect; generics cannot use primitive types directly due to type erasure.,Incorrect; generics do not eliminate the need for constructors.,"Generics enable the use of parameterized types, improving code re-use and compile-time error detection, as highlighted in the lecture slides.","Question: What is the main purpose of using generics in Java?

Options:
A) To allow code re-use while providing compile-time type safety
B) To enable Java code to run faster
C) To allow the use of primitive types directly in collections
D) To eliminate the need for constructors

Correct Answer: A

Option A explanation: Correct; generics allow code re-use and catch type errors at compile time.
Option B explanation: Incorrect; generics do not directly impact code performance.
Option C explanation: Incorrect; generics cannot use primitive types directly due to type erasure.
Option D explanation: Incorrect; generics do not eliminate the need for constructors.

Main Explanation: Generics enable the use of parameterized types, improving code re-use and compile-time error detection, as highlighted in the lecture slides.

Tags: Generics, Remember","List<String> list = new ArrayList<>();List<Integer> list2 = new ArrayList<>();System.out.println(list.getClass() == list2.getClass()); // true
Limitations of Generics
Imitations due to type erasure:
Inability to create generic arrays, use primitive types directly, or instantiate type parameters.

Example:

Invalid:T[] array = new T[10]; // ErrorT obj = new T(); // ErrorValid workaround:@SuppressWarnings(""unchecked"")T[] array = (T[]) new Object[10];
Common Use Cases
Widely used in Java Collections, utility classes, and frameworks 
Handles different types with the same code structure.

List<Integer> intList = new ArrayList<>();Map<String, Integer> map = new HashMap<>();Comparator<String> cmp = (a, b) -> a.compareTo(b);
Take Home Points
Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods
By explicitly typing, errors from general code can be caught at compile time!
Wildcards allow methods to express hierarchical generic types
After compiling, all generics are removed for backwards compatibility
Due to this type erasure, there are some unintuitive restrictions to using generics

Professor Folajimi

===== CHUNK BREAK =====

to be parameters when defining classes, interfaces, and methods
The goal: allow code re-use while still allowing for strong error-detection at compile-time (i.e. as early as possible)
So What is <T>?
The author of the Comparable interface has allowed other software developers to explicitly specialize the interface for one or more ""types"" (i.e. classes/interfaces)
Basic Syntax of Generics
Using Angle Brackets (< >): Types are specified within angle brackets.
Generic Type Parameter:
<T>: Commonly used as a placeholder for any type.

public class Box<T> {
    private T item;
    public void setItem(T item) { 
	this.item = item; 
    }
    public T getItem() { 
 	return item; 
    }
}

Generic Classes
A generic class allows defining a class with a type parameter.
Syntax: 
class ClassName<T> { /* class body */ }
Example: Creating a Box class that can hold any type of item
Example:




Here, Box<Integer> is specified as holding an Integer.


Box<Integer> integerBox = new Box<>(); integerBox.setItem(123);
Integer item = integerBox.getItem(); // No need to cast 
A Small, but Useful, Example
Consider a MutableObject with the following simple methods
Constructors (no-arg=null, or value)

===== CHUNK BREAK =====

ming Conventions
Multiple Type Parameters
Generics can support multiple types simultaneously, using comma-separated parameters.
Syntax: class ClassName<T, U> { /* class body */ }
Example:






Usage:
public class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    public K getKey() { return key; }
    public V getValue() { return value; }
}
Pair<String, Integer> student = new Pair<>(""Alice"", 90);
Generic Methods

Generic methods allow a method to operate on different types without specifying them upfront in a class definition. The type parameter is defined before the return type.

public <T> void printArray(T[] array) {    for (T element : array) {        System.out.println(element);    }}
Bounded Type Parameters

You can restrict the types that can be used as type arguments using bounds. Bounded types allow access to methods defined in the bound type.


public <T extends Number> double add(T a, T b) {    return a.doubleValue() + b.doubleValue();}
Bounded Type Example 
11/13/2025
public class BoundedType {

    // Generic method with bounded type

===== CHUNK BREAK =====

hierarchical generic types
After compiling, all generics are removed for backwards compatibility
Due to this type erasure, there are some unintuitive restrictions to using generics

Professor Folajimi
Welcome to COMP1050!
Java Collection Framework
What is a Data Structure?
A data structure is a collection of data organized in some fashion
The structure not only stores data but also supports operations for accessing/manipulating the data
Java provides several data structures that can be used to organize/manipulate data efficiently in the Java Collections Framework
Java Collections Framework (JCF)
The Java Collections Framework (JCF) is a unified architecture for storing and manipulating groups of objects in Java.
Key Features:
Reduces programming effort by providing reusable data structures and algorithms.
Provides type safety and eliminates the need for manually implementing collections.
Includes Interfaces, Classes, and Algorithms.
JCF supports two types of containers:
Storing a collection of elements (collection)
Storing key/value pairs (map)



Example
final Collection<String> c = new ArrayList<>();
c.add(""New York"");
c.add(""Atlanta"");
c.add(""Dallas"");
c.add(""Madison"");",5,2,5,5,"The question directly assesses understanding of generics' core purpose (relevance=5). All explanations are technically accurate and well-reasoned; Option C correctly notes type erasure limitations, and Option D appropriately clarifies constructor independence (accuracy=5). Explanations are clear and specific, referencing compile-time type safety and code reuse (explainability=5). However, the cognitive demand exceeds ""Remember"" level—it requires understanding the fundamental design rationale and trade-offs of generics, which aligns better with Bloom's ""Understand"" (level 2) rather than simple recall (bloom=2). The question is well-constructed overall but slightly misaligned if intended for basic recall assessment."
549da48e-16fd-48fa-b466-f7039e23306e,2025-11-25T11:20:20.313885,Generics,Remember,What is the main purpose of using generics in Java?,To enable code re-use and strong error-detection at compile-time,To allow the use of primitive types directly in collections,To automatically create arrays of any type parameter,To avoid specifying types in data structures,A,Correct. Generics allow code re-use and provide strong error-detection at compile-time.,Incorrect. Generics do not support primitive types directly due to type erasure.,Incorrect. Creating generic arrays is not allowed because of type erasure.,Incorrect. Generics require explicit type specification for type safety.,"Generics are designed to help reuse code with different types and to catch errors at compile time, improving reliability and maintainability in Java programs.","Question: What is the main purpose of using generics in Java?

Options:
A) To enable code re-use and strong error-detection at compile-time
B) To allow the use of primitive types directly in collections
C) To automatically create arrays of any type parameter
D) To avoid specifying types in data structures

Correct Answer: A

Option A explanation: Correct. Generics allow code re-use and provide strong error-detection at compile-time.
Option B explanation: Incorrect. Generics do not support primitive types directly due to type erasure.
Option C explanation: Incorrect. Creating generic arrays is not allowed because of type erasure.
Option D explanation: Incorrect. Generics require explicit type specification for type safety.

Main Explanation: Generics are designed to help reuse code with different types and to catch errors at compile time, improving reliability and maintainability in Java programs.

Tags: Generics, Remember","List<String> list = new ArrayList<>();List<Integer> list2 = new ArrayList<>();System.out.println(list.getClass() == list2.getClass()); // true
Limitations of Generics
Imitations due to type erasure:
Inability to create generic arrays, use primitive types directly, or instantiate type parameters.

Example:

Invalid:T[] array = new T[10]; // ErrorT obj = new T(); // ErrorValid workaround:@SuppressWarnings(""unchecked"")T[] array = (T[]) new Object[10];
Common Use Cases
Widely used in Java Collections, utility classes, and frameworks 
Handles different types with the same code structure.

List<Integer> intList = new ArrayList<>();Map<String, Integer> map = new HashMap<>();Comparator<String> cmp = (a, b) -> a.compareTo(b);
Take Home Points
Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods
By explicitly typing, errors from general code can be caught at compile time!
Wildcards allow methods to express hierarchical generic types
After compiling, all generics are removed for backwards compatibility
Due to this type erasure, there are some unintuitive restrictions to using generics

Professor Folajimi

===== CHUNK BREAK =====

to be parameters when defining classes, interfaces, and methods
The goal: allow code re-use while still allowing for strong error-detection at compile-time (i.e. as early as possible)
So What is <T>?
The author of the Comparable interface has allowed other software developers to explicitly specialize the interface for one or more ""types"" (i.e. classes/interfaces)
Basic Syntax of Generics
Using Angle Brackets (< >): Types are specified within angle brackets.
Generic Type Parameter:
<T>: Commonly used as a placeholder for any type.

public class Box<T> {
    private T item;
    public void setItem(T item) { 
	this.item = item; 
    }
    public T getItem() { 
 	return item; 
    }
}

Generic Classes
A generic class allows defining a class with a type parameter.
Syntax: 
class ClassName<T> { /* class body */ }
Example: Creating a Box class that can hold any type of item
Example:




Here, Box<Integer> is specified as holding an Integer.


Box<Integer> integerBox = new Box<>(); integerBox.setItem(123);
Integer item = integerBox.getItem(); // No need to cast 
A Small, but Useful, Example
Consider a MutableObject with the following simple methods
Constructors (no-arg=null, or value)

===== CHUNK BREAK =====

ming Conventions
Multiple Type Parameters
Generics can support multiple types simultaneously, using comma-separated parameters.
Syntax: class ClassName<T, U> { /* class body */ }
Example:






Usage:
public class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    public K getKey() { return key; }
    public V getValue() { return value; }
}
Pair<String, Integer> student = new Pair<>(""Alice"", 90);
Generic Methods

Generic methods allow a method to operate on different types without specifying them upfront in a class definition. The type parameter is defined before the return type.

public <T> void printArray(T[] array) {    for (T element : array) {        System.out.println(element);    }}
Bounded Type Parameters

You can restrict the types that can be used as type arguments using bounds. Bounded types allow access to methods defined in the bound type.


public <T extends Number> double add(T a, T b) {    return a.doubleValue() + b.doubleValue();}
Bounded Type Example 
11/13/2025
public class BoundedType {

    // Generic method with bounded type

===== CHUNK BREAK =====

hierarchical generic types
After compiling, all generics are removed for backwards compatibility
Due to this type erasure, there are some unintuitive restrictions to using generics

Professor Folajimi
Welcome to COMP1050!
Java Collection Framework
What is a Data Structure?
A data structure is a collection of data organized in some fashion
The structure not only stores data but also supports operations for accessing/manipulating the data
Java provides several data structures that can be used to organize/manipulate data efficiently in the Java Collections Framework
Java Collections Framework (JCF)
The Java Collections Framework (JCF) is a unified architecture for storing and manipulating groups of objects in Java.
Key Features:
Reduces programming effort by providing reusable data structures and algorithms.
Provides type safety and eliminates the need for manually implementing collections.
Includes Interfaces, Classes, and Algorithms.
JCF supports two types of containers:
Storing a collection of elements (collection)
Storing key/value pairs (map)



Example
final Collection<String> c = new ArrayList<>();
c.add(""New York"");
c.add(""Atlanta"");
c.add(""Dallas"");
c.add(""Madison"");",5,2,5,5,"The question directly assesses understanding of generics' core purpose. All explanations are technically accurate: Option A correctly identifies code reuse and compile-time type safety; Option B accurately notes primitives aren't supported due to type erasure; Option C correctly states generic arrays can't be created; Option D properly explains that generics require explicit types. The explanations are clear and specific. However, the cognitive demand is slightly above ""Remember"" (Bloom 1)—it requires ""Understand"" (Bloom 2) since students must comprehend the fundamental purpose and design philosophy of generics rather than merely recall a definition. The question is well-constructed overall with no technical errors."
