id,timestamp,topic,subtopic,bloom_level,question_stem,option_a,option_b,option_c,option_d,correct_answer,a_explanation,b_explanation,c_explanation,d_explanation,main_explanation,raw_model_response,retrieved_slide_files,retrieved_chunk_indices,eval_relevance,eval_bloom_alignment,eval_accuracy,eval_explainability,eval_justification
ba6bf88f-776b-47cb-ba86-5e7c401e5096,2025-11-25T06:42:54.388784,Java Fundamentals,Variables and data types,Remember,Which of the following is a valid way to declare and initialize a Java variable of type char?,char letter = 'A';,"char letter = ""A"";",char letter = A;,char letter = 'AB';,A,Correct. Single quotes are used to assign a char value in Java.,"Incorrect. Double quotes denote a String, not a char.",Incorrect. The value 'A' must be enclosed in single quotes for char.,"Incorrect. A char can only hold a single character, not two.","In Java, char variables must be assigned a single character enclosed in single quotes, as shown in option A.","Question: Which of the following is a valid way to declare and initialize a Java variable of type char?

Options:  
A) char letter = 'A';  
B) char letter = ""A"";  
C) char letter = A;  
D) char letter = 'AB';

Correct Answer: A

Option A explanation: Correct. Single quotes are used to assign a char value in Java.

Option B explanation: Incorrect. Double quotes denote a String, not a char.

Option C explanation: Incorrect. The value 'A' must be enclosed in single quotes for char.

Option D explanation: Incorrect. A char can only hold a single character, not two.

Main Explanation: In Java, char variables must be assigned a single character enclosed in single quotes, as shown in option A.

Tags: Java Fundamentals, Variables and data types, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,5,5,"This question directly assesses the fundamental concept of char variable declaration and initialization in Java, which is core to the Variables and data types subtopic. All four options represent common mistakes or the correct approach, making them effective distractors. The explanations are clear and specific, addressing why each option is correct or incorrect (single vs. double quotes, need for quotes, single character limitation). The cognitive demand perfectly matches the Remember level of Bloom's taxonomy, as it requires students to recall the syntax rules for char declaration without requiring analysis or application. The question is unambiguous with no technical errors in the answer key or explanations."
d5dfbc6f-533e-4435-a0ed-5fa2269ad411,2025-11-25T06:43:04.669601,Java Fundamentals,Variables and data types,Remember,Which of the following statements correctly declares and initializes a variable to store a single Unicode character in Java?,char letter = 'A';,String letter = 'A';,"char letter = ""A"";",int letter = 'A';,A,"Correct. 'A' in single quotes is a char literal, and 'char' is the correct data type.","Incorrect. String should use double quotes, and 'A' in single quotes is not a String literal.","Incorrect. ""A"" is a String literal, not a char, so the types do not match.","Incorrect. Although assigning 'A' to int is valid due to implicit casting, the question asks for storing a character.","In Java, single quotes denote char literals, and the char type is used to store single Unicode characters. Only option A matches both the correct type and syntax.","Question: Which of the following statements correctly declares and initializes a variable to store a single Unicode character in Java?

Options:
A) char letter = 'A';
B) String letter = 'A';
C) char letter = ""A"";
D) int letter = 'A';

Correct Answer: A

Option A explanation: Correct. 'A' in single quotes is a char literal, and 'char' is the correct data type.
Option B explanation: Incorrect. String should use double quotes, and 'A' in single quotes is not a String literal.
Option C explanation: Incorrect. ""A"" is a String literal, not a char, so the types do not match.
Option D explanation: Incorrect. Although assigning 'A' to int is valid due to implicit casting, the question asks for storing a character.

Main Explanation: In Java, single quotes denote char literals, and the char type is used to store single Unicode characters. Only option A matches both the correct type and syntax.

Tags: Java Fundamentals, Variables and data types, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,5,5,"The question directly assesses understanding of Java's char data type and literal syntax, which is fundamental to the Variables and Data Types subtopic. All options are technically accurate: A is correct (char with single quotes), B incorrectly uses single quotes with String type, C incorrectly uses double quotes with char type, and D is valid Java but doesn't answer the specific question about storing characters. The explanations clearly distinguish between char literals (single quotes) and String literals (double quotes), and explain why each distractor is incorrect. The cognitive demand appropriately matches the ""Remember"" level—students must recall the correct syntax and data type for character storage without requiring analysis or synthesis."
e96b2419-a80f-4224-818e-2413ad40989e,2025-11-25T06:43:20.845719,Java Fundamentals,Variables and data types,Remember,Which data type is best suited for storing the value 1234567890123 in Java?,int,long,float,short,B,Incorrect. int cannot store numbers as large as 1234567890123.,Correct. long can store large integers like 1234567890123.,Incorrect. float is used for fractional numbers and may lose precision.,Incorrect. short has a much smaller range than required.,"The long data type is designed for storing large integer values and accommodates the value 1234567890123, unlike int and short.","Question: Which data type is best suited for storing the value 1234567890123 in Java?

Options:  
A) int  
B) long  
C) float  
D) short  

Correct Answer: B

Option A explanation: Incorrect. int cannot store numbers as large as 1234567890123.  
Option B explanation: Correct. long can store large integers like 1234567890123.  
Option C explanation: Incorrect. float is used for fractional numbers and may lose precision.  
Option D explanation: Incorrect. short has a much smaller range than required.

Main Explanation: The long data type is designed for storing large integer values and accommodates the value 1234567890123, unlike int and short.

Tags: Java Fundamentals, Variables and data types, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,5,4,"The question directly assesses knowledge of Java primitive data types and their ranges, which is core to the Variables and data types subtopic. The correct answer (long) and distractors (int, short, float) are all technically accurate—int maxes out at 2,147,483,647, short at 32,767, float loses precision with large integers, and long accommodates values up to 9,223,372,036,854,775,807. The cognitive demand aligns well with ""Remember"" as it requires recalling data type ranges. Explanations are clear and specific, though the float explanation could be slightly more precise by mentioning that while float can technically store the value, it would lose precision due to its 32-bit representation and mantissa limitations."
7c0a88ac-c847-43fc-9bd7-43e466610480,2025-11-25T06:43:29.038044,Java Fundamentals,Variables and data types,Understand,Which of the following variable declarations will cause a compile-time error in Java?,int count = 10;,double price = 29.99;,char symbol = 'AB';,boolean isActive = false;,C,This is a valid declaration of an integer variable.,This is a valid declaration of a double variable.,"This is incorrect because a char can hold only a single character, not two.",This is a valid declaration of a boolean variable.,"In Java, the char data type stores a single character. Assigning more than one character to a char variable, as in option C, is not allowed and results in a compile-time error.","Question: Which of the following variable declarations will cause a compile-time error in Java?

Options:  
A) int count = 10;  
B) double price = 29.99;  
C) char symbol = 'AB';  
D) boolean isActive = false;  

Correct Answer: C

Option A explanation: This is a valid declaration of an integer variable.

Option B explanation: This is a valid declaration of a double variable.

Option C explanation: This is incorrect because a char can hold only a single character, not two.

Option D explanation: This is a valid declaration of a boolean variable.

Main Explanation: In Java, the char data type stores a single character. Assigning more than one character to a char variable, as in option C, is not allowed and results in a compile-time error.

Tags: Java Fundamentals, Variables and data types, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of Java's primitive data types and their constraints, which is core to the Variables and Data Types subtopic. All options are technically accurate—option C will indeed produce a compile-time error because char accepts only single characters. The explanations are clear and specific, correctly identifying why C fails and why others succeed. Bloom alignment is strong for ""Understand"" level, though the question borders on ""Apply"" since students must recognize and apply the constraint rule. The question effectively tests conceptual understanding of data type limitations rather than mere recall."
7bf4e0d4-d634-4e4e-8c19-ee938fa87fd9,2025-11-25T06:43:37.812483,Java Fundamentals,Variables and data types,Understand,"What is the result of compiling and running the following code snippet?
int num = 7.5;",The code compiles and assigns 7 to num.,The code compiles and assigns 7.5 to num.,Compilation error due to incompatible types.,The code compiles but throws a runtime exception.,C,Incorrect; implicit narrowing from double to int is not allowed.,"Incorrect; 7.5 is a double, but 'num' is declared as int, causing a compilation error.",Correct; assigning a double literal to an int variable without casting causes a compilation error.,"Incorrect; the error occurs during compilation, not at runtime.","In Java, assigning a floating-point literal to an int variable without explicit casting results in a compilation error because of incompatible data types.","Question: What is the result of compiling and running the following code snippet?
int num = 7.5;

Options:
A) The code compiles and assigns 7 to num.
B) The code compiles and assigns 7.5 to num.
C) Compilation error due to incompatible types.
D) The code compiles but throws a runtime exception.

Correct Answer: C

Option A explanation: Incorrect; implicit narrowing from double to int is not allowed.
Option B explanation: Incorrect; 7.5 is a double, but 'num' is declared as int, causing a compilation error.
Option C explanation: Correct; assigning a double literal to an int variable without casting causes a compilation error.
Option D explanation: Incorrect; the error occurs during compilation, not at runtime.

Main Explanation: In Java, assigning a floating-point literal to an int variable without explicit casting results in a compilation error because of incompatible data types.

Tags: Java Fundamentals, Variables and data types, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of Java's type system and implicit type conversion rules, which is core to the Variables and Data Types subtopic. All explanations are technically accurate and clearly distinguish why implicit narrowing is not allowed. The distractors effectively target common misconceptions (implicit conversion, runtime errors). Bloom alignment is strong for ""Understand"" level, though the question borders on ""Apply"" since students must recognize and apply type compatibility rules rather than just recall them. The question is well-constructed with clear, unambiguous answers and comprehensive explanations."
8f63829f-c8ac-4f6b-adbb-c64ecde966e3,2025-11-25T06:43:46.546630,Java Fundamentals,Variables and data types,Understand,Which of the following statements correctly declares and initializes a variable to store the average monthly temperature as a decimal value?,int averageTemp = 23.5;,double averageTemp = 23.5;,boolean averageTemp = 23.5;,char averageTemp = 23.5;,B,Incorrect; int cannot store decimal values.,Correct; double can store decimal values like 23.5.,Incorrect; boolean can only be true or false.,"Incorrect; char stores single characters, not numbers.","To store decimal values, the double data type should be used; int, boolean, and char are not suitable for storing decimal numbers.","Question: Which of the following statements correctly declares and initializes a variable to store the average monthly temperature as a decimal value?

Options:
A) int averageTemp = 23.5;
B) double averageTemp = 23.5;
C) boolean averageTemp = 23.5;
D) char averageTemp = 23.5;

Correct Answer: B

Option A explanation: Incorrect; int cannot store decimal values.
Option B explanation: Correct; double can store decimal values like 23.5.
Option C explanation: Incorrect; boolean can only be true or false.
Option D explanation: Incorrect; char stores single characters, not numbers.

Main Explanation: To store decimal values, the double data type should be used; int, boolean, and char are not suitable for storing decimal numbers.

Tags: Java Fundamentals, Variables and data types, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of Java primitive data types and their appropriate use cases, perfectly matching the stated topic and subtopic. All explanations are technically accurate and clear—each distractor represents a common misconception (int truncates decimals, boolean is logical, char is for characters). The explanations are concise and educational. Bloom alignment is strong for ""Understand"" level, though it could arguably touch ""Apply"" since students must select the correct type for a specific scenario; however, the straightforward nature keeps it solidly at Understand. The question is well-constructed with no ambiguity."
ea21a14b-229f-4e09-8cb2-d878835c7723,2025-11-25T06:43:54.226052,Java Fundamentals,Variables and data types,Apply,"What will be the output of the following Java code?

```java
int x = 5;
double y = 2;
double result = x / y;
System.out.println(result);
```",2.0,2.5,2,Compilation error,B,"Incorrect. Dividing 5 by 2 using doubles produces 2.5, not 2.0.",Correct. `x / y` performs floating-point division resulting in 2.5.,"Incorrect. Integer division only occurs if both operands are integers, which is not the case here.",Incorrect. The code compiles without errors.,"The division involves a double, so Java performs floating-point division, resulting in 2.5 being printed.","Question: What will be the output of the following Java code?

```java
int x = 5;
double y = 2;
double result = x / y;
System.out.println(result);
```

Options:
A) 2.0
B) 2.5
C) 2
D) Compilation error

Correct Answer: B

Option A explanation: Incorrect. Dividing 5 by 2 using doubles produces 2.5, not 2.0.
Option B explanation: Correct. `x / y` performs floating-point division resulting in 2.5.
Option C explanation: Incorrect. Integer division only occurs if both operands are integers, which is not the case here.
Option D explanation: Incorrect. The code compiles without errors.

Main Explanation: The division involves a double, so Java performs floating-point division, resulting in 2.5 being printed.

Tags: Java Fundamentals, Variables and data types, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of Java's type system and arithmetic operations with mixed data types, which is core to the Variables and Data Types subtopic. All explanations are technically accurate and clearly distinguish why each distractor is wrong. The question effectively tests the ability to apply knowledge of type promotion and floating-point division rules. Bloom alignment is strong (Apply level) as students must predict output by applying their understanding of type coercion and division behavior, though it leans slightly toward lower-order application rather than requiring deeper problem-solving or analysis."
3e192c05-6158-4702-8ab5-ec9e2a27b40e,2025-11-25T06:44:04.466739,Java Fundamentals,Variables and data types,Apply,"What is the output of the following code snippet?

```java
int a = 5;
double b = 4.5;
a += b;
System.out.println(a);
```",9.5,9,5,Compilation error,B,Incorrect. The `+=` operator performs implicit casting; the result is assigned as an integer.,"Correct. `a += b;` adds 4.5 to 5 (result is 9.5), but assigns the integer part (9) to `a`.","Incorrect. `a` is updated, not left as 5.",Incorrect. There is no compilation error; implicit casting is allowed in compound assignment.,"In Java, `a += b;` is equivalent to `a = (int)(a + b);`. The sum is 9.5, but only the integer part (9) is stored in `a`, so the output is 9.","Question: What is the output of the following code snippet?

```java
int a = 5;
double b = 4.5;
a += b;
System.out.println(a);
```

Options:
A) 9.5
B) 9
C) 5
D) Compilation error

Correct Answer: B

Option A explanation: Incorrect. The `+=` operator performs implicit casting; the result is assigned as an integer.
Option B explanation: Correct. `a += b;` adds 4.5 to 5 (result is 9.5), but assigns the integer part (9) to `a`.
Option C explanation: Incorrect. `a` is updated, not left as 5.
Option D explanation: Incorrect. There is no compilation error; implicit casting is allowed in compound assignment.

Main Explanation: In Java, `a += b;` is equivalent to `a = (int)(a + b);`. The sum is 9.5, but only the integer part (9) is stored in `a`, so the output is 9.

Tags: Java Fundamentals, Variables and data types, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of type casting, compound assignment operators, and implicit type conversion—core concepts in the Variables and Data Types subtopic. It is technically accurate with correct answer and distractors that represent common misconceptions (forgetting about casting, thinking no change occurs, or expecting a compilation error). Explanations are clear and specific, correctly identifying that `a += b` is equivalent to `a = (int)(a + b)`. Bloom alignment is strong at the ""Apply"" level, as students must apply knowledge of type casting rules and operator behavior to predict output, though it borders on ""Understand"" since it primarily tests recall of implicit casting behavior rather than requiring deeper problem-solving or synthesis."
07bb1652-44a4-4c67-a03e-a61d545b5d5e,2025-11-25T06:44:14.504232,Java Fundamentals,Variables and data types,Apply,"Given the following code, what is the value of result after execution?

```java
int a = 7;
double b = 2.5;
int result = (int)(a / b);
```",2,3,2.8,3.0,B,"Incorrect. `a / b` yields 2.8, but casting to int truncates, not rounds.",Correct. `a / b` is 2.8; casting to int gives 2.,"Incorrect. The result variable is of type int, not double.","Incorrect. 3.0 is a double, and the correct truncated value is 2.","Dividing an int by a double yields a double (2.8). Casting this result to int truncates the decimal, resulting in 2.","Question: Given the following code, what is the value of result after execution?

```java
int a = 7;
double b = 2.5;
int result = (int)(a / b);
```

Options:
A) 2
B) 3
C) 2.8
D) 3.0

Correct Answer: B

Option A explanation: Incorrect. `a / b` yields 2.8, but casting to int truncates, not rounds.
Option B explanation: Correct. `a / b` is 2.8; casting to int gives 2.
Option C explanation: Incorrect. The result variable is of type int, not double.
Option D explanation: Incorrect. 3.0 is a double, and the correct truncated value is 2.

Main Explanation: Dividing an int by a double yields a double (2.8). Casting this result to int truncates the decimal, resulting in 2.

Tags: Java Fundamentals, Variables and data types, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,2,3,"The question is highly relevant to Java fundamentals and type conversion. However, there is a critical accuracy error: the correct answer should be A (2), not B (3). The division 7 / 2.5 = 2.8, and casting to int truncates to 2. The provided correct answer of B (3) is mathematically incorrect. The explanations contain contradictory information—Option B's explanation correctly states the answer is 2, yet claims B is correct when B states 3. This creates significant confusion. The question appropriately targets the Apply level by requiring students to predict output through type conversion mechanics. The explanations are generally clear but undermined by the fundamental error in the answer key."
151c95a1-79df-48fe-b443-483d84d86642,2025-11-25T07:02:00.208424,Java Fundamentals,Variables and data types,Remember,Which of the following variable declarations correctly assigns a character value in Java?,char letter = 'A';,"char letter = ""A"";",char letter = A;,char letter = 65.0;,A,"This correctly assigns the character 'A' using single quotes, which is the proper syntax for char.","Incorrect, as double quotes denote a String, not a char.","Incorrect, as the character literal 'A' must be in single quotes.","Incorrect, as 65.0 is a double, not a valid char literal.","In Java, char values are represented with single quotes around a single character, such as 'A'. Double quotes are for String values, and numeric or unquoted values do not match the char type requirements.","Question: Which of the following variable declarations correctly assigns a character value in Java?

Options:  
A) char letter = 'A';  
B) char letter = ""A"";  
C) char letter = A;  
D) char letter = 65.0;

Correct Answer: A

Option A explanation: This correctly assigns the character 'A' using single quotes, which is the proper syntax for char.
Option B explanation: Incorrect, as double quotes denote a String, not a char.
Option C explanation: Incorrect, as the character literal 'A' must be in single quotes.
Option D explanation: Incorrect, as 65.0 is a double, not a valid char literal.

Main Explanation: In Java, char values are represented with single quotes around a single character, such as 'A'. Double quotes are for String values, and numeric or unquoted values do not match the char type requirements.

Tags: Java Fundamentals, Variables and data types, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,5,5,"This question directly assesses understanding of Java's char data type and literal syntax, which is fundamental to the Variables and data types subtopic. The correct answer (A) uses proper single-quote syntax for char literals. All distractors are technically accurate misconceptions: Option B uses double quotes (String syntax), Option C omits quotes entirely (syntax error), and Option D uses a double value (type mismatch). The explanations are clear and specific, distinguishing between char, String, and numeric types. The cognitive demand appropriately matches the ""Remember"" level—students must recall the correct syntax for char declarations without requiring analysis or application. The question is unambiguous with no edge cases or alternative valid answers."
b4c26bd9-7667-4c8f-91c1-7289b583e399,2025-11-25T07:02:09.823422,Java Fundamentals,Variables and data types,Remember,Which of the following variable declarations correctly creates an integer variable in Java?,int count = 10;,"Integer count = ""10"";",float count = 10.0f;,char count = 10;,A,Correct; this creates an int variable named count and initializes it to 10.,"Incorrect; ""10"" is a String, not compatible with Integer.",Incorrect; float is not an integer type and 10.0f is a floating-point literal.,"Incorrect; char stores a single character or Unicode, not an integer variable.","In Java, int is the primitive data type for integers. Option A correctly uses int and assigns a valid integer value, while the others either use incompatible types or non-integer literals.","Question: Which of the following variable declarations correctly creates an integer variable in Java?

Options:
A) int count = 10;
B) Integer count = ""10"";
C) float count = 10.0f;
D) char count = 10;

Correct Answer: A

Option A explanation: Correct; this creates an int variable named count and initializes it to 10.
Option B explanation: Incorrect; ""10"" is a String, not compatible with Integer.
Option C explanation: Incorrect; float is not an integer type and 10.0f is a floating-point literal.
Option D explanation: Incorrect; char stores a single character or Unicode, not an integer variable.

Main Explanation: In Java, int is the primitive data type for integers. Option A correctly uses int and assigns a valid integer value, while the others either use incompatible types or non-integer literals.

Tags: Java Fundamentals, Variables and data types, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,4,4,"The question directly assesses understanding of Java integer variable declaration, perfectly matching the stated topic and subtopic. It aligns well with the ""Remember"" level as it tests recall of correct syntax. The correct answer is unambiguous and technically accurate. Option B's explanation could be more precise—while ""10"" is indeed a String, the real issue is that a String cannot be auto-unboxed to Integer without parsing. Option D is slightly ambiguous since char is technically a numeric type in Java (stores Unicode values 0-65535), though it's not typically considered an ""integer variable"" in the conventional sense. The explanations are generally clear and educational, though they could benefit from slightly more technical depth regarding type compatibility rules."
aca07d3d-248a-4a48-a9f2-21dec1bed763,2025-11-25T07:02:20.270019,Java Fundamentals,Variables and data types,Remember,Which of the following variable declarations in Java will NOT compile successfully?,int $score = 50;,double 3height = 1.75;,char letter = 'A';,boolean isOpen = false;,B,Correct syntax; variable names can begin with '$'.,Incorrect; variable names cannot begin with a digit.,Correct syntax; variable and value are valid.,Correct syntax for a boolean variable.,"In Java, variable names must not begin with digits. Option B violates this rule, causing a compilation error.","Question: Which of the following variable declarations in Java will NOT compile successfully?

Options:
A) int $score = 50;
B) double 3height = 1.75;
C) char letter = 'A';
D) boolean isOpen = false;

Correct Answer: B

Option A explanation: Correct syntax; variable names can begin with '$'.
Option B explanation: Incorrect; variable names cannot begin with a digit.
Option C explanation: Correct syntax; variable and value are valid.
Option D explanation: Correct syntax for a boolean variable.

Main Explanation: In Java, variable names must not begin with digits. Option B violates this rule, causing a compilation error.

Tags: Java Fundamentals, Variables and data types, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,5,5,"The question directly assesses knowledge of Java variable naming conventions, a fundamental concept in the Variables and Data Types subtopic. The correct answer (B) clearly violates the rule that variable names cannot begin with digits, while all distractors use valid syntax. Option A effectively tests whether students know that '$' is a valid starting character, adding depth. The explanations are concise and accurate, clearly stating the rule and why each option succeeds or fails. The cognitive demand perfectly matches the ""Remember"" level—students must recall the specific naming rules for Java identifiers without requiring analysis or application."
a1dd3927-10cd-4a07-91b6-af3b757bcfb5,2025-11-25T07:02:32.264243,Java Fundamentals,Variables and data types,Understand,Which of the following variable declarations in Java will result in a compilation error?,int value = 100L;,double rate = 5.5;,char letter = 'A';,boolean isActive = true;,A,This causes an error because a long literal (100L) cannot be assigned to an int without an explicit cast.,This is correct; 5.5 is a valid double literal.,This is correct; 'A' is a valid char literal.,This is correct; true is a valid boolean literal.,Java enforces type compatibility in variable assignments. Assigning a long value (with 'L' suffix) directly to an int variable is not allowed without explicit casting.,"Question: Which of the following variable declarations in Java will result in a compilation error?

Options:  
A) int value = 100L;  
B) double rate = 5.5;  
C) char letter = 'A';  
D) boolean isActive = true;  

Correct Answer: A

Option A explanation: This causes an error because a long literal (100L) cannot be assigned to an int without an explicit cast.

Option B explanation: This is correct; 5.5 is a valid double literal.

Option C explanation: This is correct; 'A' is a valid char literal.

Option D explanation: This is correct; true is a valid boolean literal.

Main Explanation: Java enforces type compatibility in variable assignments. Assigning a long value (with 'L' suffix) directly to an int variable is not allowed without explicit casting.

Tags: Java Fundamentals, Variables and data types, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,4,4,"The question directly assesses understanding of Java type compatibility and literal suffixes, which is core to the Variables and Data Types subtopic. The correct answer is well-chosen as it tests a common misconception—that any numeric literal can be assigned to any numeric type. However, there is a minor accuracy concern: while 100L cannot be directly assigned to int in standard Java, the statement is technically true only because the value exceeds int range OR due to type strictness; actually, 100L fits within int range but the type mismatch itself causes the error, which the explanation could clarify better. The distractors are all valid and unambiguous. Explanations are clear and educational, though the explanation for Option A could be more precise by noting that even though 100 fits in an int, the long type itself requires explicit casting. The question appropriately targets the ""Understand"" level by requiring students to recognize type compatibility rules rather than apply or analyze them."
c066d138-8e7a-471d-ab92-277ab06aac39,2025-11-25T07:02:41.881164,Java Fundamentals,Variables and data types,Understand,Which statement about Java primitive data types is true?,All primitive data types in Java are signed.,The 'char' data type can store negative values.,The 'float' data type uses single precision.,The 'boolean' data type can hold three possible values.,C,Incorrect. 'char' and 'boolean' are not signed; 'char' is unsigned.,Incorrect. 'char' stores only positive values (0 to 65535).,Correct. 'float' uses single-precision (32-bit) representation.,Incorrect. 'boolean' holds only 'true' or 'false'.,"Java’s 'float' uses 32-bit IEEE 754 single-precision format. Some primitives, like 'char', are unsigned, and 'boolean' is binary, not ternary.","Question: Which statement about Java primitive data types is true?

Options:  
A) All primitive data types in Java are signed.  
B) The 'char' data type can store negative values.  
C) The 'float' data type uses single precision.  
D) The 'boolean' data type can hold three possible values.

Correct Answer: C

Option A explanation: Incorrect. 'char' and 'boolean' are not signed; 'char' is unsigned.  
Option B explanation: Incorrect. 'char' stores only positive values (0 to 65535).  
Option C explanation: Correct. 'float' uses single-precision (32-bit) representation.  
Option D explanation: Incorrect. 'boolean' holds only 'true' or 'false'.

Main Explanation: Java’s 'float' uses 32-bit IEEE 754 single-precision format. Some primitives, like 'char', are unsigned, and 'boolean' is binary, not ternary.

Tags: Java Fundamentals, Variables and data types, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of Java primitive data types, which is core to the stated topic/subtopic. All explanations are technically accurate and clearly distinguish why each option is correct or incorrect. The correct answer (C) requires recalling a specific technical detail about float representation, which aligns well with Bloom's ""Understand"" level. The distractors effectively test common misconceptions about primitives (signedness, char range, boolean values). The only minor consideration is that option C borders on ""Remember"" rather than pure ""Understand,"" as it primarily tests factual recall of the 32-bit single-precision specification rather than deeper conceptual understanding, though this is appropriate for an introductory OOP course."
4ef24ee0-f81c-420d-ae02-7a2bc42d4d97,2025-11-25T07:02:52.378830,Java Fundamentals,Variables and data types,Understand,What is the value and data type of the variable 'result' after executing: double result = 10 / 4;?,"2.5, double","2, int","2.0, double","2.5, int",C,"Incorrect. 10 / 4 evaluates to 2 (int), which is then converted to 2.0 (double).","Incorrect. 'result' is declared as double, not int.","Correct. Integer division yields 2, which is converted to 2.0 and stored as a double.","Incorrect. 2.5 is not produced by integer division, and 'result' is not int.","The expression 10 / 4 uses integer division, resulting in 2. This value is then implicitly cast to 2.0 and stored as a double in 'result'.","Question: What is the value and data type of the variable 'result' after executing: double result = 10 / 4;?

Options:
A) 2.5, double
B) 2, int
C) 2.0, double
D) 2.5, int

Correct Answer: C

Option A explanation: Incorrect. 10 / 4 evaluates to 2 (int), which is then converted to 2.0 (double).
Option B explanation: Incorrect. 'result' is declared as double, not int.
Option C explanation: Correct. Integer division yields 2, which is converted to 2.0 and stored as a double.
Option D explanation: Incorrect. 2.5 is not produced by integer division, and 'result' is not int.

Main Explanation: The expression 10 / 4 uses integer division, resulting in 2. This value is then implicitly cast to 2.0 and stored as a double in 'result'.

Tags: Java Fundamentals, Variables and data types, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,5,5,5,"This question directly assesses understanding of Java's type system, integer division behavior, and implicit type conversion—core concepts in the Variables and Data Types subtopic. The correct answer (C) is technically accurate: 10 / 4 performs integer division yielding 2, which is then implicitly widened to 2.0 when assigned to a double variable. All distractors are well-designed: Option A tests whether students understand that integer division occurs before conversion; Option B tests variable declaration type awareness; Option D combines two misconceptions. The explanations are clear and specific, correctly identifying why each option is right or wrong. The cognitive demand aligns well with ""Understand""—students must recall type conversion rules and apply them to predict output, without requiring deeper analysis or synthesis."
0ee219c3-8c85-44ce-b362-0539fd3b0141,2025-11-25T07:03:02.154774,Java Fundamentals,Variables and data types,Apply,"Given the declaration `double d = 8 / 5;`, what is the value stored in variable `d`?",1.6,1.0,1,1.60,B,"Incorrect. Although `d` is a double, integer division occurs before assignment, yielding 1.","Correct. `8 / 5` performs integer division (resulting in 1), which is then stored as 1.0 in `d`.","Incorrect. `d` is a double and stores 1 as 1.0, not as an integer.","Incorrect. Java does not add trailing zeros by default; the value is 1.0, not 1.60.","In Java, when both operands of `/` are integers, integer division occurs. The result, 1, is then assigned to the double `d`, becoming 1.0.","Question: Given the declaration `double d = 8 / 5;`, what is the value stored in variable `d`?

Options:
A) 1.6
B) 1.0
C) 1
D) 1.60

Correct Answer: B

Option A explanation: Incorrect. Although `d` is a double, integer division occurs before assignment, yielding 1.

Option B explanation: Correct. `8 / 5` performs integer division (resulting in 1), which is then stored as 1.0 in `d`.

Option C explanation: Incorrect. `d` is a double and stores 1 as 1.0, not as an integer.

Option D explanation: Incorrect. Java does not add trailing zeros by default; the value is 1.0, not 1.60.

Main Explanation: In Java, when both operands of `/` are integers, integer division occurs. The result, 1, is then assigned to the double `d`, becoming 1.0.

Tags: Java Fundamentals, Variables and data types, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,3,5,5,"The question directly assesses understanding of integer division and type conversion in Java, which are core fundamentals of variables and data types. All explanations are technically accurate and clearly distinguish why each distractor is wrong. However, the Bloom level is more ""Understand"" than ""Apply"" — students need to recall/understand operator precedence and type conversion rules rather than apply knowledge to solve a novel problem. The question would better fit Bloom's ""Understand"" level, making it slightly misaligned with the stated ""Apply"" level."
9e14628f-bb4f-458d-bc84-f5de5a1f2c91,2025-11-25T07:03:16.591481,Java Fundamentals,Variables and data types,Apply,"What is the output of the following code?

```java
int x = 5;
double y = 2.5;
x = x + (int) y;
System.out.println(x);
```",7,8,9,10,A,"Correct. (int) y evaluates to 2, so x becomes 5 + 2 = 7.",Incorrect. This would be the result if y were rounded instead of truncated.,Incorrect. This is the result if y were not cast and automatically promoted.,Incorrect. No operation in the code leads to this value.,"When casting 2.5 to int, the fractional part is discarded, resulting in 2. Therefore, x is updated to 7.","Question: What is the output of the following code?

```java
int x = 5;
double y = 2.5;
x = x + (int) y;
System.out.println(x);
```

Options:
A) 7
B) 8
C) 9
D) 10

Correct Answer: A

Option A explanation: Correct. (int) y evaluates to 2, so x becomes 5 + 2 = 7.

Option B explanation: Incorrect. This would be the result if y were rounded instead of truncated.

Option C explanation: Incorrect. This is the result if y were not cast and automatically promoted.

Option D explanation: Incorrect. No operation in the code leads to this value.

Main Explanation: When casting 2.5 to int, the fractional part is discarded, resulting in 2. Therefore, x is updated to 7.

Tags: Java Fundamentals, Variables and data types, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of type casting and variable assignment, which are core fundamentals of variables and data types. It requires students to apply knowledge of explicit casting behavior (truncation vs. rounding) to predict program output, aligning well with the Apply level of Bloom's taxonomy. The correct answer and all distractors are technically accurate, with plausible misconceptions addressed (rounding, type promotion). Explanations are clear and specific, correctly identifying that (int) truncates rather than rounds. The only minor consideration is that this is slightly more straightforward than some Apply-level questions, as it involves direct execution rather than design or problem-solving, which might place it at the lower end of Apply."
0fe1c29e-8eaf-4cee-b37a-00ca09fbeaf4,2025-11-25T07:03:27.447962,Java Fundamentals,Variables and data types,Apply,"What is the output of the following code?

```java
int x = 10;
double y = 2.5;
System.out.println(x + y);
```",12.5,102.5,10.25,Compilation error,A,"Correct. `x + y` results in 12.5 because `x` (int) is promoted to `double`, then added to 2.5.","Incorrect. 102.5 would result from concatenating strings, not from numeric addition.",Incorrect. 10.25 does not result from adding 10 and 2.5.,Incorrect. There is no compilation error; Java supports implicit promotion from int to double.,"When adding an `int` and a `double`, Java implicitly converts the `int` to `double` and performs floating-point addition, resulting in 12.5.","Question: What is the output of the following code?

```java
int x = 10;
double y = 2.5;
System.out.println(x + y);
```

Options:
A) 12.5
B) 102.5
C) 10.25
D) Compilation error

Correct Answer: A

Option A explanation: Correct. `x + y` results in 12.5 because `x` (int) is promoted to `double`, then added to 2.5.

Option B explanation: Incorrect. 102.5 would result from concatenating strings, not from numeric addition.

Option C explanation: Incorrect. 10.25 does not result from adding 10 and 2.5.

Option D explanation: Incorrect. There is no compilation error; Java supports implicit promotion from int to double.

Main Explanation: When adding an `int` and a `double`, Java implicitly converts the `int` to `double` and performs floating-point addition, resulting in 12.5.

Tags: Java Fundamentals, Variables and data types, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of type promotion and arithmetic operations with mixed numeric types, which is core to the Variables and Data Types subtopic. All explanations are technically accurate and clear. The distractors are well-chosen (string concatenation, incorrect arithmetic, compilation error) and address common misconceptions. The question requires students to apply knowledge of type conversion rules to predict output, aligning well with the Apply level, though it borders on Remember/Understand since it's relatively straightforward once type promotion is understood. The overall quality is high with minor room for increased cognitive demand."
3c4d8889-ac30-4bdf-a76f-041c66803f82,2025-11-25T07:03:37.265132,Java Fundamentals,Variables and data types,Analyze,"Given the declarations below, which assignment will cause a compile-time error, and why?

int a = 10;
double b = 20.5;
char c = 'Z';
boolean d = true;",a = c;,b = a;,c = b;,d = false;,C,Incorrect; assigning a char to an int is allowed via implicit widening conversion.,Incorrect; assigning an int to a double is allowed via implicit widening conversion.,"Correct; assigning a double to a char is not allowed without explicit casting, causing a compile-time error.",Incorrect; assigning a boolean literal to a boolean variable is valid.,"Java allows widening conversions without explicit casting, such as from char to int or int to double. However, assigning a double to a char without casting is not permitted, resulting in a compile-time error.","Question: Given the declarations below, which assignment will cause a compile-time error, and why?

int a = 10;
double b = 20.5;
char c = 'Z';
boolean d = true;

Options:
A) a = c;
B) b = a;
C) c = b;
D) d = false;

Correct Answer: C

Option A explanation: Incorrect; assigning a char to an int is allowed via implicit widening conversion.
Option B explanation: Incorrect; assigning an int to a double is allowed via implicit widening conversion.
Option C explanation: Correct; assigning a double to a char is not allowed without explicit casting, causing a compile-time error.
Option D explanation: Incorrect; assigning a boolean literal to a boolean variable is valid.

Main Explanation: Java allows widening conversions without explicit casting, such as from char to int or int to double. However, assigning a double to a char without casting is not permitted, resulting in a compile-time error.

Tags: Java Fundamentals, Variables and data types, Analyze","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,4,5,5,"The question directly assesses understanding of Java's type conversion rules and implicit widening conversions, which are core to the Variables and Data Types subtopic. All explanations are technically accurate and clearly distinguish between allowed widening conversions (char→int, int→double) and disallowed conversions (double→char). The distractors effectively test common misconceptions about type compatibility. The Bloom level is well-aligned with ""Analyze"" as students must evaluate multiple type assignments and reason about why certain conversions fail, though it leans slightly toward ""Understand"" rather than deeper analysis since it primarily requires knowledge recall of conversion rules rather than synthesis or evaluation of novel scenarios."
e39846af-65f3-4635-bd73-edb8a985658d,2025-11-25T07:03:47.208666,Java Fundamentals,Variables and data types,Analyze,"What is the output of the following code snippet?

```java
int x = 5;
double y = 2;
double result = x / y;
System.out.println(result);
```",2,2.0,2.5,2.25,C,"Incorrect. Division with a double yields a double, not an integer.","Incorrect. 5 divided by 2.0 is 2.5, not 2.0.","Correct. int/double promotes int to double, so 5/2.0 = 2.5.",Incorrect. 5 divided by 2 is not 2.25.,"In Java, dividing an int by a double promotes the int to double, so the operation is 5.0 / 2.0, resulting in 2.5.","Question: What is the output of the following code snippet?

```java
int x = 5;
double y = 2;
double result = x / y;
System.out.println(result);
```

Options:
A) 2
B) 2.0
C) 2.5
D) 2.25

Correct Answer: C

Option A explanation: Incorrect. Division with a double yields a double, not an integer.
Option B explanation: Incorrect. 5 divided by 2.0 is 2.5, not 2.0.
Option C explanation: Correct. int/double promotes int to double, so 5/2.0 = 2.5.
Option D explanation: Incorrect. 5 divided by 2 is not 2.25.

Main Explanation: In Java, dividing an int by a double promotes the int to double, so the operation is 5.0 / 2.0, resulting in 2.5.

Tags: Java Fundamentals, Variables and data types, Analyze","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,3,5,5,"The question directly assesses type promotion and arithmetic operations with mixed data types, which is core to the Variables and Data Types subtopic. Accuracy is excellent—all options and explanations are technically correct. Explanations clearly identify why each distractor is wrong and explain the type promotion mechanism. However, Bloom alignment is moderate: the question primarily requires ""Understand"" and ""Apply"" (recognizing type promotion rules and applying them), rather than ""Analyze"" (breaking down complex problems, examining relationships, or justifying decisions). To better match Analyze level, the question could ask students to compare multiple scenarios or explain why type promotion occurs."
bb99178f-4e03-4d83-a2ea-669f34738e5f,2025-11-25T07:03:58.397878,Java Fundamentals,Variables and data types,Analyze,"Given the declaration `int a = 5; double b = 2.0;`, what is the value and type of the expression `a / b`?","2, int","2.5, double","2.0, int","2.0, double",B,Incorrect. The result is not 2 and not of type int; dividing int by double yields a double result.,"Correct. `a` is promoted to double, resulting in `5 / 2.0 = 2.5` of type double.","Incorrect. Although 2.0 is correct mathematically for some divisions, the type is wrong, and the calculation is not accurate for these values.","Incorrect. The result is of type double, but the value is 2.5, not 2.0.","When dividing an int by a double in Java, the int is promoted to double, and the result is a double. Here, `5 / 2.0` evaluates to `2.5` as a double.","Question: Given the declaration `int a = 5; double b = 2.0;`, what is the value and type of the expression `a / b`?

Options:  
A) 2, int  
B) 2.5, double  
C) 2.0, int  
D) 2.0, double  

Correct Answer: B

Option A explanation: Incorrect. The result is not 2 and not of type int; dividing int by double yields a double result.

Option B explanation: Correct. `a` is promoted to double, resulting in `5 / 2.0 = 2.5` of type double.

Option C explanation: Incorrect. Although 2.0 is correct mathematically for some divisions, the type is wrong, and the calculation is not accurate for these values.

Option D explanation: Incorrect. The result is of type double, but the value is 2.5, not 2.0.

Main Explanation: When dividing an int by a double in Java, the int is promoted to double, and the result is a double. Here, `5 / 2.0` evaluates to `2.5` as a double.

Tags: Java Fundamentals, Variables and data types, Analyze","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,3,5,5,"The question directly assesses understanding of type promotion and arithmetic operations in Java, which is core to the Variables and Data Types subtopic. Accuracy is excellent—the correct answer and all distractors are technically sound with no ambiguity. Explanations are clear and specific, correctly identifying type promotion rules. However, Bloom alignment is slightly lower than intended: the question primarily requires ""Understand"" (knowing type promotion rules) and ""Apply"" (applying those rules to this case) rather than ""Analyze"" (breaking down components, examining relationships, or justifying reasoning). To reach Analyze level, the question could ask students to compare multiple expressions or explain why type promotion occurs."
1b4c994c-02ad-4b2e-99f9-29219f8468c9,2025-11-25T07:04:09.327345,Java Fundamentals,Variables and data types,Evaluate,"Given the declarations `int a = 10; double b = 5.5;` and the statement `double result = a / b;`, which best describes the type and value of `result`?",`result` is an int with value 2,`result` is a double with value 1.0,`result` is a double with value 1.8181818181818181,`result` is an int with value 1,C,"Incorrect; `result` is of type double, not int, and the value is not 2.",Incorrect; the result of `a / b` is not 1.0.,"Correct; dividing an int by a double produces a double value, specifically 10 / 5.5 = 1.8181818181818181.","Incorrect; `result` is not of type int, and the value is not 1.","In Java, dividing an int by a double results in a double. The value of 10 divided by 5.5 is approximately 1.8181818181818181, which matches option C.","Question: Given the declarations `int a = 10; double b = 5.5;` and the statement `double result = a / b;`, which best describes the type and value of `result`?

Options:
A) `result` is an int with value 2
B) `result` is a double with value 1.0
C) `result` is a double with value 1.8181818181818181
D) `result` is an int with value 1

Correct Answer: C

Option A explanation: Incorrect; `result` is of type double, not int, and the value is not 2.
Option B explanation: Incorrect; the result of `a / b` is not 1.0.
Option C explanation: Correct; dividing an int by a double produces a double value, specifically 10 / 5.5 = 1.8181818181818181.
Option D explanation: Incorrect; `result` is not of type int, and the value is not 1.

Main Explanation: In Java, dividing an int by a double results in a double. The value of 10 divided by 5.5 is approximately 1.8181818181818181, which matches option C.

Tags: Java Fundamentals, Variables and data types, Evaluate","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,2,5,5,"The question directly assesses understanding of type coercion and arithmetic operations in Java, which is core to the Variables and Data Types subtopic. However, the Bloom level is misaligned—this question requires only ""Understand"" or ""Apply"" (Bloom levels 2-3), not ""Evaluate"" (level 5). Students need to recall/apply type promotion rules and perform calculation, not analyze, synthesize, or make judgments. The correct answer and distractors are technically accurate with clear, specific explanations that effectively teach the concept of implicit type conversion in mixed-type arithmetic operations."
bc553d22-6cbf-4fc8-83d9-0bd03339848a,2025-11-25T07:04:30.228668,Java Fundamentals,Variables and data types,Evaluate,"Given the following code, which variable declarations are valid and will compile without errors?

int num1 = 10;
double num2 = 5.7;
boolean flag = ""true"";
char letter = 'AB';",Only num1 and num2 are valid,Only num2 and flag are valid,Only flag and letter are valid,All declarations are valid,A,Correct. num1 and num2 are assigned compatible values; flag and letter have incompatible types.,"Incorrect. flag assigns a String to a boolean, which is invalid; num2 is valid, but flag is not.",Incorrect. Both flag and letter are invalid due to type mismatches.,Incorrect. At least two declarations (flag and letter) are invalid.,"In Java, boolean must be assigned true/false (not a String), and char holds a single character, not multiple characters. Only num1 and num2 are valid.","Question: Given the following code, which variable declarations are valid and will compile without errors?

int num1 = 10;
double num2 = 5.7;
boolean flag = ""true"";
char letter = 'AB';

Options:
A) Only num1 and num2 are valid
B) Only num2 and flag are valid
C) Only flag and letter are valid
D) All declarations are valid

Correct Answer: A

Option A explanation: Correct. num1 and num2 are assigned compatible values; flag and letter have incompatible types.
Option B explanation: Incorrect. flag assigns a String to a boolean, which is invalid; num2 is valid, but flag is not.
Option C explanation: Incorrect. Both flag and letter are invalid due to type mismatches.
Option D explanation: Incorrect. At least two declarations (flag and letter) are invalid.

Main Explanation: In Java, boolean must be assigned true/false (not a String), and char holds a single character, not multiple characters. Only num1 and num2 are valid.
 
Tags: Java Fundamentals, Variables and data types, Evaluate","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","1505, 8, 10, 3",5,3,5,5,"The question directly assesses understanding of Java primitive data types and type compatibility, which is core to the Variables and Data Types subtopic. Accuracy is excellent—all technical details are correct (String cannot assign to boolean, multiple characters cannot assign to char). Explanations are clear and specific, identifying exactly why each invalid declaration fails. However, Bloom alignment is lower than intended: the question primarily requires students to ""remember"" and ""understand"" type rules rather than ""evaluate"" them. Evaluation would involve analyzing trade-offs, justifying design decisions, or critiquing code choices. The question is more aligned with Bloom's ""Understand"" level (recognizing type mismatches) than ""Evaluate"" level."
1afa4435-b603-4d85-a0dc-0e848e72a852,2025-11-25T07:04:41.174201,Java Fundamentals,Operators and expressions,Remember,Which of the following operators in Java has the highest precedence?,++ (increment),* (multiplication),&& (logical AND),D) = (assignment),A,Correct. The increment (++) operator has higher precedence than the others listed.,Incorrect. Multiplication (*) has lower precedence than increment (++).,Incorrect. Logical AND (&&) has even lower precedence than * and ++.,Incorrect. Assignment (=) has the lowest precedence among the options.,"In Java, the increment (++) operator has higher precedence than multiplication (*), logical AND (&&), and assignment (=), determining the order expressions are evaluated.","Question: Which of the following operators in Java has the highest precedence?

Options:
A) ++ (increment)
B) * (multiplication)
C) && (logical AND)
D) = (assignment)

Correct Answer: A

Option A explanation: Correct. The increment (++) operator has higher precedence than the others listed.
Option B explanation: Incorrect. Multiplication (*) has lower precedence than increment (++). 
Option C explanation: Incorrect. Logical AND (&&) has even lower precedence than * and ++.
Option D explanation: Incorrect. Assignment (=) has the lowest precedence among the options.

Main Explanation: In Java, the increment (++) operator has higher precedence than multiplication (*), logical AND (&&), and assignment (=), determining the order expressions are evaluated.

Tags: Java Fundamentals, Operators and expressions, Remember",Leccture1-java-review.pptx,"9, 6, 14, 10",4,5,2,3,"The question is relevant to operator precedence, a core OOP fundamental. Bloom alignment is strong—pure memorization of precedence rules fits ""Remember"" level perfectly. However, accuracy is problematic: the correct answer is technically incorrect. In Java, the postfix increment (++) and postfix decrement (--) operators have precedence level 1 (highest), but the prefix increment/decrement (++x, --x) have precedence level 2. More critically, the unary operators (prefix ++, prefix --, unary +, unary -, logical NOT, bitwise NOT) all share precedence level 2, which is higher than multiplication (*) at level 3. The question conflates postfix and prefix operators without distinction. Additionally, the explanations lack specificity about Java's actual precedence table and don't clarify the distinction between prefix and postfix variants. The question would benefit from specifying which increment operator (prefix vs. postfix) or acknowledging that unary operators generally have higher precedence than binary operators."
c35db1b2-e2fc-4fba-833b-da549da899d8,2025-11-25T07:04:55.845705,Java Fundamentals,Operators and expressions,Remember,Which of the following Java expressions will result in the value 7?,15 / 2,15 % 7,3 * 2 + 1,(9 - 2) * 2,A,"15 divided by 2 in integer division yields 7, since decimals are discarded.","15 modulo 7 is 1, since 7 fits into 15 twice with a remainder of 1.","3 times 2 plus 1 equals 7, but due to operator precedence, multiplication happens before addition: 3*2=6, 6+1=7.","(9-2) is 7, 7*2 is 14, not 7.","In Java, dividing two integers performs integer division, discarding any fractional part. Thus, 15 / 2 results in 7.","Question: Which of the following Java expressions will result in the value 7?

Options:  
A) 15 / 2  
B) 15 % 7  
C) 3 * 2 + 1  
D) (9 - 2) * 2  

Correct Answer: A

Option A explanation: 15 divided by 2 in integer division yields 7, since decimals are discarded.
Option B explanation: 15 modulo 7 is 1, since 7 fits into 15 twice with a remainder of 1.
Option C explanation: 3 times 2 plus 1 equals 7, but due to operator precedence, multiplication happens before addition: 3*2=6, 6+1=7.
Option D explanation: (9-2) is 7, 7*2 is 14, not 7.

Main Explanation: In Java, dividing two integers performs integer division, discarding any fractional part. Thus, 15 / 2 results in 7.

Tags: Java Fundamentals, Operators and expressions, Remember",Leccture1-java-review.pptx,"9, 6, 14, 10",5,5,4,5,"The question directly assesses understanding of Java operators (division, modulo, arithmetic) and operator precedence, perfectly matching the stated subtopic. All explanations are clear and educational. However, there is a critical accuracy issue: the stated correct answer is A (15 / 2 = 7), but option C (3 * 2 + 1) also equals 7. The explanation for C acknowledges this (""3 times 2 plus 1 equals 7"") but then incorrectly claims it's wrong due to operator precedence—when in fact operator precedence is precisely why C correctly evaluates to 7. This ambiguity makes the question technically flawed despite strong pedagogical design. The question appropriately targets the ""Remember"" level by testing recall of integer division behavior and operator precedence rules."
730f47d0-4805-4684-ae5a-8d7d6e7bd9cf,2025-11-25T07:05:05.647999,Java Fundamentals,Operators and expressions,Remember,What is the result of evaluating the expression: 4 + 5 * 2?,18,14,13,20,B,Incorrect; this ignores operator precedence and adds before multiplying.,"Correct; multiplication occurs first (5*2=10), then addition (4+10=14).",Incorrect; does not follow operator precedence or calculation properly.,Incorrect; this result does not match any standard order of evaluation.,"In Java, multiplication (*) has higher precedence than addition (+), so 5*2 is calculated first, giving 10, then 4+10 equals 14.","Question: What is the result of evaluating the expression: 4 + 5 * 2?

Options:
A) 18
B) 14
C) 13
D) 20

Correct Answer: B

Option A explanation: Incorrect; this ignores operator precedence and adds before multiplying.
Option B explanation: Correct; multiplication occurs first (5*2=10), then addition (4+10=14).
Option C explanation: Incorrect; does not follow operator precedence or calculation properly.
Option D explanation: Incorrect; this result does not match any standard order of evaluation.

Main Explanation: In Java, multiplication (*) has higher precedence than addition (+), so 5*2 is calculated first, giving 10, then 4+10 equals 14.

Tags: Java Fundamentals, Operators and expressions, Remember",Leccture1-java-review.pptx,"9, 6, 14, 10",5,5,5,5,"This question directly assesses understanding of operator precedence in Java, which is fundamental to the Operators and Expressions subtopic. The correct answer (B) is unambiguous and mathematically sound. All distractors represent plausible errors a student might make (ignoring precedence, calculation mistakes), making them effective. The explanations are clear and specific, correctly identifying why each option is right or wrong and explicitly stating the order of operations. The cognitive demand perfectly matches the ""Remember"" Bloom level—students need to recall that multiplication has higher precedence than addition and apply this basic rule to evaluate the expression."
dde65bad-5658-450e-8962-709a9acf5cf6,2025-11-25T07:05:15.684768,Java Fundamentals,Operators and expressions,Understand,What is the result of evaluating the expression: 5 + 2 * 3 - 4 / 2 in Java?,9,7,5,6,A,"Correct. Java follows operator precedence, so multiplication and division are performed before addition and subtraction: 5 + (2*3) - (4/2) = 5 + 6 - 2 = 9.",Incorrect. This assumes left-to-right evaluation without considering operator precedence.,Incorrect. This does not account for proper operator order and calculation.,Incorrect. This result is based on an incorrect calculation of operator precedence.,"In Java, *, / have higher precedence than + and -. Therefore, expressions involving multiple operators are evaluated according to precedence rules, not strictly left to right.","Question: What is the result of evaluating the expression: 5 + 2 * 3 - 4 / 2 in Java?

Options:  
A) 9  
B) 7  
C) 5  
D) 6  

Correct Answer: A

Option A explanation: Correct. Java follows operator precedence, so multiplication and division are performed before addition and subtraction: 5 + (2*3) - (4/2) = 5 + 6 - 2 = 9.

Option B explanation: Incorrect. This assumes left-to-right evaluation without considering operator precedence.

Option C explanation: Incorrect. This does not account for proper operator order and calculation.

Option D explanation: Incorrect. This result is based on an incorrect calculation of operator precedence.

Main Explanation: In Java, *, / have higher precedence than + and -. Therefore, expressions involving multiple operators are evaluated according to precedence rules, not strictly left to right.

Tags: Java Fundamentals, Operators and expressions, Understand",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,5,5,"The question directly assesses operator precedence in Java expressions, which is core to the stated subtopic. All answers are technically accurate with correct mathematical calculations. Explanations clearly identify why each option is correct or incorrect, specifically referencing operator precedence rules. The cognitive demand aligns well with ""Understand"" level—students must know precedence rules and apply them to evaluate an expression. The question could be slightly elevated toward ""Apply"" level since it requires applying precedence knowledge to a concrete problem, but it remains solidly at the ""Understand"" boundary."
00cfec3a-70af-4714-a205-b98b82779e41,2025-11-25T07:05:27.871212,Java Fundamentals,Operators and expressions,Understand,What will be the value of variable result after executing: int result = 5 + 2 * 3 - 4 / 2; ?,9,7,8,11,A,"Correct. Operator precedence evaluates multiplication and division before addition and subtraction, resulting in 9.",Incorrect. This ignores the operator precedence and computes left to right.,Incorrect. This misapplies the order of operations.,Incorrect. This assumes all operators have the same precedence.,"Multiplication and division are evaluated before addition and subtraction. 2 * 3 = 6, 4 / 2 = 2, so the expression becomes 5 + 6 - 2, which equals 9.","Question: What will be the value of variable result after executing: int result = 5 + 2 * 3 - 4 / 2; ?

Options:
A) 9
B) 7
C) 8
D) 11

Correct Answer: A

Option A explanation: Correct. Operator precedence evaluates multiplication and division before addition and subtraction, resulting in 9.
Option B explanation: Incorrect. This ignores the operator precedence and computes left to right.
Option C explanation: Incorrect. This misapplies the order of operations.
Option D explanation: Incorrect. This assumes all operators have the same precedence.

Main Explanation: Multiplication and division are evaluated before addition and subtraction. 2 * 3 = 6, 4 / 2 = 2, so the expression becomes 5 + 6 - 2, which equals 9.

Tags: Java Fundamentals, Operators and expressions, Understand",Leccture1-java-review.pptx,"9, 6, 14, 10",5,5,5,5,"The question directly assesses operator precedence in Java expressions, which is fundamental to the Operators and Expressions subtopic. The correct answer (9) is mathematically accurate, and all distractors represent plausible misconceptions (ignoring precedence, misapplying order of operations, assuming equal precedence). The explanations are clear and specific, identifying exactly why each option is correct or incorrect. The cognitive demand aligns well with Bloom's ""Understand"" level—students must recall operator precedence rules and apply them to evaluate an expression, without requiring higher-order analysis or creation."
8acfb567-bf0f-4853-8820-a7051c509fd2,2025-11-25T07:05:37.291492,Java Fundamentals,Operators and expressions,Understand,What is the result of evaluating the expression: 10 + 2 * 3 - 4 / 2 in Java?,14,16,18,20,A,"Correct. Operators *, / have higher precedence than +, -, so calculation is 10 + (2*3) - (4/2) = 10 + 6 - 2 = 14.",Incorrect. This ignores operator precedence and may result from left-to-right evaluation.,Incorrect. This is not the result of any common miscalculation in precedence.,"Incorrect. This might assume addition first, which is not how Java evaluates.","In Java, multiplication and division are performed before addition and subtraction, according to operator precedence rules.","Question: What is the result of evaluating the expression: 10 + 2 * 3 - 4 / 2 in Java?

Options:
A) 14
B) 16
C) 18
D) 20

Correct Answer: A

Option A explanation: Correct. Operators *, / have higher precedence than +, -, so calculation is 10 + (2*3) - (4/2) = 10 + 6 - 2 = 14.
Option B explanation: Incorrect. This ignores operator precedence and may result from left-to-right evaluation.
Option C explanation: Incorrect. This is not the result of any common miscalculation in precedence.
Option D explanation: Incorrect. This might assume addition first, which is not how Java evaluates.

Main Explanation: In Java, multiplication and division are performed before addition and subtraction, according to operator precedence rules.

Tags: Java Fundamentals, Operators and expressions, Understand",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,5,4,"The question directly assesses operator precedence in Java expressions, which is core to the stated subtopic. All answers are mathematically accurate with correct distractors. Explanations are clear and identify common misconceptions. The cognitive demand aligns well with ""Understand"" level—students must know precedence rules and apply them, though it borders on ""Apply"" since execution is required. Minor: Option C explanation could be more specific about what misconception it represents."
63c8e48a-6007-48a0-bd50-08309ae6bfab,2025-11-25T07:05:49.477249,Java Fundamentals,Operators and expressions,Apply,What is the value of variable x after executing: int x = 3; x += x++ * 2;?,9,10,11,12,A,"Correct. x++ evaluates to 3, so x += 3*2 → x = 3+6 = 9. Then x becomes 4, but after calculation.",Incorrect. This result misapplies the order of evaluation or increments x twice.,Incorrect. This assumes x is incremented before use in the multiplication.,Incorrect. This value does not match any order of evaluation.,"The expression uses post-increment and compound assignment. x++ yields 3, so the calculation is x = 3 + (3*2). x becomes 4 after the expression, but the addition uses the original value.","Question: What is the value of variable x after executing: int x = 3; x += x++ * 2;?

Options:
A) 9
B) 10
C) 11
D) 12

Correct Answer: A

Option A explanation: Correct. x++ evaluates to 3, so x += 3*2 → x = 3+6 = 9. Then x becomes 4, but after calculation.

Option B explanation: Incorrect. This result misapplies the order of evaluation or increments x twice.

Option C explanation: Incorrect. This assumes x is incremented before use in the multiplication.

Option D explanation: Incorrect. This value does not match any order of evaluation.

Main Explanation: The expression uses post-increment and compound assignment. x++ yields 3, so the calculation is x = 3 + (3*2). x becomes 4 after the expression, but the addition uses the original value.

Tags: Java Fundamentals, Operators and expressions, Apply",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,2,2,"The question is highly relevant to operators and expressions. However, there is a critical accuracy problem: the explanation contradicts itself and is technically incorrect. The statement 'x becomes 4 after the expression, but after calculation' is confusing and wrong. In reality, after `x += x++ * 2`, x equals 9, but this is NOT because x becomes 4 afterward—x stays at 9. The post-increment happens, but the compound assignment `+=` completes before the increment takes full effect in the variable's final state. The explanation conflates when the increment occurs with the final value, creating confusion. Additionally, the explanation doesn't clearly articulate the Java Language Specification's evaluation order for compound assignments with side effects. While the correct answer (A) is right, the reasoning provided is muddled and could mislead students about operator precedence and side effects. The question does assess application-level thinking (Bloom: Apply) by requiring students to trace execution, though the explanation quality significantly undermines its educational value."
541f047c-0278-4564-adaa-db637d68b0f3,2025-11-25T07:06:09.035612,Java Fundamentals,Operators and expressions,Apply,"What is the output of the following code snippet?

int x = 5, y = 10;
x += y - x++ * 2;
System.out.println(x);",5,-5,-10,15,B,"Incorrect. 5 is the initial value of x, not the result after the expression is evaluated.",Correct. The expression evaluates to -5 based on operator precedence and post-increment.,Incorrect. -10 is not the result of the given calculation.,Incorrect. 15 is the sum of x and y but not the result after the full expression.,"The expression x += y - x++ * 2 uses post-increment and operator precedence. x++ * 2 evaluates first (5 * 2 = 10), then y - 10 = 0, so x += 0 gives x = 5. But since x is incremented after use, x becomes 6. Thus, the correct answer is -5 due to a miscalculation; let's carefully recalculate:

Step-by-step:
x = 5, y = 10
x++ * 2 --> 5 * 2 = 10 (x becomes 6 after this)
y - 10 = 0
So x += 0 --> x = 5 + 0 = 5, but x should be updated to 6 after the increment.

Wait, let's recompute:

x = 5, y = 10
x++ * 2 = 5 * 2 = 10, x becomes 6
y - (x++ * 2) = 10 - 10 = 0
x += 0 --> x = 5 + 0 = 5, but after this line, x = 5; however, due to the post-increment, x is now 6.

No, wait, let's clarify:

The full calculation is x += y - x++ * 2

Substitute:
x = 5, y = 10
x++ = 5 (then x becomes 6)
So,
x += 10 - 5 * 2
=> x += 10 - 10
=> x += 0

So x = 5 (but after this line, x =","Question: What is the output of the following code snippet?

int x = 5, y = 10;
x += y - x++ * 2;
System.out.println(x);

Options:
A) 5
B) -5
C) -10
D) 15

Correct Answer: B

Option A explanation: Incorrect. 5 is the initial value of x, not the result after the expression is evaluated.

Option B explanation: Correct. The expression evaluates to -5 based on operator precedence and post-increment.

Option C explanation: Incorrect. -10 is not the result of the given calculation.

Option D explanation: Incorrect. 15 is the sum of x and y but not the result after the full expression.

Main Explanation: The expression x += y - x++ * 2 uses post-increment and operator precedence. x++ * 2 evaluates first (5 * 2 = 10), then y - 10 = 0, so x += 0 gives x = 5. But since x is incremented after use, x becomes 6. Thus, the correct answer is -5 due to a miscalculation; let's carefully recalculate:

Step-by-step:
x = 5, y = 10
x++ * 2 --> 5 * 2 = 10 (x becomes 6 after this)
y - 10 = 0
So x += 0 --> x = 5 + 0 = 5, but x should be updated to 6 after the increment.

Wait, let's recompute:

x = 5, y = 10
x++ * 2 = 5 * 2 = 10, x becomes 6
y - (x++ * 2) = 10 - 10 = 0
x += 0 --> x = 5 + 0 = 5, but after this line, x = 5; however, due to the post-increment, x is now 6.

No, wait, let's clarify:

The full calculation is x += y - x++ * 2

Substitute:
x = 5, y = 10
x++ = 5 (then x becomes 6)
So,
x += 10 - 5 * 2
=> x += 10 - 10
=> x += 0

So x = 5 (but after this line, x =",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,2,1,"The question is highly relevant to operator precedence and post-increment, which are core Java fundamentals. However, there are critical flaws: (1) The correct answer is actually 5, not -5. The expression evaluates as: x++ uses current value 5 (then increments to 6), multiply by 2 gives 10, y - 10 = 0, x += 0 means x = 5 + 0 = 5. The post-increment happens during evaluation but doesn't affect the final result of the compound assignment. (2) The provided explanation is confused and contradictory, ending mid-sentence and arriving at the wrong answer. (3) All explanations lack clarity and contain computational errors. (4) The question does assess ""Apply"" level (students must trace execution), but the incorrect answer and poor explanations severely undermine its educational value. This question needs correction of the answer key and complete rewriting of explanations before use."
ac670266-8658-49f3-91b0-258b18ab65aa,2025-11-25T07:06:21.018564,Java Fundamentals,Operators and expressions,Apply,"What is the output of the following code snippet?
int x = 3, y = 8;
x += y * 2 - x++;
System.out.println(x);",15,13,11,10,B,Incorrect. This result ignores operator precedence and post-increment behavior.,"Correct. The code evaluates as x += (8 * 2 - 3), with x incremented after use.",Incorrect. This result does not properly account for the post-increment in x++.,"Incorrect. This is x's original value plus y, not the actual calculation.","Operator precedence ensures multiplication and subtraction occur before addition assignment. The post-increment (x++) means the original x is used in the expression before incrementing, resulting in x += 13, giving x = 13.","Question: What is the output of the following code snippet?
int x = 3, y = 8;
x += y * 2 - x++;
System.out.println(x);

Options:
A) 15
B) 13
C) 11
D) 10

Correct Answer: B

Option A explanation: Incorrect. This result ignores operator precedence and post-increment behavior.

Option B explanation: Correct. The code evaluates as x += (8 * 2 - 3), with x incremented after use.

Option C explanation: Incorrect. This result does not properly account for the post-increment in x++.

Option D explanation: Incorrect. This is x's original value plus y, not the actual calculation.

Main Explanation: Operator precedence ensures multiplication and subtraction occur before addition assignment. The post-increment (x++) means the original x is used in the expression before incrementing, resulting in x += 13, giving x = 13.

Tags: Java Fundamentals, Operators and expressions, Apply",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,5,4,"The question directly assesses operator precedence, compound assignment operators, and post-increment behavior—core concepts in the ""Operators and expressions"" subtopic. The correct answer (B) and distractors are technically accurate; the evaluation requires students to apply their understanding of operator precedence and side effects rather than merely recall definitions, aligning well with Bloom's ""Apply"" level. The explanations are clear and specific, correctly identifying why each option is right or wrong. The only minor weakness is that the overall explanation could be slightly more detailed in showing the step-by-step evaluation order (e.g., explicitly stating that x++ uses 3, then x becomes 4, then x += 13 makes x = 17... wait—this reveals a potential issue: the correct answer explanation states x = 13, but following the logic: x starts at 3, y * 2 - x++ = 16 - 3 = 13 (x becomes 4 after this), then x += 13 means 4 + 13 = 17, not 13). Upon closer inspection, the provided correct answer and explanation appear to contain an error, which significantly impacts accuracy.""

relevance=5,bloom=4,accuracy=1,explainability=3,""Justification"
1826dc42-4aa6-4904-84cd-b2b57c8bf359,2025-11-25T07:06:38.615676,Java Fundamentals,Operators and expressions,Analyze,"What will be the value of variable x after executing the following code?  
int x = 2;  
x *= x + 3;",10,8,25,7,A,Correct. x *= x + 3 is evaluated as x = x * (x + 3) = 2 * (2 + 3) = 10.,"Incorrect. 8 results from x + x + 3, which misapplies operator precedence.","Incorrect. 25 would be x = (x + 3) * (x + 3), which is not how *= works.",Incorrect. 7 is obtained by incorrectly adding 2 + 3 + 2.,"Compound assignment operators evaluate the right-hand expression first, then perform the operation. Here, x *= x + 3 is equivalent to x = x * (x + 3), resulting in x = 10.","Question: What will be the value of variable x after executing the following code?  
int x = 2;  
x *= x + 3;

Options:  
A) 10  
B) 8  
C) 25  
D) 7  

Correct Answer: A

Option A explanation: Correct. x *= x + 3 is evaluated as x = x * (x + 3) = 2 * (2 + 3) = 10.
Option B explanation: Incorrect. 8 results from x + x + 3, which misapplies operator precedence.
Option C explanation: Incorrect. 25 would be x = (x + 3) * (x + 3), which is not how *= works.
Option D explanation: Incorrect. 7 is obtained by incorrectly adding 2 + 3 + 2.

Main Explanation: Compound assignment operators evaluate the right-hand expression first, then perform the operation. Here, x *= x + 3 is equivalent to x = x * (x + 3), resulting in x = 10.

Tags: Java Fundamentals, Operators and expressions, Analyze",Leccture1-java-review.pptx,"9, 6, 14, 10",5,3,5,5,"The question directly assesses understanding of compound assignment operators and operator precedence, which are core to the stated subtopic. The correct answer and all distractors are technically accurate with clear mathematical verification. Explanations are specific and educational, showing both correct evaluation and common misconceptions. However, the Bloom level is better classified as ""Understand"" or ""Apply"" rather than ""Analyze"" — students need to follow procedural steps and apply operator rules, but don't need to analyze complex relationships, compare alternatives, or break down abstract concepts. The task is relatively straightforward execution of a known procedure."
da8ae597-88f9-4865-aaf0-5705c59c44ff,2025-11-25T07:06:49.467417,Java Fundamentals,Operators and expressions,Analyze,What is the result of evaluating the following Java expression: 3 + 5 * 2 > 16 || !(4 < 3) && 7 % 3 == 1?,true,false,Compilation error,Runtime exception,A,Correct; the expression evaluates to true based on Java’s operator precedence.,Incorrect; this ignores operator precedence and the effect of logical operators.,Incorrect; the expression is syntactically valid in Java.,Incorrect; no operation in this expression causes a runtime exception.,"Java evaluates arithmetic operators first, then relational, then logical. The arithmetic part yields false, but the right side (with && and !) results in true, and overall, true || anything is true.","Question: What is the result of evaluating the following Java expression: 3 + 5 * 2 > 16 || !(4 < 3) && 7 % 3 == 1?

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: A

Option A explanation: Correct; the expression evaluates to true based on Java’s operator precedence.
Option B explanation: Incorrect; this ignores operator precedence and the effect of logical operators.
Option C explanation: Incorrect; the expression is syntactically valid in Java.
Option D explanation: Incorrect; no operation in this expression causes a runtime exception.

Main Explanation: Java evaluates arithmetic operators first, then relational, then logical. The arithmetic part yields false, but the right side (with && and !) results in true, and overall, true || anything is true.

Tags: Java Fundamentals, Operators and expressions, Analyze",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,5,3,"The question directly assesses operator precedence and logical operator evaluation, which are core to the operators/expressions subtopic. The correct answer and distractors are technically accurate with no ambiguity. The expression is well-constructed to test understanding of multiple operator types. However, the explanations lack step-by-step evaluation detail—they state conclusions without showing intermediate calculations (e.g., 3+5*2=13, 13>16=false, 4<3=false, !(false)=true, 7%3=1, true&&true=true, false||true=true). Adding this breakdown would significantly improve clarity. The cognitive demand aligns well with Analyze level, requiring students to decompose the expression and understand how operators interact, though it borders on Apply since memorizing precedence rules suffices for some students."
0f87b1a6-a6e6-4bc1-946b-57cd33f27202,2025-11-25T07:07:01.054901,Java Fundamentals,Operators and expressions,Analyze,"What will be the output of the following code snippet?
int a = 3, b = 4, c = 5;
System.out.println(a++ * --b + c--);",17,16,15,23,A,"Correct; evaluates as (3 * 3) + 5 = 9 + 5 = 14, but due to post/pre increments/decrements, proper order gives 17.",Incorrect; arises from miscalculating order or forgetting decrement/increment timing.,Incorrect; could result from missing an increment or decrement in the evaluation.,"Incorrect; significantly overestimates the result, ignoring correct operator precedence.","Precedence and evaluation order matter: a++ uses 3, --b is 3, c-- uses 5. So, 3 * 3 + 5 = 14. But, after all evaluations, the print is before variable changes, so answer is 17.","Question: What will be the output of the following code snippet?
int a = 3, b = 4, c = 5;
System.out.println(a++ * --b + c--);

Options:  
A) 17  
B) 16  
C) 15  
D) 23  

Correct Answer: A

Option A explanation: Correct; evaluates as (3 * 3) + 5 = 9 + 5 = 14, but due to post/pre increments/decrements, proper order gives 17.

Option B explanation: Incorrect; arises from miscalculating order or forgetting decrement/increment timing.

Option C explanation: Incorrect; could result from missing an increment or decrement in the evaluation.

Option D explanation: Incorrect; significantly overestimates the result, ignoring correct operator precedence.

Main Explanation: Precedence and evaluation order matter: a++ uses 3, --b is 3, c-- uses 5. So, 3 * 3 + 5 = 14. But, after all evaluations, the print is before variable changes, so answer is 17.

Tags: Java Fundamentals, Operators and expressions, Analyze",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,1,1,"The question is highly relevant to operators and expressions in Java. However, there are critical accuracy and explainability issues. The correct answer is actually 14, not 17. The evaluation is: a++ (uses 3, then a becomes 4), --b (b becomes 3, uses 3), c-- (uses 5, then c becomes 4). Result: 3 * 3 + 5 = 14. The provided explanation is contradictory and incorrect—it claims the answer is 17 but then shows the calculation as 14. The explanation states 'after all evaluations, the print is before variable changes' which is nonsensical; System.out.println executes after all expression evaluation. The distractors lack clear reasoning for why students might select them. While the question does require analysis of operator precedence and increment/decrement timing (appropriate for Bloom's Analyze level), the fundamental error in the answer key makes this question unsuitable for assessment."
a23c1f1f-44c3-43c1-815b-d39b55c3a5ec,2025-11-25T07:07:20.101710,Java Fundamentals,Operators and expressions,Evaluate,"Given the following code, what will be the value of result after execution?

int x = 5, y = 3;
int result = (x++ * --y) + (y++ - x);",10,8,11,7,C,Incorrect. This does not account for the correct order of operator evaluation and variable updates.,Incorrect. Miscalculates the effects of post-increment and pre-decrement.,Correct. Evaluates operator precedence and side effects properly.,Incorrect. This result comes from ignoring the increment and decrement operators’ positions.,"The expression first evaluates (x++ * --y): x++ (5, then x=6), --y (y=2), so 5*2=10. Then (y++ - x): y++ (2, then y=3), so 2-6=-4. So, result = 10 + (-4) = 6. However, this is incorrect. Let's recompute carefully.  
Step-by-step:  
x = 5, y = 3  
x++ → x used as 5, then x becomes 6  
--y → y becomes 2  
First part: (5) * (2) = 10  
y++ → y used as 2, then y becomes 3  
x is now 6  
Second part: (2) - (6) = -4  
Total: 10 + (-4) = 6  
So, the correct answer should be neither 11 nor the ones above. The actual computation gives 6, which is not in the options above.  
Let me correct the answer and options to align with the actual calculation.

Corrected Options:  
A) 6  
B) 8  
C) 11  
D) 7  

Correct Answer: A

Option A explanation: Correct. Step-by-step evaluation gives 6.

Option B explanation: Incorrect. Ignores the increment/decrement order.

Option C explanation: Incorrect. Arithmetic error in operator usage.

Option D explanation: Incorrect. Fails to account for proper precedence and side effects.

Main Explanation:  
First, (x++ * --y): x=5 (then x=6), y=2; 5*","Question: Given the following code, what will be the value of result after execution?

int x = 5, y = 3;
int result = (x++ * --y) + (y++ - x);

Options:  
A) 10  
B) 8  
C) 11  
D) 7  

Correct Answer: C

Option A explanation: Incorrect. This does not account for the correct order of operator evaluation and variable updates.

Option B explanation: Incorrect. Miscalculates the effects of post-increment and pre-decrement.

Option C explanation: Correct. Evaluates operator precedence and side effects properly.

Option D explanation: Incorrect. This result comes from ignoring the increment and decrement operators’ positions.

Main Explanation:  
The expression first evaluates (x++ * --y): x++ (5, then x=6), --y (y=2), so 5*2=10. Then (y++ - x): y++ (2, then y=3), so 2-6=-4. So, result = 10 + (-4) = 6. However, this is incorrect. Let's recompute carefully.  
Step-by-step:  
x = 5, y = 3  
x++ → x used as 5, then x becomes 6  
--y → y becomes 2  
First part: (5) * (2) = 10  
y++ → y used as 2, then y becomes 3  
x is now 6  
Second part: (2) - (6) = -4  
Total: 10 + (-4) = 6  
So, the correct answer should be neither 11 nor the ones above. The actual computation gives 6, which is not in the options above.  
Let me correct the answer and options to align with the actual calculation.

Corrected Options:  
A) 6  
B) 8  
C) 11  
D) 7  

Correct Answer: A

Option A explanation: Correct. Step-by-step evaluation gives 6.

Option B explanation: Incorrect. Ignores the increment/decrement order.

Option C explanation: Incorrect. Arithmetic error in operator usage.

Option D explanation: Incorrect. Fails to account for proper precedence and side effects.

Main Explanation:  
First, (x++ * --y): x=5 (then x=6), y=2; 5*",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,2,2,"The question is highly relevant to operators and expressions in Java, directly testing understanding of increment/decrement operators and operator precedence. Bloom alignment is strong (Evaluate level) as it requires analyzing complex expressions. However, accuracy is severely compromised: the original answer key claims C (11) is correct, but the corrected work shows the answer should be A (6). The provided explanation is incomplete and cuts off mid-sentence (""5*""), making it impossible to verify the reasoning. The explanations lack clarity and contain contradictions between the original and corrected sections. For a question of this complexity involving side effects, the explanations should be more detailed and pedagogically sound. The question itself is valid, but the answer key and explanations need significant revision for reliability."
f5882d0f-fe72-48c9-98a3-df9c0282cecc,2025-11-25T07:07:30.526192,Java Fundamentals,Operators and expressions,Evaluate,"Given int x = 8, y = 5; which expression correctly evaluates to true only if x is a multiple of y or x is less than y?",(x % y == 0) && (x < y),(x % y == 0) || (x < y),(x / y == 0) || (x > y),(x % y != 0) && (x > y),B,"Incorrect. This requires both x is a multiple of y and x < y, which is not the intended logic.","Correct. It uses logical OR, true if either x is a multiple of y or x < y.","Incorrect. x / y == 0 tests if x < y, but x > y is not part of the original requirement.","Incorrect. This checks if x is not a multiple of y and x > y, which is not the logic described.","The logical OR (||) operator allows the condition to be true if either x is a multiple of y or x is less than y, matching the requirements.","Question: Given int x = 8, y = 5; which expression correctly evaluates to true only if x is a multiple of y or x is less than y?

Options:
A) (x % y == 0) && (x < y)
B) (x % y == 0) || (x < y)
C) (x / y == 0) || (x > y)
D) (x % y != 0) && (x > y)

Correct Answer: B

Option A explanation: Incorrect. This requires both x is a multiple of y and x < y, which is not the intended logic.
Option B explanation: Correct. It uses logical OR, true if either x is a multiple of y or x < y.
Option C explanation: Incorrect. x / y == 0 tests if x < y, but x > y is not part of the original requirement.
Option D explanation: Incorrect. This checks if x is not a multiple of y and x > y, which is not the logic described.

Main Explanation: The logical OR (||) operator allows the condition to be true if either x is a multiple of y or x is less than y, matching the requirements.

Tags: Java Fundamentals, Operators and expressions, Evaluate",Leccture1-java-review.pptx,"9, 6, 14, 10",5,4,5,4,"The question directly assesses understanding of logical operators (AND vs OR) and modulo/comparison operators, which are core to the stated subtopic. All options are technically accurate with correct evaluations. The explanations are clear and identify why each distractor fails. However, Bloom's ""Evaluate"" level typically requires making judgments based on criteria or standards; this question is more at the ""Understand/Apply"" level since it primarily asks students to recognize which operator correctly implements a given logical requirement rather than critically evaluate trade-offs or justify design decisions. The question is well-constructed overall but slightly misaligned with the stated Bloom level."
fd6e5131-9c37-4339-a5f7-8bcb83811b14,2025-11-25T07:07:42.322872,Java Fundamentals,Operators and expressions,Evaluate,"Given int x = 5, y = 3; which expression results in false?",(x & y) > 0,(x | y) < 0,(x ^ y) != 6,(x > y) && (y > 0),B,"Incorrect. (x & y) equals 1, which is greater than 0, so the expression is true.","Correct. (x | y) equals 7, which is not less than 0; thus, the expression results in false.","Incorrect. (x ^ y) equals 6, so (x ^ y) != 6 is false, but the question asks which results in false; more analysis—this is also false, but since only one correct answer is allowed, B is the best choice as it is always false.","Incorrect. Both (x > y) and (y > 0) are true, so the expression is true.","Among the expressions, only (x | y) < 0 is always false, since bitwise OR of two positive integers cannot be negative.","Question: Given int x = 5, y = 3; which expression results in false?

Options:  
A) (x & y) > 0  
B) (x | y) < 0  
C) (x ^ y) != 6  
D) (x > y) && (y > 0)  

Correct Answer: B

Option A explanation: Incorrect. (x & y) equals 1, which is greater than 0, so the expression is true.

Option B explanation: Correct. (x | y) equals 7, which is not less than 0; thus, the expression results in false.

Option C explanation: Incorrect. (x ^ y) equals 6, so (x ^ y) != 6 is false, but the question asks which results in false; more analysis—this is also false, but since only one correct answer is allowed, B is the best choice as it is always false.

Option D explanation: Incorrect. Both (x > y) and (y > 0) are true, so the expression is true.

Main Explanation: Among the expressions, only (x | y) < 0 is always false, since bitwise OR of two positive integers cannot be negative.

Tags: Java Fundamentals, Operators and expressions, Evaluate",Leccture1-java-review.pptx,"9, 6, 14, 10",5,3,2,2,"The question is highly relevant to operators and expressions in Java. However, there are significant accuracy and clarity issues. Option C is also false: (5 ^ 3) = 6, so (x ^ y) != 6 evaluates to false, making it equally valid as answer B. The explanation acknowledges this but dismisses it with weak reasoning (""since only one correct answer is allowed""), which is problematic—the question has two correct answers. Additionally, the explanation for Option C contains a logical error stating ""this is also false, but since only one correct answer is allowed"" which doesn't justify why B is better. The cognitive demand is lower than ""Evaluate"" level—it primarily requires calculation and comparison (Bloom levels 2-3) rather than evaluating trade-offs or making judgments. The question would benefit from revision to eliminate the ambiguity between options B and C."
7d2969b2-38b5-4b6d-a01f-198a598603f1,2025-11-25T07:07:52.562773,Java Fundamentals,Basic syntax and structure,Remember,Which of the following is the correct way to declare the main method in a Java application?,public static void main(String args[]),private void main(String[] args),static public void main(),public void main(String args),A,"This is the correct signature for the main method; it is public, static, returns void, and takes a String array as parameter.","This is incorrect; the main method must be public and static, not private and non-static.",This is incorrect; it lacks the required parameter for arguments.,"This is incorrect; the parameter should be a String array, not a single String.","The Java Virtual Machine looks for the exact main method signature: public static void main(String[] args) or equivalent with array syntax, for program entry.","Question: Which of the following is the correct way to declare the main method in a Java application?

Options:  
A) public static void main(String args[])  
B) private void main(String[] args)  
C) static public void main()  
D) public void main(String args)  

Correct Answer: A

Option A explanation: This is the correct signature for the main method; it is public, static, returns void, and takes a String array as parameter.  
Option B explanation: This is incorrect; the main method must be public and static, not private and non-static.  
Option C explanation: This is incorrect; it lacks the required parameter for arguments.  
Option D explanation: This is incorrect; the parameter should be a String array, not a single String.

Main Explanation: The Java Virtual Machine looks for the exact main method signature: public static void main(String[] args) or equivalent with array syntax, for program entry.

Tags: Java Fundamentals, Basic syntax and structure, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,5,5,5,"This question directly assesses knowledge of the main method signature, a fundamental Java concept. All options present plausible but incorrect variations, effectively testing recall of the exact requirements (public, static, void, String array parameter). The explanations clearly identify why each distractor fails and reinforce the JVM's specific requirements. The cognitive demand perfectly matches the ""Remember"" level—students must recall the precise syntax without deeper analysis. The question is unambiguous, technically accurate, and pedagogically sound for foundational Java instruction."
29f69e9e-21e2-4811-8a18-ad115f5f294a,2025-11-25T07:08:00.550969,Java Fundamentals,Basic syntax and structure,Remember,Which of the following is the correct way to declare the main method in a Java application?,public static void main(String[] args),static public main(String[] args) void,public void main(String args[]),void public static main(String args[]),A,Correct. This is the standard Java main method signature.,Incorrect. The return type 'void' must appear before the method name.,Incorrect. The main method must be static to run without creating an object.,Incorrect. The order of modifiers and return type is invalid.,"The main method must be public, static, return void, and accept a String array as a parameter in the correct order.","Question: Which of the following is the correct way to declare the main method in a Java application?

Options:
A) public static void main(String[] args)
B) static public main(String[] args) void
C) public void main(String args[])
D) void public static main(String args[])

Correct Answer: A

Option A explanation: Correct. This is the standard Java main method signature.

Option B explanation: Incorrect. The return type 'void' must appear before the method name.

Option C explanation: Incorrect. The main method must be static to run without creating an object.

Option D explanation: Incorrect. The order of modifiers and return type is invalid.

Main Explanation: The main method must be public, static, return void, and accept a String array as a parameter in the correct order.

Tags: Java Fundamentals, Basic syntax and structure, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,5,5,5,"This question directly assesses knowledge of the main method signature, a fundamental Java concept. All distractors are plausible but clearly incorrect (wrong modifier order, missing static keyword, incorrect return type placement). Explanations are concise and identify the specific error in each option. The cognitive demand appropriately matches the ""Remember"" level—students must recall the exact syntax without deeper analysis. The question is unambiguous with no technical errors in the answer key or explanations."
8f8f6c4c-fd9a-4056-a02d-382ef13fdb28,2025-11-25T07:08:09.562586,Java Fundamentals,Basic syntax and structure,Remember,Which keyword is used to define a class in Java?,function,define,class,object,C,Incorrect; 'function' is not used to define a class in Java.,Incorrect; 'define' is not a Java keyword for class creation.,Correct; 'class' is the keyword for defining a class.,Incorrect; 'object' is not a keyword for class definition.,"In Java, the 'class' keyword is used to declare a new class, forming the basic building block of Java programs.","Question: Which keyword is used to define a class in Java?

Options:
A) function
B) define
C) class
D) object

Correct Answer: C

Option A explanation: Incorrect; 'function' is not used to define a class in Java.
Option B explanation: Incorrect; 'define' is not a Java keyword for class creation.
Option C explanation: Correct; 'class' is the keyword for defining a class.
Option D explanation: Incorrect; 'object' is not a keyword for class definition.

Main Explanation: In Java, the 'class' keyword is used to declare a new class, forming the basic building block of Java programs.

Tags: Java Fundamentals, Basic syntax and structure, Remember","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,5,5,5,"This is a straightforward foundational question that directly assesses knowledge of Java's class declaration syntax. The correct answer (C) is unambiguous and technically accurate. All distractors are plausible but clearly incorrect—they reference non-existent or irrelevant Java keywords. The explanations are concise and accurate, clearly distinguishing why each option is correct or incorrect. The cognitive demand perfectly matches the ""Remember"" level of Bloom's taxonomy, as it requires simple recall of a basic Java keyword without requiring analysis, application, or synthesis. The question is well-suited for assessing fundamental Java syntax knowledge."
521947e7-958c-464c-a0c5-932c9b1a8ce3,2025-11-25T07:08:20.212745,Java Fundamentals,Basic syntax and structure,Understand,Which of the following is a valid way to declare and initialize a Java array of five integers?,"int[] nums = {1, 2, 3, 4, 5};","int nums[5] = new int{1, 2, 3, 4, 5};","int nums = new int[5]{1, 2, 3, 4, 5};",int[] nums = new int(5);,A,This is the correct syntax for array declaration and initialization using an initializer list.,Java does not support C-style array declarations with brackets after the variable name or array size in brackets.,This mixes two Java array syntaxes incorrectly; the size and initializer list cannot both be provided together like this.,"'new int(5)' tries to instantiate an integer with value 5, not an array; array instantiation uses square brackets.","Java arrays are declared using square brackets and can be initialized directly with values in curly braces, as in option A.","Question: Which of the following is a valid way to declare and initialize a Java array of five integers?

Options:  
A) int[] nums = {1, 2, 3, 4, 5};  
B) int nums[5] = new int{1, 2, 3, 4, 5};  
C) int nums = new int[5]{1, 2, 3, 4, 5};  
D) int[] nums = new int(5);

Correct Answer: A

Option A explanation: This is the correct syntax for array declaration and initialization using an initializer list.

Option B explanation: Java does not support C-style array declarations with brackets after the variable name or array size in brackets.

Option C explanation: This mixes two Java array syntaxes incorrectly; the size and initializer list cannot both be provided together like this.

Option D explanation: 'new int(5)' tries to instantiate an integer with value 5, not an array; array instantiation uses square brackets.

Main Explanation: Java arrays are declared using square brackets and can be initialized directly with values in curly braces, as in option A.

Tags: Java Fundamentals, Basic syntax and structure, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,4,5,5,"The question directly assesses Java array declaration and initialization syntax, which is fundamental to the topic. All distractors represent plausible misconceptions (C-style syntax, mixing syntaxes, constructor confusion). Explanations are clear and technically accurate. The cognitive demand aligns well with ""Understand"" level—students must recognize valid syntax rather than apply or analyze deeper concepts. The only minor consideration is that this is somewhat mechanical/recall-based, which could be argued as slightly below ""Understand"" (more ""Remember""), but recognizing valid syntax from invalid options reasonably fits the Understand level for this foundational topic."
27d49efd-0afe-496d-a551-0338b9811785,2025-11-25T07:08:29.836823,Java Fundamentals,Basic syntax and structure,Understand,Which of the following lines is a correct method declaration in Java?,public void myMethod(int x),public int myMethod x int,void public myMethod(int x) {},public int myMethod(int x) {},D,Incorrect; missing curly braces to define the method body.,Incorrect; syntax for declaring parameters and method is invalid.,Incorrect; the order of access modifier and return type is wrong.,"Correct; follows Java’s syntax for method declaration with proper access modifier, return type, name, parameters, and body.","In Java, a method declaration must specify the access modifier, return type, method name, parameter list in parentheses, and a body enclosed in curly braces.","Question: Which of the following lines is a correct method declaration in Java?

Options:
A) public void myMethod(int x)
B) public int myMethod x int
C) void public myMethod(int x) {}
D) public int myMethod(int x) {}

Correct Answer: D

Option A explanation: Incorrect; missing curly braces to define the method body.
Option B explanation: Incorrect; syntax for declaring parameters and method is invalid.
Option C explanation: Incorrect; the order of access modifier and return type is wrong.
Option D explanation: Correct; follows Java’s syntax for method declaration with proper access modifier, return type, name, parameters, and body.

Main Explanation: In Java, a method declaration must specify the access modifier, return type, method name, parameter list in parentheses, and a body enclosed in curly braces.

Tags: Java Fundamentals, Basic syntax and structure, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,4,5,5,"The question directly assesses understanding of Java method declaration syntax, which is fundamental to the stated topic. All options are technically accurate with clear distinctions between correct and incorrect syntax. Explanations are specific and educational, identifying exact errors in each distractor. The cognitive demand aligns well with ""Understand"" level—students must recognize correct syntax patterns rather than merely recall or apply in complex scenarios. The only minor consideration is that this is somewhat straightforward for upper-level understanding, placing it slightly toward the lower end of Bloom's ""Understand"" rather than higher-order thinking, but it remains appropriate for the stated level."
d9d05525-055c-4e6f-867a-f045ec20ee9d,2025-11-25T07:08:38.796858,Java Fundamentals,Basic syntax and structure,Understand,Which of the following is a valid way to declare and initialize a Java array of integers with three elements?,"int[] nums = {1, 2, 3};","int nums = [1, 2, 3];","int[] nums = new int[3]{1, 2, 3};","int nums[] = new int(1, 2, 3);",A,This is the correct syntax for array declaration and initialization in Java.,"Arrays in Java use square brackets after the type, not before the initializer.","The syntax `new int[3]{1, 2, 3}` is invalid in Java.",Parentheses cannot be used to initialize arrays in Java.,"In Java, arrays can be initialized directly with curly braces using the syntax `int[] nums = {1, 2, 3};`. Other forms shown are not valid Java syntax for arrays.","Question: Which of the following is a valid way to declare and initialize a Java array of integers with three elements?

Options:
A) int[] nums = {1, 2, 3};
B) int nums = [1, 2, 3];
C) int[] nums = new int[3]{1, 2, 3};
D) int nums[] = new int(1, 2, 3);

Correct Answer: A

Option A explanation: This is the correct syntax for array declaration and initialization in Java.
Option B explanation: Arrays in Java use square brackets after the type, not before the initializer.
Option C explanation: The syntax `new int[3]{1, 2, 3}` is invalid in Java.
Option D explanation: Parentheses cannot be used to initialize arrays in Java.

Main Explanation: In Java, arrays can be initialized directly with curly braces using the syntax `int[] nums = {1, 2, 3};`. Other forms shown are not valid Java syntax for arrays.

Tags: Java Fundamentals, Basic syntax and structure, Understand","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,4,5,5,"The question directly assesses Java array declaration and initialization syntax, which is fundamental to the topic. All options are technically accurate representations of invalid or valid syntax with clear distinctions. Explanations are concise and educational, explaining why each option fails or succeeds. Bloom alignment is strong for ""Understand"" level—students must recognize correct syntax rather than merely recall it. The only minor consideration is that this could arguably touch ""Remember"" level for students who have simply memorized syntax, but the presence of plausible distractors elevates it appropriately to ""Understand."""
da2a5547-904a-4e58-bff4-b630a9bb91ed,2025-11-25T07:08:48.610715,Java Fundamentals,Basic syntax and structure,Apply,"What is the output when the following Java code is executed?
```java
int x = 5;
System.out.println(++x * 2);
```",10,12,14,11,B,"Incorrect. This would be the result of 5 * 2, but ++x increments before multiplication.","Correct. ++x increments x to 6, then 6 * 2 gives 12.",Incorrect. There is no calculation here that produces 14.,"Incorrect. This would be the result if x were incremented after multiplication, which is not the case.","The prefix increment (++x) increases x to 6 before the multiplication, resulting in 6 * 2 = 12.","Question: What is the output when the following Java code is executed?
```java
int x = 5;
System.out.println(++x * 2);
```

Options:  
A) 10  
B) 12  
C) 14  
D) 11  

Correct Answer: B

Option A explanation: Incorrect. This would be the result of 5 * 2, but ++x increments before multiplication.

Option B explanation: Correct. ++x increments x to 6, then 6 * 2 gives 12.

Option C explanation: Incorrect. There is no calculation here that produces 14.

Option D explanation: Incorrect. This would be the result if x were incremented after multiplication, which is not the case.

Main Explanation: The prefix increment (++x) increases x to 6 before the multiplication, resulting in 6 * 2 = 12.

Tags: Java Fundamentals, Basic syntax and structure, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,4,5,5,"The question directly assesses understanding of prefix increment operators and operator precedence in Java, which are core Java fundamentals. All explanations are technically accurate and clearly distinguish why each distractor is wrong. The question requires students to apply knowledge of operator behavior to predict output, aligning well with Bloom's Apply level. The only minor consideration is that this is a relatively straightforward application scenario; a slightly more complex expression might better represent higher-order application tasks, but the current question is still solidly at the Apply level."
7dab8fad-3fbe-4cfe-9b86-50d3c7723a51,2025-11-25T07:09:02.094141,Java Fundamentals,Basic syntax and structure,Apply,"What is the result of compiling and running the following code?
public class Demo {
    public static void main(String[] args) {
        int x = 5;
        if (x = 3) {
            System.out.println(""Three"");
        }
    }
}","Prints ""Three""",Compilation error,Runtime error,Prints nothing,B,Incorrect; assignment in if-condition is not allowed for boolean context.,Correct; assigning an int to a boolean context causes a compilation error.,Incorrect; code does not reach runtime due to compilation failure.,"Incorrect; compilation fails, so nothing is printed.","The code attempts to use assignment (=) in the if-condition, but Java requires a boolean expression. Assigning an int to a boolean produces a compilation error.","Question: What is the result of compiling and running the following code?
public class Demo {
    public static void main(String[] args) {
        int x = 5;
        if (x = 3) {
            System.out.println(""Three"");
        }
    }
}

Options:
A) Prints ""Three""
B) Compilation error
C) Runtime error
D) Prints nothing

Correct Answer: B

Option A explanation: Incorrect; assignment in if-condition is not allowed for boolean context.
Option B explanation: Correct; assigning an int to a boolean context causes a compilation error.
Option C explanation: Incorrect; code does not reach runtime due to compilation failure.
Option D explanation: Incorrect; compilation fails, so nothing is printed.

Main Explanation: The code attempts to use assignment (=) in the if-condition, but Java requires a boolean expression. Assigning an int to a boolean produces a compilation error.

Tags: Java Fundamentals, Basic syntax and structure, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,3,5,5,"The question directly assesses understanding of Java syntax rules regarding conditional statements and type requirements. All explanations are technically accurate and clearly distinguish why assignment (=) fails in a boolean context. However, the Bloom level is misaligned—this question primarily tests ""Remember/Understand"" (recognizing a syntax error) rather than ""Apply"" (using knowledge to solve problems). An ""Apply"" level question would require students to modify code or apply the concept to new scenarios, not simply identify a compilation error."
a3a982d8-eaca-4baa-b298-94b836d326d6,2025-11-25T07:09:11.925505,Java Fundamentals,Basic syntax and structure,Apply,Which of the following code snippets correctly declares and initializes a Java array of 5 integers with values 1 to 5?,"int[] numbers = {1, 2, 3, 4, 5};","int[5] numbers = (1, 2, 3, 4, 5);","int numbers = new int[5]{1, 2, 3, 4, 5};","int[] numbers = new int[5]; numbers = {1,2,3,4,5};",A,Correct. This is valid Java syntax for array declaration and initialization.,Incorrect. Java does not support this C/C++-style array declaration.,Incorrect. The combination of 'new int[5]{...}' is not valid in Java.,"Incorrect. Array initializer '{1,2,3,4,5}' cannot be used in assignment after declaration.",Option A uses the correct Java syntax for declaring and initializing an integer array with specific values in a single statement. The other options use invalid syntax or unsupported initialization forms.,"Question: Which of the following code snippets correctly declares and initializes a Java array of 5 integers with values 1 to 5?

Options:  
A) int[] numbers = {1, 2, 3, 4, 5};  
B) int[5] numbers = (1, 2, 3, 4, 5);  
C) int numbers = new int[5]{1, 2, 3, 4, 5};  
D) int[] numbers = new int[5]; numbers = {1,2,3,4,5};  

Correct Answer: A

Option A explanation: Correct. This is valid Java syntax for array declaration and initialization.
Option B explanation: Incorrect. Java does not support this C/C++-style array declaration.
Option C explanation: Incorrect. The combination of 'new int[5]{...}' is not valid in Java.
Option D explanation: Incorrect. Array initializer '{1,2,3,4,5}' cannot be used in assignment after declaration.

Main Explanation: Option A uses the correct Java syntax for declaring and initializing an integer array with specific values in a single statement. The other options use invalid syntax or unsupported initialization forms.

Tags: Java Fundamentals, Basic syntax and structure, Apply","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,3,5,5,"The question directly assesses Java array declaration and initialization syntax, which is fundamental to the topic. All explanations are technically accurate and clearly distinguish why each incorrect option fails. However, the Bloom level is better classified as ""Remember/Understand"" rather than ""Apply"" since students are simply recognizing correct syntax rather than applying array knowledge to solve a problem or create a solution. The question would require ""Apply"" level if it asked students to write code using arrays to accomplish a specific task."
27dcd319-2d51-4ed3-8f9c-d51f863b7e40,2025-11-25T07:09:21.959139,Java Fundamentals,Basic syntax and structure,Analyze,"Given the following Java code, what is the output?

```java
int x = 10;
if (x = 5) {
    System.out.println(""Five"");
} else {
    System.out.println(""Ten"");
}
```",Five,Ten,Compilation error,Runtime exception,C,"Incorrect. The code does not output ""Five"" due to a syntax error.","Incorrect. The code does not compile, so ""Ten"" is never printed.",Correct. Assignment in the if condition causes a compilation error.,Incorrect. The code never reaches execution due to a compile-time error.,"In Java, the condition in an `if` statement must be a boolean expression. Using `x = 5` (assignment) instead of `x == 5` (comparison) in the `if` condition results in a compilation error because `int` cannot be converted to `boolean`.","Question: Given the following Java code, what is the output?

```java
int x = 10;
if (x = 5) {
    System.out.println(""Five"");
} else {
    System.out.println(""Ten"");
}
```

Options:
A) Five
B) Ten
C) Compilation error
D) Runtime exception

Correct Answer: C

Option A explanation: Incorrect. The code does not output ""Five"" due to a syntax error.
Option B explanation: Incorrect. The code does not compile, so ""Ten"" is never printed.
Option C explanation: Correct. Assignment in the if condition causes a compilation error.
Option D explanation: Incorrect. The code never reaches execution due to a compile-time error.

Main Explanation: In Java, the condition in an `if` statement must be a boolean expression. Using `x = 5` (assignment) instead of `x == 5` (comparison) in the `if` condition results in a compilation error because `int` cannot be converted to `boolean`.

Tags: Java Fundamentals, Basic syntax and structure, Analyze","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,3,5,5,"The question directly assesses understanding of Java syntax fundamentals, specifically the distinction between assignment and comparison operators in conditional statements. The correct answer and all distractors are technically accurate—the code genuinely produces a compilation error in Java because `if` conditions require boolean expressions, not int values. Explanations are clear and specific, correctly identifying the root cause. However, Bloom alignment is slightly lower than ""Analyze"" because the question primarily requires recognition/recall of a syntax rule rather than deeper analysis; students either know the rule or they don't. A true ""Analyze"" question would require comparing multiple code snippets or explaining consequences of the error."
6214a83f-ff96-4544-9d26-63bf1c3648a9,2025-11-25T07:09:30.665039,Java Fundamentals,Basic syntax and structure,Analyze,"Given the following Java code snippet, what will be printed to the console?

```java
int x = 5;
if (x = 3) {
    System.out.println(""Three"");
} else {
    System.out.println(""Not Three"");
}
```",Three,Not Three,Compilation error,Runtime exception,C,"Incorrect. The code does not print ""Three"" because there is a compilation error.","Incorrect. The code will not print ""Not Three"" due to a compilation error.","Correct. The condition uses assignment (=) instead of comparison (==), causing a compilation error.","Incorrect. The program does not compile, so no runtime exception occurs.","In Java, an assignment (=) cannot be used as a boolean expression in an if condition; a comparison (==) is required. Thus, the code fails to compile.","Question: Given the following Java code snippet, what will be printed to the console?

```java
int x = 5;
if (x = 3) {
    System.out.println(""Three"");
} else {
    System.out.println(""Not Three"");
}
```

Options:
A) Three
B) Not Three
C) Compilation error
D) Runtime exception

Correct Answer: C

Option A explanation: Incorrect. The code does not print ""Three"" because there is a compilation error.
Option B explanation: Incorrect. The code will not print ""Not Three"" due to a compilation error.
Option C explanation: Correct. The condition uses assignment (=) instead of comparison (==), causing a compilation error.
Option D explanation: Incorrect. The program does not compile, so no runtime exception occurs.

Main Explanation: In Java, an assignment (=) cannot be used as a boolean expression in an if condition; a comparison (==) is required. Thus, the code fails to compile.

Tags: Java Fundamentals, Basic syntax and structure, Analyze","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,2,2,4,"While the question is highly relevant to Java fundamentals and syntax, there is a critical accuracy issue: the correct answer is actually A) Three, not C) Compilation error. In Java, an assignment expression like (x = 3) is valid in an if condition because assignment returns a value (3 in this case), and any non-zero integer is truthy in a boolean context. The code compiles and runs successfully, printing ""Three"". The explanations are clear and well-structured, but they are based on an incorrect premise. Additionally, the Bloom level is misaligned—this question primarily tests ""Remember/Understand"" (recognizing syntax rules) rather than ""Analyze"" (breaking down complex scenarios). The question would be excellent if the correct answer were changed to A with appropriate explanations, and the Bloom level adjusted accordingly."
0cc1ec81-307e-46c4-b4bd-9daff65b312d,2025-11-25T07:09:39.940527,Java Fundamentals,Basic syntax and structure,Analyze,"What is the output when the following code is executed?
```java
int x = 5;
if (x > 3)
    if (x < 10)
        System.out.print(""A"");
    else
        System.out.print(""B"");
System.out.print(""C"");
```",AC,ABC,A,BC,A,"Correct; ""A"" prints due to the nested if, and ""C"" always prints.","Incorrect; ""B"" does not print since x < 10 is true.","Incorrect; ""C"" always prints after the if statement.","Incorrect; ""B"" does not print, and ""C"" always prints.","The nested if prints ""A"" since x = 5 satisfies both conditions. ""C"" is printed outside the if blocks, so the output is ""AC"".","Question: What is the output when the following code is executed?
```java
int x = 5;
if (x > 3)
    if (x < 10)
        System.out.print(""A"");
    else
        System.out.print(""B"");
System.out.print(""C"");
```

Options:
A) AC
B) ABC
C) A
D) BC

Correct Answer: A

Option A explanation: Correct; ""A"" prints due to the nested if, and ""C"" always prints.
Option B explanation: Incorrect; ""B"" does not print since x < 10 is true.
Option C explanation: Incorrect; ""C"" always prints after the if statement.
Option D explanation: Incorrect; ""B"" does not print, and ""C"" always prints.

Main Explanation: The nested if prints ""A"" since x = 5 satisfies both conditions. ""C"" is printed outside the if blocks, so the output is ""AC"".

Tags: Java Fundamentals, Basic syntax and structure, Analyze","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,3,5,5,"The question directly assesses understanding of nested if statements and control flow in Java, which are core Java fundamentals. All explanations are technically accurate and clearly distinguish why each distractor is incorrect. However, the Bloom level is misaligned—this question primarily requires ""Remember"" and ""Understand"" (identifying what prints), not ""Analyze"" (breaking down complex systems or examining relationships). To reach Analyze level, the question would need to ask students to compare multiple code snippets, explain the logic flow, or predict outcomes with more complex nested conditions. The question is otherwise well-constructed with clear, educational explanations."
c5e51aeb-d594-4392-aefc-ababcdc8a677,2025-11-25T07:09:51.103981,Java Fundamentals,Basic syntax and structure,Evaluate,Which of the following Java code snippets will NOT compile successfully due to incorrect class or method structure?,"public class Example { void run() { System.out.println(""Hello""); } }",class Demo { static int x = 5; public void show() {} },public void class Test { void start() {} },class Sample { int value; Sample() { value = 1; } },C,Correctly declares a public class and a method; it will compile.,Class and members are properly declared; it will compile.,"Incorrect order of modifiers (""void"" before ""class""); will not compile.",Valid class and constructor structure; it will compile.,"In Java, class declarations cannot be preceded by method return types like ""void"". Option C has an invalid syntax, resulting in a compilation error, while the other options follow correct Java class and method structures.","Question: Which of the following Java code snippets will NOT compile successfully due to incorrect class or method structure?

Options:
A) public class Example { void run() { System.out.println(""Hello""); } }
B) class Demo { static int x = 5; public void show() {} }
C) public void class Test { void start() {} }
D) class Sample { int value; Sample() { value = 1; } }

Correct Answer: C

Option A explanation: Correctly declares a public class and a method; it will compile.
Option B explanation: Class and members are properly declared; it will compile.
Option C explanation: Incorrect order of modifiers (""void"" before ""class""); will not compile.
Option D explanation: Valid class and constructor structure; it will compile.

Main Explanation: In Java, class declarations cannot be preceded by method return types like ""void"". Option C has an invalid syntax, resulting in a compilation error, while the other options follow correct Java class and method structures.

Tags: Java Fundamentals, Basic syntax and structure, Evaluate","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",5,3,5,5,"The question directly assesses Java syntax and class structure fundamentals as intended. All explanations are accurate and clear—Option C's error is unambiguous (void cannot precede class keyword). However, the Bloom level is misaligned: this question primarily requires students to REMEMBER/UNDERSTAND correct syntax rather than EVALUATE. Evaluation would require analyzing trade-offs, comparing design patterns, or justifying structural choices. The question is well-constructed for lower Bloom levels (Remember/Understand) but falls short of true evaluation-level cognition."
d03e653e-4246-40a7-a26d-090ebbaea2f0,2025-11-25T07:10:08.245798,Java Fundamentals,Basic syntax and structure,Evaluate,Which of the following code snippets will NOT compile successfully in Java?,"int x = 10; System.out.println(""Value: "" + x);","String s = ""Hello""; char c = s.charAt(0);",public int y = 5; static int z = 7;,double d = 4.5f + 2;,C,This code is valid; it declares an int and prints its value.,This code is valid; it accesses the first character of a String.,This code is invalid; instance and static fields cannot be declared together outside a class.,This code is valid; a float can be added to an int and assigned to a double.,"In Java, variable declarations must follow correct placement and modifiers. Declaring both instance and static variables together outside a class body is not allowed, making option C invalid. All other snippets follow valid Java syntax and structure rules.","Question: Which of the following code snippets will NOT compile successfully in Java?

Options:
A) int x = 10; System.out.println(""Value: "" + x);
B) String s = ""Hello""; char c = s.charAt(0);
C) public int y = 5; static int z = 7;
D) double d = 4.5f + 2;

Correct Answer: C

Option A explanation: This code is valid; it declares an int and prints its value.
Option B explanation: This code is valid; it accesses the first character of a String.
Option C explanation: This code is invalid; instance and static fields cannot be declared together outside a class.
Option D explanation: This code is valid; a float can be added to an int and assigned to a double.

Main Explanation: In Java, variable declarations must follow correct placement and modifiers. Declaring both instance and static variables together outside a class body is not allowed, making option C invalid. All other snippets follow valid Java syntax and structure rules.

Tags: Java Fundamentals, Basic syntax and structure, Evaluate","Leccture1-java-review.pptx, comp1050-sp2022-lecture2-objects-and-classes.pptx","2, 3, 14, 1505",2,2,1,2,"The question has significant technical issues. Option C's explanation is incorrect—the code snippet shows variable declarations that WOULD compile if placed inside a class body (which is the normal context). The snippet itself is ambiguous about scope; if interpreted as top-level code outside a class, it wouldn't compile, but not for the stated reason. The explanation conflates declaration syntax with placement context. Additionally, Option D contains a subtle type coercion (float + int → double) that might be more appropriate for testing than the ambiguous Option C. The question doesn't clearly assess understanding of Java fundamentals—it tests whether students can identify malformed code, but the explanation provided is misleading about WHY it fails. For Bloom's ""Evaluate"" level, the question should require deeper analysis of design decisions or trade-offs, not just syntax recognition. The question would benefit from clearer context and more accurate explanations."
c26efb75-897b-41a2-9e24-96ef4d32f90a,2025-11-25T07:10:16.721468,Java Fundamentals,Wrapper classes and autoboxing,Remember,Which of the following statements about Java’s wrapper classes is TRUE?,Wrapper classes can be used to store primitive values in collections.,Autoboxing only applies to the Boolean wrapper class.,Wrapper classes are abstract and cannot be instantiated.,Wrapper classes allow direct modification of their wrapped value.,A,Correct. Wrapper classes enable storage of primitive values in collections like ArrayList.,"Incorrect. Autoboxing applies to all primitive wrapper classes, not just Boolean.","Incorrect. Wrapper classes are final, not abstract, and can be instantiated.",Incorrect. Wrapper classes are immutable; their value cannot be changed after creation.,"Java’s wrapper classes encapsulate primitive values, allowing them to be used where objects are required, such as in collections. Autoboxing applies to all primitive wrapper classes, which are immutable and not abstract.","Question: Which of the following statements about Java’s wrapper classes is TRUE?

Options:
A) Wrapper classes can be used to store primitive values in collections.
B) Autoboxing only applies to the Boolean wrapper class.
C) Wrapper classes are abstract and cannot be instantiated.
D) Wrapper classes allow direct modification of their wrapped value.

Correct Answer: A

Option A explanation: Correct. Wrapper classes enable storage of primitive values in collections like ArrayList.
Option B explanation: Incorrect. Autoboxing applies to all primitive wrapper classes, not just Boolean.
Option C explanation: Incorrect. Wrapper classes are final, not abstract, and can be instantiated.
Option D explanation: Incorrect. Wrapper classes are immutable; their value cannot be changed after creation.

Main Explanation: Java’s wrapper classes encapsulate primitive values, allowing them to be used where objects are required, such as in collections. Autoboxing applies to all primitive wrapper classes, which are immutable and not abstract.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Remember","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,5,5,5,"The question directly assesses understanding of wrapper classes and autoboxing, core Java fundamentals. Option A is unambiguously correct and addresses the primary use case of wrapper classes. The distractors are technically accurate misconceptions: B correctly identifies that autoboxing applies broadly (not just Boolean), C accurately describes wrapper classes as final (not abstract), and D correctly notes immutability. All explanations are clear and concise. The cognitive demand appropriately matches the ""Remember"" level—students must recall factual knowledge about wrapper class characteristics, autoboxing scope, class modifiers, and immutability without requiring deeper analysis or application."
9b216ee8-e89a-4c12-8fb7-12bceedd2534,2025-11-25T07:10:27.602074,Java Fundamentals,Wrapper classes and autoboxing,Remember,Which statement best describes autoboxing in Java?,Automatically converting a primitive type to its corresponding wrapper class,Wrapping multiple objects into a single class,Unwrapping a wrapper object to obtain its primitive value,Overriding methods of wrapper classes,A,Correct; autoboxing is the automatic conversion from a primitive type to its wrapper class object.,"Incorrect; this refers to aggregation or composition, not autoboxing.","Incorrect; this describes unboxing, the opposite of autoboxing.",Incorrect; wrapper classes are final and cannot be subclassed or have their methods overridden.,"Autoboxing in Java is the automatic conversion performed by the compiler when a primitive value is assigned to a variable of its corresponding wrapper class, such as converting an int to an Integer.","Question: Which statement best describes autoboxing in Java?

Options:  
A) Automatically converting a primitive type to its corresponding wrapper class  
B) Wrapping multiple objects into a single class  
C) Unwrapping a wrapper object to obtain its primitive value  
D) Overriding methods of wrapper classes  

Correct Answer: A

Option A explanation: Correct; autoboxing is the automatic conversion from a primitive type to its wrapper class object.
Option B explanation: Incorrect; this refers to aggregation or composition, not autoboxing.
Option C explanation: Incorrect; this describes unboxing, the opposite of autoboxing.
Option D explanation: Incorrect; wrapper classes are final and cannot be subclassed or have their methods overridden.

Main Explanation:  
Autoboxing in Java is the automatic conversion performed by the compiler when a primitive value is assigned to a variable of its corresponding wrapper class, such as converting an int to an Integer.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Remember","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,5,5,5,"The question directly assesses understanding of autoboxing, a core concept in the wrapper classes subtopic. Option A is unambiguously correct, while distractors are technically accurate and address common misconceptions (unboxing, composition, and wrapper class immutability). Explanations are clear and specific, distinguishing autoboxing from related concepts. The cognitive demand appropriately matches the ""Remember"" level, requiring recall of the definition without requiring application or analysis."
9c2d3088-f6ea-4c81-80bb-4f3780f154bb,2025-11-25T07:10:35.795800,Java Fundamentals,Wrapper classes and autoboxing,Remember,Which statement best describes Java autoboxing?,Converting a primitive type to its corresponding wrapper class automatically,Manually casting a wrapper object to a primitive type,Creating wrapper objects using the new keyword,Automatically converting a String to a primitive type,A,Correct; autoboxing is automatic conversion from primitive to wrapper class.,"Incorrect; this is manual unboxing, not autoboxing.","Incorrect; using new is explicit object creation, not autoboxing.",Incorrect; converting a String to a primitive is unrelated to autoboxing.,"Autoboxing in Java refers to the automatic conversion by the compiler between primitive types and their corresponding wrapper classes, such as int to Integer.","Question: Which statement best describes Java autoboxing?

Options:  
A) Converting a primitive type to its corresponding wrapper class automatically  
B) Manually casting a wrapper object to a primitive type  
C) Creating wrapper objects using the new keyword  
D) Automatically converting a String to a primitive type  

Correct Answer: A

Option A explanation: Correct; autoboxing is automatic conversion from primitive to wrapper class.  
Option B explanation: Incorrect; this is manual unboxing, not autoboxing.  
Option C explanation: Incorrect; using new is explicit object creation, not autoboxing.  
Option D explanation: Incorrect; converting a String to a primitive is unrelated to autoboxing.

Main Explanation:  
Autoboxing in Java refers to the automatic conversion by the compiler between primitive types and their corresponding wrapper classes, such as int to Integer.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Remember","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,5,5,5,"The question directly and unambiguously assesses understanding of autoboxing, a core concept in the wrapper classes subtopic. Option A is definitively correct, and all distractors are technically accurate but clearly incorrect—Option B describes unboxing, Option C describes explicit instantiation, and Option D describes String conversion. The explanations are concise and precise, correctly identifying why each option is right or wrong. The cognitive demand perfectly matches the ""Remember"" level, as it requires recalling the definition of autoboxing without requiring application or analysis. The question is well-constructed with no ambiguity."
673a4e5e-e7b1-4d4c-8d66-1db5cf219e55,2025-11-25T07:10:44.702964,Java Fundamentals,Wrapper classes and autoboxing,Understand,"What is the output of the following code snippet?

Integer x = 10;
int y = x + 5;
System.out.println(y);",10,15,Compile-time error,105,B,"Incorrect; 10 is the value of x, not the result of the addition.","Correct; x (an Integer) is autounboxed to int, and 10 + 5 equals 15.",Incorrect; no compile-time error occurs because autounboxing is supported.,Incorrect; concatenation does not happen here—it's integer addition.,"Java automatically converts Integer to int via autounboxing, enabling the arithmetic operation. The result is 15.","Question: What is the output of the following code snippet?

Integer x = 10;
int y = x + 5;
System.out.println(y);

Options:
A) 10
B) 15
C) Compile-time error
D) 105

Correct Answer: B

Option A explanation: Incorrect; 10 is the value of x, not the result of the addition.
Option B explanation: Correct; x (an Integer) is autounboxed to int, and 10 + 5 equals 15.
Option C explanation: Incorrect; no compile-time error occurs because autounboxing is supported.
Option D explanation: Incorrect; concatenation does not happen here—it's integer addition.

Main Explanation: Java automatically converts Integer to int via autounboxing, enabling the arithmetic operation. The result is 15.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Understand","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of autoboxing/autounboxing with wrapper classes (Integer) and primitive types (int), which is the stated subtopic. All explanations are technically accurate and clear. The distractors effectively target common misconceptions (confusing with concatenation, misunderstanding autounboxing support). The cognitive demand aligns well with ""Understand"" level—students must recognize the autounboxing mechanism and predict behavior, though it leans slightly toward the higher end of ""Understand"" (approaching ""Apply""). The question is well-constructed and educationally sound."
3105e132-4675-4ec2-bf30-01b318704971,2025-11-25T07:10:54.125181,Java Fundamentals,Wrapper classes and autoboxing,Understand,"What is the result of the following code snippet?

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);",true,false,Compilation error,Runtime exception,B,"Incorrect. The == operator checks reference equality, not value equality, for objects.","Correct. x and y refer to different Integer objects, so == returns false.",Incorrect. The code compiles successfully.,Incorrect. No runtime exception occurs in this code.,"When comparing Integer objects outside the range -128 to 127, autoboxing creates distinct objects. The == operator checks reference equality, so x == y is false here.","Question: What is the result of the following code snippet?

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: B

Option A explanation: Incorrect. The == operator checks reference equality, not value equality, for objects.
Option B explanation: Correct. x and y refer to different Integer objects, so == returns false.
Option C explanation: Incorrect. The code compiles successfully.
Option D explanation: Incorrect. No runtime exception occurs in this code.

Main Explanation: When comparing Integer objects outside the range -128 to 127, autoboxing creates distinct objects. The == operator checks reference equality, so x == y is false here.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Understand","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes and autoboxing behavior in Java, specifically the Integer cache behavior and reference vs. value equality. The correct answer and distractors are technically accurate—Integer values outside -128 to 127 create separate objects, making == return false. Explanations are clear and educational, correctly identifying the reference equality issue. Bloom alignment is strong for ""Understand"" level, though the question borders on ""Apply"" since students must recognize the specific Integer caching behavior. Minor note: The question could be slightly more challenging by asking students to predict behavior with values like 100 (which would return true due to caching), but as written, it effectively assesses the intended learning objective."
8683906e-5535-411b-9797-401c38172ceb,2025-11-25T07:11:01.835380,Java Fundamentals,Wrapper classes and autoboxing,Understand,"What is the result of executing the following code?

Integer a = 1000;
Integer b = 1000;
System.out.println(a == b);",true,false,Compilation error,NullPointerException,B,"Incorrect; '==' compares object references, not values, for Integer objects outside the cached range.","Correct; a and b are distinct Integer objects, so 'a == b' evaluates to false.",Incorrect; the code compiles without error.,"Incorrect; neither variable is null, so no exception is thrown.","Autoboxing creates new Integer objects for values outside -128 to 127. Thus, 'a == b' compares references, not values, resulting in false.","Question: What is the result of executing the following code?

Integer a = 1000;
Integer b = 1000;
System.out.println(a == b);

Options:
A) true
B) false
C) Compilation error
D) NullPointerException

Correct Answer: B

Option A explanation: Incorrect; '==' compares object references, not values, for Integer objects outside the cached range.
Option B explanation: Correct; a and b are distinct Integer objects, so 'a == b' evaluates to false.
Option C explanation: Incorrect; the code compiles without error.
Option D explanation: Incorrect; neither variable is null, so no exception is thrown.

Main Explanation: Autoboxing creates new Integer objects for values outside -128 to 127. Thus, 'a == b' compares references, not values, resulting in false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Understand","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes and autoboxing by testing knowledge of Integer caching behavior and reference vs. value comparison. All explanations are technically accurate and clearly distinguish why 1000 falls outside the cached range (-128 to 127). The distractors effectively target common misconceptions. The cognitive demand slightly exceeds ""Understand"" level as it requires recalling specific implementation details (caching range) rather than just comprehending the general concept, placing it closer to lower ""Apply"" level, but remains appropriate for assessing conceptual understanding of this nuanced behavior."
dd4222a9-900f-403f-8351-0c2fda9c1529,2025-11-25T07:11:15.619938,Java Fundamentals,Wrapper classes and autoboxing,Apply,"What is the output of the following code snippet?

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);",true,false,1000,Compilation error,B,Incorrect. x and y are references to different Integer objects.,Correct. Autoboxing creates separate objects for values outside the -128 to 127 range.,"Incorrect. This prints a boolean value, not the integer value.",Incorrect. The code compiles without errors.,"When comparing Integer objects using '==', reference equality is checked. For values outside the cached range (-128 to 127), new Integer objects are created, making x and y refer to different objects. Hence, x == y is false.","Question: What is the output of the following code snippet?

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);

Options:
A) true
B) false
C) 1000
D) Compilation error

Correct Answer: B

Option A explanation: Incorrect. x and y are references to different Integer objects.
Option B explanation: Correct. Autoboxing creates separate objects for values outside the -128 to 127 range.
Option C explanation: Incorrect. This prints a boolean value, not the integer value.
Option D explanation: Incorrect. The code compiles without errors.

Main Explanation: When comparing Integer objects using '==', reference equality is checked. For values outside the cached range (-128 to 127), new Integer objects are created, making x and y refer to different objects. Hence, x == y is false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Apply","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes, autoboxing, and the Integer cache—core concepts in the stated subtopic. All explanations are technically accurate and clearly distinguish between reference equality (==) and value equality. The distractors effectively target common misconceptions. The Bloom level is slightly below ""Apply"" as it primarily requires understanding and remembering the Integer cache behavior rather than applying concepts to novel situations, though it does require applying knowledge of == operator semantics to predict output."
a0e030d0-1a3f-48fc-966e-9972bdf26cac,2025-11-25T07:11:27.883276,Java Fundamentals,Wrapper classes and autoboxing,Apply,"What is the output of the following code?
Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);",true,false,Compilation error,NullPointerException,B,"Incorrect. 'x == y' compares object references, not values, for Integer objects outside the -128 to 127 range.","Correct. 'x' and 'y' reference different Integer objects, so 'x == y' is false.",Incorrect. The code is syntactically correct and compiles without error.,"Incorrect. Both 'x' and 'y' are non-null, so no NullPointerException occurs.","For Integer values outside the cache range (-128 to 127), new objects are created. Thus, 'x == y' compares different references, resulting in false.","Question: What is the output of the following code?
Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);

Options:
A) true
B) false
C) Compilation error
D) NullPointerException

Correct Answer: B

Option A explanation: Incorrect. 'x == y' compares object references, not values, for Integer objects outside the -128 to 127 range.

Option B explanation: Correct. 'x' and 'y' reference different Integer objects, so 'x == y' is false.

Option C explanation: Incorrect. The code is syntactically correct and compiles without error.

Option D explanation: Incorrect. Both 'x' and 'y' are non-null, so no NullPointerException occurs.

Main Explanation: For Integer values outside the cache range (-128 to 127), new objects are created. Thus, 'x == y' compares different references, resulting in false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Apply","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes and autoboxing by testing knowledge of Integer caching behavior and the distinction between reference equality (==) and value equality (.equals()). It's highly relevant to the stated subtopic. Accuracy is excellent—all explanations are technically correct and the answer is unambiguous. Explainability is strong with clear, specific reasoning about why each option is correct or incorrect, including the crucial detail about the -128 to 127 cache range. Bloom alignment is very good (4/5) as it requires students to apply their knowledge of autoboxing and object references to predict code behavior, though it borders on ""Understand"" for students already familiar with this common gotcha; the ""Apply"" level is appropriate for those encountering this concept."
984b66ac-8559-4dba-95d7-54524665da1a,2025-11-25T07:11:35.799268,Java Fundamentals,Wrapper classes and autoboxing,Apply,"What is the output of the following code?

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);",true,false,Compilation error,Runtime exception,B,Incorrect. 'true' is not printed because 'x' and 'y' refer to different Integer objects.,"Correct. 'false' is printed because '==' checks object reference, and these are different objects.",Incorrect. The code compiles successfully.,Incorrect. No exception occurs at runtime.,"Autoboxing creates new Integer objects for values outside -128 to 127, so 'x' and 'y' are different objects and 'x == y' evaluates to false.","Question: What is the output of the following code?

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: B

Option A explanation: Incorrect. 'true' is not printed because 'x' and 'y' refer to different Integer objects.
Option B explanation: Correct. 'false' is printed because '==' checks object reference, and these are different objects.
Option C explanation: Incorrect. The code compiles successfully.
Option D explanation: Incorrect. No exception occurs at runtime.

Main Explanation: Autoboxing creates new Integer objects for values outside -128 to 127, so 'x' and 'y' are different objects and 'x == y' evaluates to false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Apply","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes and autoboxing by testing knowledge of the Integer cache (-128 to 127) and the distinction between == (reference equality) and .equals() (value equality). This is a classic and important concept in Java. The correct answer and distractors are technically accurate—autoboxing does create separate objects for 1000, making the reference comparison false. All explanations are clear and specific about why each option is correct or incorrect. The Bloom level is slightly above ""Apply"" (closer to ""Analyze"") since students must understand the caching mechanism and reference semantics, but it appropriately requires application of wrapper class knowledge to predict output."
abf28cfb-8452-48b0-b471-d8376ae693a4,2025-11-25T07:11:46.449168,Java Fundamentals,Wrapper classes and autoboxing,Analyze,"What is the output of the following code?

Integer a = 128;
Integer b = 128;
System.out.println(a == b);",true,false,Compilation error,Throws a NullPointerException,B,"Incorrect. '==' checks reference equality, not value equality for objects, and these are not the same reference.","Correct. Both Integer objects are outside the cached range and reference different objects, so '==' returns false.",Incorrect. The code compiles without error.,"Incorrect. No object involved is null, so no NullPointerException occurs.","In Java, Integer values between -128 and 127 are cached. Here, both 'a' and 'b' refer to different Integer instances with value 128, so 'a == b' evaluates to false.","Question: What is the output of the following code?

Integer a = 128;
Integer b = 128;
System.out.println(a == b);

Options:
A) true
B) false
C) Compilation error
D) Throws a NullPointerException

Correct Answer: B

Option A explanation: Incorrect. '==' checks reference equality, not value equality for objects, and these are not the same reference.
Option B explanation: Correct. Both Integer objects are outside the cached range and reference different objects, so '==' returns false.
Option C explanation: Incorrect. The code compiles without error.
Option D explanation: Incorrect. No object involved is null, so no NullPointerException occurs.

Main Explanation: In Java, Integer values between -128 and 127 are cached. Here, both 'a' and 'b' refer to different Integer instances with value 128, so 'a == b' evaluates to false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Analyze","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes, autoboxing, and the Integer cache—core concepts in the stated subtopic. It accurately tests the distinction between reference equality (==) and value equality (.equals()), with correct answer and distractors. The explanations are clear and educational, specifically mentioning the -128 to 127 cache range. Bloom alignment is strong (Analyze level) as students must understand how autoboxing interacts with caching and reference comparison, though it borders on Apply since the concept is somewhat well-known among intermediate Java developers. Minor: the question could be slightly more challenging by using values within the cached range as a distractor option."
e08cfa5a-cfaf-46dc-b237-725939b58eee,2025-11-25T07:11:56.895152,Java Fundamentals,Wrapper classes and autoboxing,Analyze,"What is the output of the following code?

Integer a = 127;
Integer b = 127;
System.out.println(a == b);",true,false,Compilation error,Runtime exception,A,"This is correct. For values between -128 and 127, Integer uses cached objects, so a and b reference the same object.","Incorrect. Although == compares references, both a and b refer to the same cached Integer object for 127.",Incorrect. The code is syntactically valid and compiles without error.,Incorrect. There is no runtime exception in this code.,"Java caches Integer objects in the range -128 to 127. Autoboxing for these values returns the same reference, making 'a == b' true.","Question: What is the output of the following code?

Integer a = 127;
Integer b = 127;
System.out.println(a == b);

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: A

Option A explanation: This is correct. For values between -128 and 127, Integer uses cached objects, so a and b reference the same object.

Option B explanation: Incorrect. Although == compares references, both a and b refer to the same cached Integer object for 127.

Option C explanation: Incorrect. The code is syntactically valid and compiles without error.

Option D explanation: Incorrect. There is no runtime exception in this code.

Main Explanation: Java caches Integer objects in the range -128 to 127. Autoboxing for these values returns the same reference, making 'a == b' true.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Analyze","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,3,5,4,"The question directly assesses understanding of Integer caching and autoboxing, which are core wrapper class concepts. Accuracy is strong—all explanations are technically correct and the cached range (-128 to 127) is accurately stated. Explainability is clear with good detail about object references and caching behavior. However, Bloom alignment is slightly lower than intended: the question primarily tests ""Remember/Understand"" (recalling the caching rule) rather than ""Analyze"" (which would require deeper examination of when caching applies, why it exists, or comparison with other scenarios). To better match Analyze level, the question could ask students to predict output for 128, compare with Long, or explain the design rationale."
f7e8c9da-26a1-4e1b-9cee-ae80ef7d3407,2025-11-25T07:12:05.599359,Java Fundamentals,Wrapper classes and autoboxing,Analyze,"What is the output of the following code?

Integer x = 127;
Integer y = 127;
System.out.println(x == y);",true,false,Compilation error,Runtime exception,A,Correct. Integer values from -128 to 127 are cached; both x and y reference the same object.,"Incorrect. For values within the cache range, == compares references that are equal.",Incorrect. The code compiles without error.,Incorrect. No runtime exception occurs.,"Java caches Integer objects between -128 and 127, so x and y refer to the same object and == returns true.","Question: What is the output of the following code?

Integer x = 127;
Integer y = 127;
System.out.println(x == y);

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: A

Option A explanation: Correct. Integer values from -128 to 127 are cached; both x and y reference the same object.

Option B explanation: Incorrect. For values within the cache range, == compares references that are equal.

Option C explanation: Incorrect. The code compiles without error.

Option D explanation: Incorrect. No runtime exception occurs.

Main Explanation: Java caches Integer objects between -128 and 127, so x and y refer to the same object and == returns true.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Analyze","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,3,5,5,"The question directly assesses understanding of Integer caching and autoboxing, core concepts in the wrapper classes subtopic. Accuracy is excellent—all explanations are technically correct and the caching behavior is precisely described. Explanations are clear and educational, effectively distinguishing why == returns true for cached values. However, Bloom alignment is slightly lower than intended: the question primarily requires ""Remember"" and ""Understand"" (recalling the caching rule and understanding autoboxing), rather than ""Analyze"" which demands breaking down complex concepts or examining relationships. To better match Analyze level, the question could ask students to predict output for mixed cached/uncached values or explain the underlying mechanism."
a3193056-0b5f-471f-acc5-fd55fca7dd16,2025-11-25T07:12:14.917597,Java Fundamentals,Wrapper classes and autoboxing,Evaluate,"Given Integer i = 128; and Integer j = 128;, evaluate the result of the expression (i == j).","true, because both objects represent the same integer value","false, because they are different Integer objects outside the cached range","true, because autoboxing always reuses Integer objects","false, because Integer does not support == operator",B,"Incorrect; == compares object references, not values, for Integer.","Correct; 128 is outside the Integer cache, so different objects are created.",Incorrect; autoboxing only caches Integers from -128 to 127.,"Incorrect; Integer supports ==, but compares references, not values.","In Java, Integer objects between -128 and 127 are cached and reused; 128 is not, so i and j point to different objects, making (i == j) false.","Question: Given Integer i = 128; and Integer j = 128;, evaluate the result of the expression (i == j).

Options:
A) true, because both objects represent the same integer value
B) false, because they are different Integer objects outside the cached range
C) true, because autoboxing always reuses Integer objects
D) false, because Integer does not support == operator

Correct Answer: B

Option A explanation: Incorrect; == compares object references, not values, for Integer.
Option B explanation: Correct; 128 is outside the Integer cache, so different objects are created.
Option C explanation: Incorrect; autoboxing only caches Integers from -128 to 127.
Option D explanation: Incorrect; Integer supports ==, but compares references, not values.

Main Explanation: In Java, Integer objects between -128 and 127 are cached and reused; 128 is not, so i and j point to different objects, making (i == j) false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Evaluate","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes, autoboxing, and the Integer cache—core concepts in the stated subtopic. All explanations are technically accurate and clearly distinguish between reference equality (==) and value equality (.equals()). The distractors effectively target common misconceptions. The Bloom level is well-aligned with ""Evaluate"" as students must analyze the caching mechanism and predict behavior; however, it borders on ""Understand"" since the answer primarily requires recalling the -128 to 127 cache range rather than deeper evaluation or synthesis. The question is excellent for teaching but slightly below the highest cognitive demand expected at the Evaluate level."
f97f6742-6e29-4081-a57c-1677a7baeb04,2025-11-25T07:12:25.566335,Java Fundamentals,Wrapper classes and autoboxing,Evaluate,Given Integer x = 128; Integer y = 128; which statement best evaluates the result of (x == y) in Java?,"true, because both Integer objects have the same value.","false, because '==' compares object references, not values.","true, due to autoboxing caching for all integer values.","false, because Integer cannot be compared using '=='.",B,"Incorrect. '==' checks references, not values for objects.","Correct. '==' checks if x and y refer to the same object, but separate Integer objects are created for values outside -128 to 127.","Incorrect. Caching applies only to -128 to 127, not 128.","Incorrect. Integer objects can be compared with '==', but it compares references, not values.","In Java, '==' compares object references for objects. Integer values from -128 to 127 are cached, but 128 is not, so new objects are created and 'x == y' yields false.","Question: Given Integer x = 128; Integer y = 128; which statement best evaluates the result of (x == y) in Java?

Options:
A) true, because both Integer objects have the same value.
B) false, because '==' compares object references, not values.
C) true, due to autoboxing caching for all integer values.
D) false, because Integer cannot be compared using '=='.

Correct Answer: B

Option A explanation: Incorrect. '==' checks references, not values for objects.
Option B explanation: Correct. '==' checks if x and y refer to the same object, but separate Integer objects are created for values outside -128 to 127.
Option C explanation: Incorrect. Caching applies only to -128 to 127, not 128.
Option D explanation: Incorrect. Integer objects can be compared with '==', but it compares references, not values.

Main Explanation: In Java, '==' compares object references for objects. Integer values from -128 to 127 are cached, but 128 is not, so new objects are created and 'x == y' yields false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Evaluate","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,4,5,5,"The question directly assesses understanding of wrapper classes, autoboxing, and the critical distinction between reference equality (==) and value equality (.equals()) in Java. It specifically targets the Integer caching behavior (-128 to 127), which is a key concept in this subtopic. The correct answer and all distractors are technically accurate and address common misconceptions. Explanations are clear and educational, explaining why each option is correct or incorrect. Bloom alignment is strong at the ""Evaluate"" level as students must analyze the behavior of == with Integer objects and judge which explanation best describes the outcome, though it leans slightly toward ""Understand"" since the question primarily asks students to recall/recognize the caching behavior rather than make complex judgments about multiple competing scenarios."
edcd806d-8ecc-4369-99c8-fb31f641e79c,2025-11-25T07:12:33.545597,Java Fundamentals,Wrapper classes and autoboxing,Evaluate,"What will be the output of the following code snippet?

Integer a = 128;
Integer b = 128;
System.out.println(a == b);",true,false,Compilation error,Runtime exception,B,"Incorrect. 'a == b' compares object references, and these refer to different Integer objects for values outside the cache range.","Correct. For values outside -128 to 127, new Integer objects are created, so 'a == b' is false.",Incorrect. The code compiles without error.,Incorrect. The code runs without throwing an exception.,"Java caches Integer objects for values between -128 and 127. For 128, separate objects are created, so 'a == b' compares references and evaluates to false.","Question: What will be the output of the following code snippet?

Integer a = 128;
Integer b = 128;
System.out.println(a == b);

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: B

Option A explanation: Incorrect. 'a == b' compares object references, and these refer to different Integer objects for values outside the cache range.
Option B explanation: Correct. For values outside -128 to 127, new Integer objects are created, so 'a == b' is false.
Option C explanation: Incorrect. The code compiles without error.
Option D explanation: Incorrect. The code runs without throwing an exception.

Main Explanation: Java caches Integer objects for values between -128 and 127. For 128, separate objects are created, so 'a == b' compares references and evaluates to false.

Tags: Java Fundamentals, Wrapper classes and autoboxing, Evaluate","comp1050-lecture8-generics.pptx, comp1050-sp2021-lecture3-thinking-in-classes.pptx, comp1050-sp2021-lecture5-inheritance-polymorphism [Autosaved].pptx","1145, 1346, 825, 1158",5,3,5,5,"The question directly assesses understanding of wrapper classes and autoboxing, specifically the Integer cache behavior. All explanations are accurate and clear. However, the Bloom level alignment is questionable—the question primarily requires students to recall/understand the Integer caching mechanism rather than evaluate. Evaluation would involve analyzing trade-offs, making judgments about design decisions, or comparing approaches. This question is more at the 'Understand' or 'Apply' level (Bloom 2-3) since it tests knowledge of a specific Java behavior rather than requiring critical analysis or judgment."
6f5224e5-1906-4875-a370-e1f4183f8c91,2025-11-25T07:12:42.442249,Control Flow,if/else branching,Remember,"What will be printed by the following code?  
int x = 7;  
if (x > 10)  
    System.out.print(""High"");  
else if (x > 5)  
    System.out.print(""Medium"");  
else  
    System.out.print(""Low"");",High,Medium,Low,No output,B,"Incorrect. ""High"" prints only if x > 10, but x is 7.","Correct. Since 7 > 5, ""Medium"" is printed.","Incorrect. ""Low"" prints only if x <= 5.","Incorrect. Output will be ""Medium"".","The first condition is false, but the second (x > 5) is true, so ""Medium"" prints.","Question: What will be printed by the following code?  
int x = 7;  
if (x > 10)  
    System.out.print(""High"");  
else if (x > 5)  
    System.out.print(""Medium"");  
else  
    System.out.print(""Low"");

Options:  
A) High  
B) Medium  
C) Low  
D) No output

Correct Answer: B

Option A explanation: Incorrect. ""High"" prints only if x > 10, but x is 7.  
Option B explanation: Correct. Since 7 > 5, ""Medium"" is printed.  
Option C explanation: Incorrect. ""Low"" prints only if x <= 5.  
Option D explanation: Incorrect. Output will be ""Medium"".

Main Explanation: The first condition is false, but the second (x > 5) is true, so ""Medium"" prints.

Tags: Control Flow, if/else branching, Remember",Leccture1-java-review.pptx,"13, 14, 15, 12",5,5,5,5,"The question directly assesses understanding of if/else branching by requiring students to trace through conditional logic. The code is straightforward with clear variable assignment (x=7) and three mutually exclusive branches. All options are technically accurate—the distractors represent common misconceptions (checking only the first condition, or confusing boundary conditions). Explanations are concise and specific, identifying why each option is correct or incorrect. The cognitive demand perfectly matches ""Remember"" level, as it requires basic recall and recognition of how if/else statements execute sequentially until a true condition is found. The question has no ambiguity and effectively tests foundational control flow understanding."
9f0e9d03-33f6-4927-89ff-400823e282ec,2025-11-25T07:12:53.825737,Control Flow,if/else branching,Remember,"What will be printed by the following code?

int x = 3;
if (x > 5)
    System.out.print(""A"");
else if (x > 2)
    System.out.print(""B"");
else
    System.out.print(""C"");",A,B,C,Nothing,B,"Incorrect. ""A"" prints only if x > 5, which is false.","Correct. x = 3 is greater than 2, so ""B"" prints.",Incorrect. The else block runs only if x ≤ 2.,Incorrect. One branch always prints; output isn't empty.,"The first if is false, so the else-if is checked; since x > 2 is true, ""B"" is printed.","Question: What will be printed by the following code?

int x = 3;
if (x > 5)
    System.out.print(""A"");
else if (x > 2)
    System.out.print(""B"");
else
    System.out.print(""C"");

Options:
A) A
B) B
C) C
D) Nothing

Correct Answer: B

Option A explanation: Incorrect. ""A"" prints only if x > 5, which is false.
Option B explanation: Correct. x = 3 is greater than 2, so ""B"" prints.
Option C explanation: Incorrect. The else block runs only if x ≤ 2.
Option D explanation: Incorrect. One branch always prints; output isn't empty.

Main Explanation: The first if is false, so the else-if is checked; since x > 2 is true, ""B"" is printed.

Tags: Control Flow, if/else branching, Remember",Leccture1-java-review.pptx,"13, 14, 15, 12",5,5,5,5,"The question directly assesses understanding of if/else-if/else branching logic by requiring students to trace execution through multiple conditions. The code is simple and unambiguous with a clear correct answer (B). All distractors are plausible misconceptions (choosing wrong branch, misunderstanding condition evaluation, or assuming no output). Explanations are concise and pedagogically sound, clearly explaining why each option is correct or incorrect. The cognitive demand perfectly matches the ""Remember"" level—students need to recall how conditional branching works and apply it to trace the code path, which is foundational recall-level knowledge for control flow."
a12dd18d-69ae-4b63-a16c-525a1646f25d,2025-11-25T07:13:04.069084,Control Flow,if/else branching,Remember,"What is the output of the following code?
```java
int x = 10;
if (x > 5)
    System.out.print(""A"");
else if (x > 8)
    System.out.print(""B"");
else
    System.out.print(""C"");
```",A,B,C,AB,A,"Correct; since x > 5 is true, ""A"" is printed and the rest is skipped.",Incorrect; the else-if is not checked because the first if is true.,Incorrect; the else block is not executed because the first if is true.,Incorrect; only one branch executes in an if/else-if/else chain.,Only the first true condition in an if/else-if/else chain is executed; others are skipped even if true.,"Question: What is the output of the following code?
```java
int x = 10;
if (x > 5)
    System.out.print(""A"");
else if (x > 8)
    System.out.print(""B"");
else
    System.out.print(""C"");
```

Options:
A) A
B) B
C) C
D) AB

Correct Answer: A

Option A explanation: Correct; since x > 5 is true, ""A"" is printed and the rest is skipped.
Option B explanation: Incorrect; the else-if is not checked because the first if is true.
Option C explanation: Incorrect; the else block is not executed because the first if is true.
Option D explanation: Incorrect; only one branch executes in an if/else-if/else chain.

Main Explanation: Only the first true condition in an if/else-if/else chain is executed; others are skipped even if true.

Tags: Control Flow, if/else branching, Remember",Leccture1-java-review.pptx,"13, 14, 15, 12",5,5,5,5,"The question directly assesses understanding of if/else-if/else control flow chains, which is the stated subtopic. The code is simple and unambiguous with a clear correct answer (A). All distractors are plausible misconceptions: option B tests whether students understand that else-if is skipped once a condition is true, option C tests understanding that else is skipped, and option D tests whether students might think multiple branches execute. The explanations are concise and clearly articulate why each option is correct or incorrect, emphasizing the key concept that only the first true condition executes. The cognitive demand appropriately matches the ""Remember"" level—students need to recall and apply the basic rule of if/else-if/else execution order without requiring analysis or synthesis."
e362a9d2-2e2f-43c9-82c1-a9d52a38bd56,2025-11-25T07:13:16.064651,Control Flow,if/else branching,Understand,"What will be printed by the following code segment?

```java
int x = 8, y = 4;
if (x > y)
    if (x % y == 0)
        System.out.print(""A"");
    else
        System.out.print(""B"");
else
    System.out.print(""C"");
```",A,B,C,No output,A,"Correct. `x > y` is true and `x % y == 0` is true, so ""A"" is printed.",Incorrect. The else would execute only if `x % y != 0`.,"Incorrect. ""C"" would print only if `x > y` is false.",Incorrect. The code always produces output.,"The outer `if` checks if 8 > 4, which is true. The nested `if` checks if 8 is divisible by 4 (`8 % 4 == 0`), which is also true, so ""A"" is printed.","Question: What will be printed by the following code segment?

```java
int x = 8, y = 4;
if (x > y)
    if (x % y == 0)
        System.out.print(""A"");
    else
        System.out.print(""B"");
else
    System.out.print(""C"");
```

Options:
A) A
B) B
C) C
D) No output

Correct Answer: A

Option A explanation: Correct. `x > y` is true and `x % y == 0` is true, so ""A"" is printed.
Option B explanation: Incorrect. The else would execute only if `x % y != 0`.
Option C explanation: Incorrect. ""C"" would print only if `x > y` is false.
Option D explanation: Incorrect. The code always produces output.

Main Explanation: The outer `if` checks if 8 > 4, which is true. The nested `if` checks if 8 is divisible by 4 (`8 % 4 == 0`), which is also true, so ""A"" is printed.

Tags: Control Flow, if/else branching, Understand",Leccture1-java-review.pptx,"13, 14, 15, 12",5,5,5,5,"The question directly assesses nested if/else control flow and conditional logic evaluation, which are core to the stated topic and subtopic. The code is technically accurate with correct answer and distractors that represent common misconceptions (misunderstanding nested if/else binding, operator precedence, and logical evaluation). All explanations are clear and specific, explaining both why the correct answer is right and why each distractor is wrong. The cognitive demand aligns well with Bloom's ""Understand"" level—students must trace execution through nested conditionals and evaluate multiple boolean expressions, which requires comprehension but not higher-order thinking. The values chosen (8, 4) make the logic transparent without being trivial."
bd6a04af-3221-4dd4-905a-2137746d14bb,2025-11-25T07:13:27.072264,Control Flow,if/else branching,Understand,"What is the output of the following Java code?
```java
int x = 10;
if(x > 5)
    if(x < 15)
        System.out.print(""A"");
    else
        System.out.print(""B"");
System.out.print(""C"");
```",AC,A,BC,C,A,"Correct; ""A"" is printed by the nested if, then ""C"" is printed after the if blocks.","Incorrect; the code prints ""A"", but also ""C"" after the if statements.","Incorrect; the else branch is not executed, so ""B"" is not printed.","Incorrect; ""A"" is printed before ""C"".","The nested if conditions are both true, so ""A"" is printed. After the if blocks, ""C"" is always printed, resulting in ""AC"".","Question: What is the output of the following Java code?
```java
int x = 10;
if(x > 5)
    if(x < 15)
        System.out.print(""A"");
    else
        System.out.print(""B"");
System.out.print(""C"");
```

Options:
A) AC
B) A
C) BC
D) C

Correct Answer: A

Option A explanation: Correct; ""A"" is printed by the nested if, then ""C"" is printed after the if blocks.
Option B explanation: Incorrect; the code prints ""A"", but also ""C"" after the if statements.
Option C explanation: Incorrect; the else branch is not executed, so ""B"" is not printed.
Option D explanation: Incorrect; ""A"" is printed before ""C"".

Main Explanation: The nested if conditions are both true, so ""A"" is printed. After the if blocks, ""C"" is always printed, resulting in ""AC"".

Tags: Control Flow, if/else branching, Understand",Leccture1-java-review.pptx,"13, 14, 15, 12",5,4,5,5,"The question directly assesses nested if/else statements and control flow, which is perfectly aligned with the stated topic and subtopic. The code is technically accurate with correct answer and distractors. All explanations are clear and specific about why each option is correct or incorrect. The cognitive demand slightly exceeds ""Understand"" level as it requires students to trace execution through nested conditionals and recognize scope of else binding, approaching ""Apply"" level, but remains accessible for understanding core concepts. This is a well-constructed question with minor Bloom alignment consideration."
ec3cc908-b5fb-42ed-8228-c6244065e35a,2025-11-25T07:13:38.496511,Control Flow,if/else branching,Understand,"What will be the output of the following code?

```java
int x = 10;
if (x > 10)
    System.out.print(""A"");
else if (x == 10)
    System.out.print(""B"");
else
    System.out.print(""C"");
```",A,B,C,No output,B,"Incorrect. ""A"" is printed only if x > 10, which is false.","Correct. Since x == 10, ""B"" will be printed.","Incorrect. ""C"" is printed only if x < 10, which is false.",Incorrect. The code will print a value; it won’t produce no output.,"The code uses if/else if/else to check the value of x. Since x is exactly 10, the else if branch executes, printing ""B"".","Question: What will be the output of the following code?

```java
int x = 10;
if (x > 10)
    System.out.print(""A"");
else if (x == 10)
    System.out.print(""B"");
else
    System.out.print(""C"");
```

Options:
A) A
B) B
C) C
D) No output

Correct Answer: B

Option A explanation: Incorrect. ""A"" is printed only if x > 10, which is false.
Option B explanation: Correct. Since x == 10, ""B"" will be printed.
Option C explanation: Incorrect. ""C"" is printed only if x < 10, which is false.
Option D explanation: Incorrect. The code will print a value; it won’t produce no output.

Main Explanation: The code uses if/else if/else to check the value of x. Since x is exactly 10, the else if branch executes, printing ""B"".

Tags: Control Flow, if/else branching, Understand",Leccture1-java-review.pptx,"13, 14, 15, 12",5,5,5,5,"The question directly assesses understanding of if/else if/else control flow by requiring students to trace execution and identify which branch executes. The code is straightforward with no ambiguity—x=10 clearly satisfies the else if condition. All distractors are plausible (students might incorrectly think x>10, x<10, or that no output occurs) and each explanation correctly identifies why that option is wrong. The explanations are clear and specific about the condition evaluation. The cognitive demand matches Bloom's ""Understand"" level—students must comprehend how conditional branching works and trace code execution, without requiring analysis or synthesis. This is a well-constructed foundational question."
07b1128f-f3a0-4e08-9946-909e91404d93,2025-11-25T07:13:54.348922,Control Flow,if/else branching,Apply,"What is the output of the following code snippet?
```java
int a = 10, b = 5;
if (a < b)
    System.out.print(""X"");
else if (a > b * 2)
    System.out.print(""Y"");
else
    System.out.print(""Z"");
```",X,Y,Z,XY,B,Incorrect. The first condition (a < b) is false.,"Correct. The second condition (a > b * 2) is true because 10 > 10 is false, but the expression is 10 > 10, which is not true. Wait, let's check this carefully.

Actually, b * 2 = 5 * 2 = 10; so a > 10 is false. So the else case will run, which is ""Z"".

So the correct answer should be C) Z.

Let me revise:

Question: What is the output of the following code snippet?
```java
int a = 10, b = 5;
if (a < b)
    System.out.print(""X"");
else if (a > b * 2)
    System.out.print(""Y"");
else
    System.out.print(""Z"");
```

Options:
A) X
B) Y
C) Z
D) XY

Correct Answer: C

Option A explanation: Incorrect. a < b is false (10 < 5).

Option B explanation: Incorrect. a > b * 2 is false (10 > 10 is false).","Correct. Both previous conditions are false, so the else block executes (""Z"").","Incorrect. Only one branch will execute; ""XY"" can't be printed.","The if conditions are both false, so the code executes the else branch, printing ""Z"".","Question: What is the output of the following code snippet?
```java
int a = 10, b = 5;
if (a < b)
    System.out.print(""X"");
else if (a > b * 2)
    System.out.print(""Y"");
else
    System.out.print(""Z"");
```

Options:
A) X
B) Y
C) Z
D) XY

Correct Answer: B

Option A explanation: Incorrect. The first condition (a < b) is false.

Option B explanation: Correct. The second condition (a > b * 2) is true because 10 > 10 is false, but the expression is 10 > 10, which is not true. Wait, let's check this carefully.

Actually, b * 2 = 5 * 2 = 10; so a > 10 is false. So the else case will run, which is ""Z"".

So the correct answer should be C) Z.

Let me revise:

Question: What is the output of the following code snippet?
```java
int a = 10, b = 5;
if (a < b)
    System.out.print(""X"");
else if (a > b * 2)
    System.out.print(""Y"");
else
    System.out.print(""Z"");
```

Options:
A) X
B) Y
C) Z
D) XY

Correct Answer: C

Option A explanation: Incorrect. a < b is false (10 < 5).

Option B explanation: Incorrect. a > b * 2 is false (10 > 10 is false).

Option C explanation: Correct. Both previous conditions are false, so the else block executes (""Z"").

Option D explanation: Incorrect. Only one branch will execute; ""XY"" can't be printed.

Main Explanation: The if conditions are both false, so the code executes the else branch, printing ""Z"".

Tags: Control Flow, if/else branching, Apply",Leccture1-java-review.pptx,"13, 14, 15, 12",5,4,5,5,"The question directly assesses understanding of if/else branching and conditional logic, making it highly relevant. The corrected answer (C) and explanations are now technically accurate with clear arithmetic verification (b*2=10, so 10>10 is false). Explanations are specific and educational, helping students understand why each branch is or isn't taken. Bloom alignment is strong at the ""Apply"" level—students must evaluate multiple conditions and trace execution flow, though it could push toward ""Analyze"" if conditions were more complex. The question is well-constructed for assessing foundational control flow concepts."
417f9738-5a0a-4a94-89a7-7c5dbd4fc3d7,2025-11-25T07:14:03.691024,Control Flow,if/else branching,Apply,"What will be the output of the following code?

```java
int x = 8;
if (x > 10)
    System.out.print(""A"");
else if (x > 5)
    System.out.print(""B"");
else
    System.out.print(""C"");
```",A,B,C,No output,B,"Incorrect. The condition (x > 10) is false, so ""A"" is not printed.","Correct. (x > 5) is true when x is 8, so ""B"" is printed.",Incorrect. The else block does not execute because (x > 5) is true.,Incorrect. The code will produce output since one condition matches.,"The first if condition is false, but the else-if (x > 5) is true, so ""B"" is printed.","Question: What will be the output of the following code?

```java
int x = 8;
if (x > 10)
    System.out.print(""A"");
else if (x > 5)
    System.out.print(""B"");
else
    System.out.print(""C"");
```

Options:
A) A
B) B
C) C
D) No output

Correct Answer: B

Option A explanation: Incorrect. The condition (x > 10) is false, so ""A"" is not printed.
Option B explanation: Correct. (x > 5) is true when x is 8, so ""B"" is printed.
Option C explanation: Incorrect. The else block does not execute because (x > 5) is true.
Option D explanation: Incorrect. The code will produce output since one condition matches.

Main Explanation: The first if condition is false, but the else-if (x > 5) is true, so ""B"" is printed.
 
Tags: Control Flow, if/else branching, Apply",Leccture1-java-review.pptx,"13, 14, 15, 12",5,4,5,5,"The question directly assesses if/else branching control flow by requiring students to trace through conditional logic. It is highly relevant to the stated topic and subtopic. The code is technically accurate with correct answer and distractors—all options are plausible misconceptions (wrong condition evaluated, wrong branch taken, or no output). Explanations are clear and specific, addressing why each option is correct or incorrect. Bloom alignment is strong at the ""Apply"" level, as students must apply their understanding of conditional evaluation to trace execution, though it borders on ""Understand"" since it primarily requires following a straightforward execution path rather than solving a more complex problem. The question is well-constructed for assessing foundational control flow comprehension."
62dfd024-4f85-40b9-bc1e-60e274a85f4b,2025-11-25T07:14:15.597999,Control Flow,if/else branching,Apply,"What is the output of the following code snippet?
```java
int x = 7, y = 4;
if (x > y)
    if (x % 2 == 0)
        System.out.print(""A"");
    else
        System.out.print(""B"");
else
    System.out.print(""C"");
```",A,B,C,No output,B,"Incorrect. ""A"" would print if x > y and x was even, but x is odd.","Correct. Since x > y and x is odd, ""B"" is printed.","Incorrect. ""C"" would print only if x <= y.","Incorrect. The code produces output; ""B"" is printed.","The code checks if x > y (true), then tests if x is even (false), so it prints ""B"".","Question: What is the output of the following code snippet?
```java
int x = 7, y = 4;
if (x > y)
    if (x % 2 == 0)
        System.out.print(""A"");
    else
        System.out.print(""B"");
else
    System.out.print(""C"");
```

Options:  
A) A  
B) B  
C) C  
D) No output

Correct Answer: B

Option A explanation: Incorrect. ""A"" would print if x > y and x was even, but x is odd.

Option B explanation: Correct. Since x > y and x is odd, ""B"" is printed.

Option C explanation: Incorrect. ""C"" would print only if x <= y.

Option D explanation: Incorrect. The code produces output; ""B"" is printed.

Main Explanation: The code checks if x > y (true), then tests if x is even (false), so it prints ""B"".

Tags: Control Flow, if/else branching, Apply",Leccture1-java-review.pptx,"13, 14, 15, 12",5,4,5,5,"The question directly assesses if/else branching and nested conditionals, which are core control flow concepts. All explanations are accurate and clearly trace through the logic. The code requires students to apply their understanding of comparison operators, modulo arithmetic, and nested if/else logic to predict output—appropriate for Bloom's Apply level. The only minor consideration is that the cognitive demand is slightly straightforward (nested conditionals with simple operators), which could be borderline between Apply and Understand, but the requirement to trace multiple conditions and predict output justifies the Apply classification. The question is well-constructed with clear distractors that address common misconceptions."
9f5dd96d-f3c5-41b7-a174-eb0ee1111d5d,2025-11-25T07:14:25.480497,Control Flow,if/else branching,Analyze,"What is the output of the following code segment?

int a = 5, b = 8;
if (a > b)
    if (a + b > 10)
        System.out.println(""X"");
    else
        System.out.println(""Y"");
else
    System.out.println(""Z"");",X,Y,Z,No output due to a compilation error,C,"Incorrect. The outer if condition (a > b) is false, so this branch is never executed.","Incorrect. The outer if is false, so this else branch is not reached.","Correct. The else paired with the outer if is executed, printing ""Z"".",Incorrect. The code compiles without error.,"The condition a > b is false, so the else belonging to the outer if executes and prints ""Z"".","Question: What is the output of the following code segment?

int a = 5, b = 8;
if (a > b)
    if (a + b > 10)
        System.out.println(""X"");
    else
        System.out.println(""Y"");
else
    System.out.println(""Z"");

Options:
A) X
B) Y
C) Z
D) No output due to a compilation error

Correct Answer: C

Option A explanation: Incorrect. The outer if condition (a > b) is false, so this branch is never executed.
Option B explanation: Incorrect. The outer if is false, so this else branch is not reached.
Option C explanation: Correct. The else paired with the outer if is executed, printing ""Z"".
Option D explanation: Incorrect. The code compiles without error.

Main Explanation: The condition a > b is false, so the else belonging to the outer if executes and prints ""Z"".
 
Tags: Control Flow, if/else branching, Analyze",Leccture1-java-review.pptx,"13, 14, 15, 12",5,3,5,5,"The question directly assesses if/else branching and control flow as intended. The code is accurate with correct answer and distractors. Explanations are clear and educational. However, the Bloom level is misaligned—this question requires only ""Remember/Understand"" (trace execution) rather than ""Analyze"" (examine relationships, distinguish between components). A true Analyze-level question would require students to compare multiple control flow structures, predict outcomes under different conditions, or explain why certain branches execute."
f6a32783-2cb9-4aab-a278-a467ea4a83e6,2025-11-25T07:14:35.412640,Control Flow,if/else branching,Analyze,"Given the code below, what will be printed if x = 5 and y = 8?

```java
if (x > 3)
    if (y < 7)
        System.out.println(""A"");
    else
        System.out.println(""B"");
else
    System.out.println(""C"");
```",A,B,C,Nothing is printed,B,"Incorrect. This would print if y < 7, but y is 8.","Correct. The outer if is true (x > 3), but y < 7 is false, so the else prints ""B"".",Incorrect. This only prints if x <= 3.,Incorrect. The code always prints something for any value of x and y.,"The inner if/else is executed because x > 3 is true. Since y = 8 is not less than 7, the ""else"" branch is taken, printing ""B"".","Question: Given the code below, what will be printed if x = 5 and y = 8?

```java
if (x > 3)
    if (y < 7)
        System.out.println(""A"");
    else
        System.out.println(""B"");
else
    System.out.println(""C"");
```

Options:
A) A
B) B
C) C
D) Nothing is printed

Correct Answer: B

Option A explanation: Incorrect. This would print if y < 7, but y is 8.

Option B explanation: Correct. The outer if is true (x > 3), but y < 7 is false, so the else prints ""B"".

Option C explanation: Incorrect. This only prints if x <= 3.

Option D explanation: Incorrect. The code always prints something for any value of x and y.

Main Explanation: The inner if/else is executed because x > 3 is true. Since y = 8 is not less than 7, the ""else"" branch is taken, printing ""B"".

Tags: Control Flow, if/else branching, Analyze",Leccture1-java-review.pptx,"13, 14, 15, 12",5,4,5,5,"The question directly assesses understanding of nested if/else statements and control flow logic, which is core to the stated topic and subtopic. All answer options are technically accurate with correct explanations. The explanations clearly trace through the logic for each option. The cognitive demand aligns well with ""Analyze"" level—students must trace execution paths and understand operator precedence in nested conditionals. The only minor consideration is that ""Analyze"" typically involves comparing or distinguishing between multiple solutions, whereas this question requires following a single execution path; however, the nested structure and need to evaluate multiple conditions still represents solid analytical thinking for this level."
eaef50ce-3d5e-488f-9c0e-2e3a2917afee,2025-11-25T07:14:45.544111,Control Flow,if/else branching,Analyze,"What is the output of the following code snippet?

```java
int x = 5, y = 10;
if (x > y)
    if (y > 0)
        System.out.println(""A"");
    else
        System.out.println(""B"");
else
    System.out.println(""C"");
```",A,B,C,"No output, compilation error",C,"Incorrect. The outer `if (x > y)` is false, so this branch is skipped.",Incorrect. The else attached to the inner if is not executed since the outer if is false.,"Correct. The else is matched with the outer if and prints ""C"".",Incorrect. The code compiles and outputs a result.,"In nested if/else statements without braces, each else matches the nearest preceding unmatched if. Here, since `x > y` is false, the else prints ""C"".","Question: What is the output of the following code snippet?

```java
int x = 5, y = 10;
if (x > y)
    if (y > 0)
        System.out.println(""A"");
    else
        System.out.println(""B"");
else
    System.out.println(""C"");
```

Options:
A) A
B) B
C) C
D) No output, compilation error

Correct Answer: C

Option A explanation: Incorrect. The outer `if (x > y)` is false, so this branch is skipped.

Option B explanation: Incorrect. The else attached to the inner if is not executed since the outer if is false.

Option C explanation: Correct. The else is matched with the outer if and prints ""C"".

Option D explanation: Incorrect. The code compiles and outputs a result.

Main Explanation: In nested if/else statements without braces, each else matches the nearest preceding unmatched if. Here, since `x > y` is false, the else prints ""C"".

Tags: Control Flow, if/else branching, Analyze",Leccture1-java-review.pptx,"13, 14, 15, 12",5,4,5,5,"The question directly assesses understanding of nested if/else control flow and the critical concept of else-matching rules in Java, which is core to the subtopic. The code is technically accurate with correct answer and distractors. Explanations are clear and educational, specifically addressing the else-matching rule. Bloom alignment is strong at the ""Analyze"" level as students must trace execution flow and understand conditional logic, though it borders on ""Apply"" since the solution involves applying a known rule rather than deeper analysis of multiple scenarios or edge cases."
67e54a21-58c4-4c33-b678-71abe24dbe19,2025-11-25T07:14:58.350659,Control Flow,if/else branching,Evaluate,"What is the output of the following Java code?

```java
int x = 5;
if (x > 2)
    if (x < 4)
        System.out.print(""A"");
    else
        System.out.print(""B"");
else
    System.out.print(""C"");
```",B,A,C,No output,A,"Correct; the first if is true, the second is false, so the else prints ""B"".","Incorrect; ""A"" would print if x < 4, but x is 5.","Incorrect; ""C"" prints only if x <= 2, but x is 5.","Incorrect; there is output (""B"").","The nested if/else structure evaluates as: x > 2 (true), x < 4 (false), so the else after the second if executes and prints ""B"".","Question: What is the output of the following Java code?

```java
int x = 5;
if (x > 2)
    if (x < 4)
        System.out.print(""A"");
    else
        System.out.print(""B"");
else
    System.out.print(""C"");
```

Options:
A) B
B) A
C) C
D) No output

Correct Answer: A

Option A explanation: Correct; the first if is true, the second is false, so the else prints ""B"".
Option B explanation: Incorrect; ""A"" would print if x < 4, but x is 5.
Option C explanation: Incorrect; ""C"" prints only if x <= 2, but x is 5.
Option D explanation: Incorrect; there is output (""B"").

Main Explanation: The nested if/else structure evaluates as: x > 2 (true), x < 4 (false), so the else after the second if executes and prints ""B"".

Tags: Control Flow, if/else branching, Evaluate",Leccture1-java-review.pptx,"13, 14, 15, 12",5,2,5,5,"The question directly assesses nested if/else branching and control flow (relevance: excellent). However, the cognitive demand is primarily at the ""Remember/Understand"" or ""Apply"" level, not ""Evaluate"" as stated. Students must trace execution and apply conditional logic, but evaluation requires making judgments about value, effectiveness, or alternatives—this question simply requires following a predetermined path. The correct answer and distractors are technically accurate with clear, specific explanations that effectively teach the concept of else-binding in nested conditionals. The explanations correctly identify why each option is right or wrong."
d4c63839-3ba6-40ea-a635-a93a745e8d48,2025-11-25T07:15:07.567156,Control Flow,if/else branching,Evaluate,"What will be printed by the following code?

```java
int x = 7;
if (x > 10)
    System.out.print(""High"");
else if (x == 7)
    System.out.print(""Lucky"");
else
    System.out.print(""Low"");
```",High,Lucky,Low,No output,B,"Incorrect. x is not greater than 10, so ""High"" is not printed.","Correct. x equals 7, so ""Lucky"" is printed by the else-if branch.",Incorrect. The else block is not executed since the else-if condition is true.,Incorrect. There will be output; the else-if branch executes.,"The code checks each condition in order. Since x equals 7, the else-if branch is executed and ""Lucky"" is printed.","Question: What will be printed by the following code?

```java
int x = 7;
if (x > 10)
    System.out.print(""High"");
else if (x == 7)
    System.out.print(""Lucky"");
else
    System.out.print(""Low"");
```

Options:
A) High
B) Lucky
C) Low
D) No output

Correct Answer: B

Option A explanation: Incorrect. x is not greater than 10, so ""High"" is not printed.
Option B explanation: Correct. x equals 7, so ""Lucky"" is printed by the else-if branch.
Option C explanation: Incorrect. The else block is not executed since the else-if condition is true.
Option D explanation: Incorrect. There will be output; the else-if branch executes.

Main Explanation: The code checks each condition in order. Since x equals 7, the else-if branch is executed and ""Lucky"" is printed.

Tags: Control Flow, if/else branching, Evaluate",Leccture1-java-review.pptx,"13, 14, 15, 12",5,2,5,5,"The question directly assesses if/else branching and control flow (relevance: excellent). However, the cognitive demand is misaligned with the stated Bloom level of ""Evaluate"" — this question only requires students to trace code execution and recall conditional logic, which falls at the ""Understand"" or ""Apply"" level (Bloom 2-3), not ""Evaluate"" (Bloom 5). The correct answer and distractors are technically accurate with no ambiguity. Explanations are clear and specific, addressing why each option is correct or incorrect. To better match ""Evaluate,"" the question would need to ask students to judge code correctness, compare alternative implementations, or justify design decisions."
9f65727e-5a2d-41d3-992a-11f97e0b1eee,2025-11-25T07:15:17.744281,Control Flow,if/else branching,Evaluate,"Consider the following code. What will be the value of result after execution?

```java
int x = 5, y = 10;
int result = 0;
if (x > y)
    if (y > 0)
        result = 1;
    else
        result = 2;
else
    result = 3;
```",result is 1,result is 2,result is 3,result is 0,C,"Incorrect. The inner if (y > 0) only executes if x > y, which is false.","Incorrect. The else (result = 2) is tied to if (y > 0), only relevant if x > y.","Correct. Since x > y is false, the outer else sets result to 3.",Incorrect. result is reassigned by the outer else before program ends.,"The outer if (x > y) is false, so the code directly executes the outer else, setting result to 3. Inner conditions are skipped.","Question: Consider the following code. What will be the value of result after execution?

```java
int x = 5, y = 10;
int result = 0;
if (x > y)
    if (y > 0)
        result = 1;
    else
        result = 2;
else
    result = 3;
```

Options:
A) result is 1
B) result is 2
C) result is 3
D) result is 0

Correct Answer: C

Option A explanation: Incorrect. The inner if (y > 0) only executes if x > y, which is false.

Option B explanation: Incorrect. The else (result = 2) is tied to if (y > 0), only relevant if x > y.

Option C explanation: Correct. Since x > y is false, the outer else sets result to 3.

Option D explanation: Incorrect. result is reassigned by the outer else before program ends.

Main Explanation: The outer if (x > y) is false, so the code directly executes the outer else, setting result to 3. Inner conditions are skipped.

Tags: Control Flow, if/else branching, Evaluate",Leccture1-java-review.pptx,"13, 14, 15, 12",5,2,5,5,"The question directly assesses if/else branching and nested conditionals, making it highly relevant. However, the cognitive demand is primarily at the ""Remember/Understand"" or ""Apply"" level (trace execution), not ""Evaluate"" as claimed. Evaluating would require comparing approaches, justifying design choices, or critiquing code logic. The correct answer and distractors are technically accurate with clear explanations of why each option is correct or incorrect. The explanations effectively teach the dangling-else problem and control flow precedence."
92c0f108-aa43-4b82-b197-3c5e226d5081,2025-11-25T07:15:26.102142,Control Flow,switch statements,Remember,Which primitive data type can be used as a selector in a Java switch statement?,double,long,char,float,C,double is not allowed as a switch selector.,long cannot be used in a switch selector.,char is a valid switch selector type.,float is not permitted in a switch selector.,"In Java, valid switch selector types are byte, short, int, char, and their wrappers, as well as String and enums. Floating-point types (float, double) and long are not supported.","Question: Which primitive data type can be used as a selector in a Java switch statement?

Options:
A) double  
B) long  
C) char  
D) float  

Correct Answer: C

Option A explanation: double is not allowed as a switch selector.
Option B explanation: long cannot be used in a switch selector.
Option C explanation: char is a valid switch selector type.
Option D explanation: float is not permitted in a switch selector.

Main Explanation: In Java, valid switch selector types are byte, short, int, char, and their wrappers, as well as String and enums. Floating-point types (float, double) and long are not supported.

Tags: Control Flow, switch statements, Remember",Leccture1-java-review.pptx,"14, 13, 21, 15",5,5,4,4,"The question directly assesses knowledge of switch statement selector types, which is core to control flow understanding. It aligns well with the ""Remember"" level as it requires recalling which primitive types are valid. The correct answer (char) is accurate. However, there is a minor accuracy issue: the overall explanation states that long is not supported, but Java 7+ actually added support for long in switch statements (though this varies by Java version and context). The explanations are clear and educational, though they could be more specific about why floating-point types are excluded (precision/comparison issues). The distractors are well-chosen as they represent common misconceptions about numeric types."
598de5a1-5be0-445e-aee5-35bb46071b16,2025-11-25T07:15:37.418025,Control Flow,switch statements,Remember,Which of the following data types is NOT permitted as an expression in a Java switch statement?,int,String,boolean,char,C,int is allowed in switch statements (since early Java versions).,String is allowed in switch statements (since Java 7).,boolean is NOT permitted in switch statements.,char is allowed in switch statements.,"Java switch statements accept int, char, enum, and String types, but not boolean, because a switch requires multiple possible values, while boolean has only two.","Question: Which of the following data types is NOT permitted as an expression in a Java switch statement?

Options:
A) int
B) String
C) boolean
D) char

Correct Answer: C

Option A explanation: int is allowed in switch statements (since early Java versions).
Option B explanation: String is allowed in switch statements (since Java 7).
Option C explanation: boolean is NOT permitted in switch statements.
Option D explanation: char is allowed in switch statements.

Main Explanation: Java switch statements accept int, char, enum, and String types, but not boolean, because a switch requires multiple possible values, while boolean has only two.

Tags: Control Flow, switch statements, Remember",Leccture1-java-review.pptx,"14, 13, 21, 15",5,5,5,5,"The question directly assesses knowledge of switch statement syntax rules, a core control flow concept. The correct answer (boolean) is unambiguous and technically accurate—boolean is indeed the only common type among the options not permitted in switch statements. All distractors are correct (int, String, char are all allowed), making them effective. The explanations are clear and concise, with the overall explanation providing good pedagogical insight into the reasoning (boolean's limitation due to only two values). The question perfectly aligns with Bloom's Remember level, requiring straightforward recall of Java's switch statement type restrictions without requiring analysis or application."
4109b78a-fdf3-4a13-80b8-df4a9c3f8ff8,2025-11-25T07:15:45.357038,Control Flow,switch statements,Remember,Which data type can be directly used in a Java switch statement?,String,double,boolean,float,A,"Correct; since Java 7, String is supported in switch statements.",Incorrect; double is not allowed in switch statements.,Incorrect; boolean cannot be used with switch statements.,Incorrect; float is not permitted in switch statements.,"Java switch statements support int, short, byte, char, enum types, and since Java 7, String. Floating-point and boolean types are not allowed.","Question: Which data type can be directly used in a Java switch statement?

Options:
A) String
B) double
C) boolean
D) float

Correct Answer: A

Option A explanation: Correct; since Java 7, String is supported in switch statements.
Option B explanation: Incorrect; double is not allowed in switch statements.
Option C explanation: Incorrect; boolean cannot be used with switch statements.
Option D explanation: Incorrect; float is not permitted in switch statements.

Main Explanation: Java switch statements support int, short, byte, char, enum types, and since Java 7, String. Floating-point and boolean types are not allowed.

Tags: Control Flow, switch statements, Remember",Leccture1-java-review.pptx,"14, 13, 21, 15",5,5,5,5,"The question directly assesses knowledge of which data types are supported in Java switch statements, which is core to the switch statement subtopic. The correct answer (String) is accurate for Java 7+, and all distractors (double, boolean, float) are correctly identified as unsupported types with accurate explanations. The overall explanation provides helpful context about all supported types. The question requires simple recall of language specifications, perfectly matching the ""Remember"" Bloom level. Explanations are clear and specific about why each option is correct or incorrect."
cfca7c59-d00a-4e97-bdc6-0c0ec1ffd154,2025-11-25T07:15:55.145126,Control Flow,switch statements,Understand,"What is the output of the following code?

```java
int value = 2;
switch (value + 1) {
    case 2:
        System.out.print(""A"");
        break;
    case 3:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```",A,BC,B,C,B,"Incorrect. Case 2 does not match, so ""A"" is not printed.","Correct. Case 3 matches; ""B"" is printed, and without break, ""C"" from default is also printed.","Incorrect. Only ""B"" would be printed if there were a break after case 3.","Incorrect. ""C"" is printed only after ""B"" due to fall-through; alone, it’s not correct.","The expression evaluates to 3, matching case 3. With no break after case 3, execution falls through to default, so ""BC"" is printed.","Question: What is the output of the following code?

```java
int value = 2;
switch (value + 1) {
    case 2:
        System.out.print(""A"");
        break;
    case 3:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```

Options:
A) A
B) BC
C) B
D) C

Correct Answer: B

Option A explanation: Incorrect. Case 2 does not match, so ""A"" is not printed.
Option B explanation: Correct. Case 3 matches; ""B"" is printed, and without break, ""C"" from default is also printed.
Option C explanation: Incorrect. Only ""B"" would be printed if there were a break after case 3.
Option D explanation: Incorrect. ""C"" is printed only after ""B"" due to fall-through; alone, it’s not correct.

Main Explanation: The expression evaluates to 3, matching case 3. With no break after case 3, execution falls through to default, so ""BC"" is printed.

Tags: Control Flow, switch statements, Understand",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses understanding of switch statements and fall-through behavior, which is core to the subtopic. The code is technically accurate with correct answer and distractors. Explanations are clear and specific about why each option is correct/incorrect, particularly highlighting the fall-through mechanism. The cognitive demand slightly exceeds basic ""Understand"" level as it requires tracing execution flow and recognizing the absence of a break statement causes fall-through—this borders on ""Apply"" in Bloom's taxonomy, but remains solidly in the understanding range for switch statement mechanics."
d034ff79-4e70-4b22-8fcd-612a862c49b6,2025-11-25T07:16:04.982524,Control Flow,switch statements,Understand,"What is the output of the following code?
```java
int day = 2;
switch(day) {
    case 1:
        System.out.print(""Mon "");
    case 2:
        System.out.print(""Tue "");
    case 3:
        System.out.print(""Wed "");
        break;
    default:
        System.out.print(""Other"");
}
```",Tue Wed,Tue,Tue Wed Other,Tue Wed Mon,A,"Correct; execution starts at case 2, prints ""Tue "", then case 3 (""Wed ""), then break.","Incorrect; ""Wed "" is also printed because there is no break after case 2.","Incorrect; ""Other"" is not printed since default is not reached.","Incorrect; ""Mon"" is not printed because case 1 does not match and there is no fall-through from prior cases.","In switch statements without breaks, control flows from the matching case through subsequent cases until a break or end, printing ""Tue Wed"".","Question: What is the output of the following code?
```java
int day = 2;
switch(day) {
    case 1:
        System.out.print(""Mon "");
    case 2:
        System.out.print(""Tue "");
    case 3:
        System.out.print(""Wed "");
        break;
    default:
        System.out.print(""Other"");
}
```

Options:  
A) Tue Wed  
B) Tue  
C) Tue Wed Other  
D) Tue Wed Mon  

Correct Answer: A

Option A explanation: Correct; execution starts at case 2, prints ""Tue "", then case 3 (""Wed ""), then break.

Option B explanation: Incorrect; ""Wed "" is also printed because there is no break after case 2.

Option C explanation: Incorrect; ""Other"" is not printed since default is not reached.

Option D explanation: Incorrect; ""Mon"" is not printed because case 1 does not match and there is no fall-through from prior cases.

Main Explanation: In switch statements without breaks, control flows from the matching case through subsequent cases until a break or end, printing ""Tue Wed"".

Tags: Control Flow, switch statements, Understand",Leccture1-java-review.pptx,"14, 13, 21, 15",5,5,5,5,"This question directly and effectively assesses understanding of switch statement fall-through behavior, a core concept in control flow. The code example is well-designed with a missing break statement that creates the teaching moment. All options are technically accurate with clear distinctions: Option A correctly identifies fall-through from case 2 through case 3 until break; Options B, C, and D each represent common misconceptions (stopping at first match, including default, or including prior cases). The explanations are precise and educational, explicitly addressing why each incorrect option fails. The cognitive demand perfectly matches Bloom's ""Understand"" level—students must trace execution flow and predict output without requiring deeper analysis or application. The question is unambiguous with no edge cases or technical errors."
872a3c49-161c-4e12-a011-a69d223265f3,2025-11-25T07:16:13.922651,Control Flow,switch statements,Understand,"What is the output of the following Java code snippet?

```java
int day = 2;
switch(day) {
    case 1: System.out.print(""Mon "");
    case 2: System.out.print(""Tue "");
    case 3: System.out.print(""Wed ""); break;
    default: System.out.print(""Other"");
}
```",Tue Wed,Tue Wed Other,Wed,Tue,A,"Correct. The switch executes from case 2, through case 3, then breaks, printing ""Tue Wed"".","Incorrect. The ""Other"" case is not executed because of the break after ""Wed"".","Incorrect. ""Wed"" alone is printed only if `day` is 3.","Incorrect. No break after ""Tue"", so ""Wed"" is also printed.","In switch statements without breaks, execution ""falls through"" to subsequent cases. For `day = 2`, cases 2 and 3 execute, resulting in ""Tue Wed"".","Question: What is the output of the following Java code snippet?

```java
int day = 2;
switch(day) {
    case 1: System.out.print(""Mon "");
    case 2: System.out.print(""Tue "");
    case 3: System.out.print(""Wed ""); break;
    default: System.out.print(""Other"");
}
```

Options:  
A) Tue Wed  
B) Tue Wed Other  
C) Wed  
D) Tue  

Correct Answer: A

Option A explanation: Correct. The switch executes from case 2, through case 3, then breaks, printing ""Tue Wed"".

Option B explanation: Incorrect. The ""Other"" case is not executed because of the break after ""Wed"".

Option C explanation: Incorrect. ""Wed"" alone is printed only if `day` is 3.

Option D explanation: Incorrect. No break after ""Tue"", so ""Wed"" is also printed.

Main Explanation: In switch statements without breaks, execution ""falls through"" to subsequent cases. For `day = 2`, cases 2 and 3 execute, resulting in ""Tue Wed"".

Tags: Control Flow, switch statements, Understand",Leccture1-java-review.pptx,"14, 13, 21, 15",5,5,5,5,"This question directly and effectively assesses understanding of switch statement fall-through behavior, a fundamental concept in control flow. The correct answer and all distractors are technically accurate and unambiguous—each represents a plausible misconception (forgetting about fall-through, misunderstanding break placement, or confusing which case executes). The explanations are clear and specific, correctly identifying why each option is right or wrong. The cognitive demand perfectly matches Bloom's ""Understand"" level: students must recognize and explain the fall-through mechanism rather than merely recall or apply it. The code snippet is concise yet sufficiently complex to test genuine comprehension."
daa69653-ca8c-4941-b20a-e3dd8f3ec5d5,2025-11-25T07:16:27.852468,Control Flow,switch statements,Apply,"What is the output of the following Java code?

```java
int day = 2;
switch(day) {
    case 1:
        System.out.print(""Mon "");
    case 2:
        System.out.print(""Tue "");
    case 3:
        System.out.print(""Wed "");
        break;
    default:
        System.out.print(""Other"");
}
```",Tue Wed,Mon Tue Wed,Tue,Wed,A,Correct. Execution starts at case 2 and falls through to case 3 until break.,"Incorrect. ""Mon"" is only printed if day == 1.","Incorrect. No break after case 2, so ""Wed"" is also printed.","Incorrect. ""Tue"" is printed before ""Wed"" due to fall-through.","In switch statements without breaks, execution falls through subsequent cases. With day = 2, ""Tue "" and ""Wed "" are printed.","Question: What is the output of the following Java code?

```java
int day = 2;
switch(day) {
    case 1:
        System.out.print(""Mon "");
    case 2:
        System.out.print(""Tue "");
    case 3:
        System.out.print(""Wed "");
        break;
    default:
        System.out.print(""Other"");
}
```

Options:
A) Tue Wed 
B) Mon Tue Wed 
C) Tue 
D) Wed 

Correct Answer: A

Option A explanation: Correct. Execution starts at case 2 and falls through to case 3 until break.

Option B explanation: Incorrect. ""Mon"" is only printed if day == 1.

Option C explanation: Incorrect. No break after case 2, so ""Wed"" is also printed.

Option D explanation: Incorrect. ""Tue"" is printed before ""Wed"" due to fall-through.

Main Explanation: In switch statements without breaks, execution falls through subsequent cases. With day = 2, ""Tue "" and ""Wed "" are printed.

Tags: Control Flow, switch statements, Apply",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses understanding of switch statement fall-through behavior, which is core to the subtopic. The code is accurate with correct answer and well-reasoned distractors. Explanations clearly identify why each option is correct/incorrect and explain the fall-through mechanism. Bloom alignment is strong at ""Apply"" level—students must trace execution flow and predict output based on switch semantics, though it borders on ""Understand"" since it's primarily about recognizing a well-known pattern rather than applying concepts to novel situations."
444c8e0c-1eab-403d-9aa5-73fa800a7b6e,2025-11-25T07:16:42.185631,Control Flow,switch statements,Apply,"What is the output of the following code?

```java
int day = 3;
switch (day) {
    case 1:
        System.out.print(""Mon "");
    case 2:
        System.out.print(""Tue "");
    case 3:
        System.out.print(""Wed "");
    default:
        System.out.print(""Other"");
}
```",Wed Other,Tue Wed Other,Wed,Wed Tue Other,A,"Correct; execution starts at case 3, prints ""Wed "", then falls through default, printing ""Other"".","Incorrect; ""Tue"" is not printed since case 3 matches, and there’s no prior fall-through.","Incorrect; ""Other"" is also printed because there is no break after ""Wed"".","Incorrect; the cases are not executed out of order, ""Tue"" is not printed after ""Wed"".","Without break statements, a switch falls through from the matching case. For `day = 3`, case 3 matches, so ""Wed "" is printed, then the default case also executes, printing ""Other"".","Question: What is the output of the following code?

```java
int day = 3;
switch (day) {
    case 1:
        System.out.print(""Mon "");
    case 2:
        System.out.print(""Tue "");
    case 3:
        System.out.print(""Wed "");
    default:
        System.out.print(""Other"");
}
```

Options:
A) Wed Other
B) Tue Wed Other
C) Wed
D) Wed Tue Other

Correct Answer: A

Option A explanation: Correct; execution starts at case 3, prints ""Wed "", then falls through default, printing ""Other"".

Option B explanation: Incorrect; ""Tue"" is not printed since case 3 matches, and there’s no prior fall-through.

Option C explanation: Incorrect; ""Other"" is also printed because there is no break after ""Wed"".

Option D explanation: Incorrect; the cases are not executed out of order, ""Tue"" is not printed after ""Wed"".

Main Explanation: Without break statements, a switch falls through from the matching case. For `day = 3`, case 3 matches, so ""Wed "" is printed, then the default case also executes, printing ""Other"".

Tags: Control Flow, switch statements, Apply",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses understanding of switch statement fall-through behavior, which is core to the subtopic. The code is accurate with correct answer and distractors that represent common misconceptions (forgetting fall-through, misunderstanding case matching order). Explanations are clear and specific about why each option is correct/incorrect. Bloom alignment is strong at ""Apply"" level—students must apply knowledge of switch mechanics to predict output, though it borders on ""Understand"" since it's primarily about recognizing behavior rather than solving a novel problem. The question effectively tests a critical Java concept that catches many learners."
ecc3465f-2a00-49dc-a500-91609ed102a5,2025-11-25T07:16:52.655797,Control Flow,switch statements,Apply,"What is the output of the following code snippet?

```java
int x = 2;
switch (x + 1) {
    case 1:
        System.out.print(""A"");
        break;
    case 3:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```",BC,B,C,ABC,A,"Correct. Case 3 matches, prints ""B"", then falls through to default and prints ""C"".","Incorrect. There is no break after case 3, so default is also executed.","Incorrect. ""C"" is only printed after ""B"" when case 3 matches.","Incorrect. Case 1 does not match, so ""A"" is not printed.","When `x + 1` equals 3, execution enters case 3, prints ""B"", falls through to default, and prints ""C"". No break prevents the fall-through.","Question: What is the output of the following code snippet?

```java
int x = 2;
switch (x + 1) {
    case 1:
        System.out.print(""A"");
        break;
    case 3:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```

Options:
A) BC
B) B
C) C
D) ABC

Correct Answer: A

Option A explanation: Correct. Case 3 matches, prints ""B"", then falls through to default and prints ""C"".

Option B explanation: Incorrect. There is no break after case 3, so default is also executed.

Option C explanation: Incorrect. ""C"" is only printed after ""B"" when case 3 matches.

Option D explanation: Incorrect. Case 1 does not match, so ""A"" is not printed.

Main Explanation: When `x + 1` equals 3, execution enters case 3, prints ""B"", falls through to default, and prints ""C"". No break prevents the fall-through.

Tags: Control Flow, switch statements, Apply",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses understanding of switch statement control flow, particularly fall-through behavior when break statements are absent. It requires students to trace execution (Apply level), though it borders on Analyze since understanding fall-through is somewhat fundamental. The correct answer is unambiguous (BC), distractors are well-reasoned, and explanations clearly identify why each option is correct or incorrect. The code is concise and the fall-through concept is the central learning objective. Minor note: Bloom's Apply typically involves using knowledge in new situations; this is more straightforward application of switch mechanics, which could be considered foundational Apply or lower-level Understand, but the requirement to trace multiple cases and predict output justifies Apply classification."
cfd0c4aa-4bfe-4d72-9468-af8bff1eada1,2025-11-25T07:17:02.462591,Control Flow,switch statements,Analyze,"Given the code below, what is printed to the console?

```
int x = 2;
switch (x + 1) {
    case 1:
        System.out.print(""A"");
        break;
    case 2:
    case 3:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```",BC,B,C,AC,A,"Correct; case 3 matches, prints ""B"", no break, falls into default, prints ""C"".","Incorrect; after printing ""B"", it falls through and prints ""C"" as well.","Incorrect; only default would print ""C"", but ""B"" is also printed before.","Incorrect; ""A"" is never printed since case 1 does not match.","The expression (x + 1) evaluates to 3, so case 3 matches, printing ""B"". No break follows, so execution continues into the default case, printing ""C"", resulting in ""BC"".","Question: Given the code below, what is printed to the console?

```
int x = 2;
switch (x + 1) {
    case 1:
        System.out.print(""A"");
        break;
    case 2:
    case 3:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```

Options:
A) BC
B) B
C) C
D) AC

Correct Answer: A

Option A explanation: Correct; case 3 matches, prints ""B"", no break, falls into default, prints ""C"".
Option B explanation: Incorrect; after printing ""B"", it falls through and prints ""C"" as well.
Option C explanation: Incorrect; only default would print ""C"", but ""B"" is also printed before.
Option D explanation: Incorrect; ""A"" is never printed since case 1 does not match.

Main Explanation: The expression (x + 1) evaluates to 3, so case 3 matches, printing ""B"". No break follows, so execution continues into the default case, printing ""C"", resulting in ""BC"".

Tags: Control Flow, switch statements, Analyze",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses switch statement behavior, specifically fall-through execution and the default case, which are core control flow concepts. The correct answer and all distractors are technically accurate with no ambiguity. Explanations are clear and educational, identifying why each option is correct or incorrect. The question requires students to trace execution (evaluate x+1, match cases, understand fall-through), which aligns well with ""Analyze"" level. The only minor consideration is that ""Analyze"" typically involves breaking down complex structures or comparing alternatives; this question is more straightforward execution tracing, placing it slightly below the highest Bloom levels but still solidly in the Analyze range."
646bacc7-30d0-45ac-b35a-59e9fd3bd1b8,2025-11-25T07:17:13.827613,Control Flow,switch statements,Analyze,"What will be the output when the following code is executed?

```java
int score = 85;
switch (score / 10) {
    case 10:
    case 9:
        System.out.print(""A"");
        break;
    case 8:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```",B,BC,C,A,B,"Incorrect. The case '8' matches, prints 'B', but no break causes the default to execute as well.","Correct. 'score / 10' is 8, so 'B' is printed, then default executes printing 'C', resulting in ""BC"".","Incorrect. 'C' is printed by default, but 'B' also prints since case '8' matches.","Incorrect. 'A' is only printed for case 10 or 9, which do not match.","The switch matches case 8, prints 'B', then falls through to default, printing 'C' without a break.","Question: What will be the output when the following code is executed?

```java
int score = 85;
switch (score / 10) {
    case 10:
    case 9:
        System.out.print(""A"");
        break;
    case 8:
        System.out.print(""B"");
    default:
        System.out.print(""C"");
}
```

Options:
A) B
B) BC
C) C
D) A

Correct Answer: B

Option A explanation: Incorrect. The case '8' matches, prints 'B', but no break causes the default to execute as well.

Option B explanation: Correct. 'score / 10' is 8, so 'B' is printed, then default executes printing 'C', resulting in ""BC"".

Option C explanation: Incorrect. 'C' is printed by default, but 'B' also prints since case '8' matches.

Option D explanation: Incorrect. 'A' is only printed for case 10 or 9, which do not match.

Main Explanation: The switch matches case 8, prints 'B', then falls through to default, printing 'C' without a break.

Tags: Control Flow, switch statements, Analyze",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses switch statement behavior, specifically fall-through semantics when break statements are missing, which is core to the subtopic. The code is technically accurate with correct answer and distractors. Explanations clearly identify why each option is correct/incorrect and explain the fall-through mechanism. Bloom alignment is strong (Analyze level) as students must trace execution flow and understand control flow consequences, though it borders on Apply since recognizing fall-through is somewhat procedural. The question effectively tests a common misconception about switch statements."
fe012b3a-c0d0-4617-ae83-7a016873cc84,2025-11-25T07:17:23.658629,Control Flow,switch statements,Analyze,"Given the code below, what is printed when input = 2?

```java
int input = 2;
switch(input) {
    case 1:
        System.out.print(""One "");
    case 2:
        System.out.print(""Two "");
    case 3:
        System.out.print(""Three"");
        break;
    default:
        System.out.print(""Default"");
}
```",Two Three,Two Three Default,Two,Two Three Default One,A,"Correct. With input = 2, execution enters case 2 and falls through to case 3, printing ""Two Three"".",Incorrect. The default case is never reached because of the break in case 3.,"Incorrect. It prints ""Two Three"" because of fall-through, not just ""Two"".","Incorrect. ""One"" is not printed since case 1 is not executed, nor is default.","In a switch statement without break after each case, execution falls through subsequent cases. With input = 2, both ""Two"" and ""Three"" are printed before the break ends the switch.","Question: Given the code below, what is printed when input = 2?

```java
int input = 2;
switch(input) {
    case 1:
        System.out.print(""One "");
    case 2:
        System.out.print(""Two "");
    case 3:
        System.out.print(""Three"");
        break;
    default:
        System.out.print(""Default"");
}
```

Options:
A) Two Three
B) Two Three Default
C) Two
D) Two Three Default One

Correct Answer: A

Option A explanation: Correct. With input = 2, execution enters case 2 and falls through to case 3, printing ""Two Three"".

Option B explanation: Incorrect. The default case is never reached because of the break in case 3.

Option C explanation: Incorrect. It prints ""Two Three"" because of fall-through, not just ""Two"".

Option D explanation: Incorrect. ""One"" is not printed since case 1 is not executed, nor is default.

Main Explanation: In a switch statement without break after each case, execution falls through subsequent cases. With input = 2, both ""Two"" and ""Three"" are printed before the break ends the switch.

Tags: Control Flow, switch statements, Analyze",Leccture1-java-review.pptx,"14, 13, 21, 15",5,4,5,5,"The question directly assesses understanding of switch statement fall-through behavior, which is core to the control flow subtopic. All explanations are technically accurate and clearly distinguish why each distractor is wrong. The code example effectively demonstrates the concept. Bloom alignment is strong (Analyze level) as students must trace execution flow and understand fall-through mechanics, though it borders on ""Apply"" since it's primarily execution tracing rather than deeper analysis of design implications. The question is well-constructed for assessing this fundamental OOP concept."
90510ee8-b71b-491b-ac2f-f09d8ac1ece1,2025-11-25T07:17:33.736247,Control Flow,switch statements,Evaluate,"Given the following code, what will be printed?

```java
int level = 2;
switch (level) {
    case 1:
        System.out.print(""Beginner "");
    case 2:
        System.out.print(""Intermediate "");
    case 3:
        System.out.print(""Advanced "");
        break;
    default:
        System.out.print(""Unknown "");
}
```",Intermediate Advanced,Beginner Intermediate Advanced,Advanced,Intermediate,A,"This is correct; without a break after case 2, control falls through to case 3.","Incorrect; ""Beginner"" is printed only if level is 1.","Incorrect; ""Advanced"" is printed only after ""Intermediate"" because control falls through.","Incorrect; ""Intermediate"" is printed, but so is ""Advanced"" due to fall-through.","In a switch statement, lack of a break causes execution to continue into subsequent cases. Since there is no break after case 2, both ""Intermediate"" and ""Advanced"" are printed.","Question: Given the following code, what will be printed?

```java
int level = 2;
switch (level) {
    case 1:
        System.out.print(""Beginner "");
    case 2:
        System.out.print(""Intermediate "");
    case 3:
        System.out.print(""Advanced "");
        break;
    default:
        System.out.print(""Unknown "");
}
```

Options:  
A) Intermediate Advanced  
B) Beginner Intermediate Advanced  
C) Advanced  
D) Intermediate  

Correct Answer: A

Option A explanation: This is correct; without a break after case 2, control falls through to case 3.

Option B explanation: Incorrect; ""Beginner"" is printed only if level is 1.

Option C explanation: Incorrect; ""Advanced"" is printed only after ""Intermediate"" because control falls through.

Option D explanation: Incorrect; ""Intermediate"" is printed, but so is ""Advanced"" due to fall-through.

Main Explanation: In a switch statement, lack of a break causes execution to continue into subsequent cases. Since there is no break after case 2, both ""Intermediate"" and ""Advanced"" are printed.

Tags: Control Flow, switch statements, Evaluate",Leccture1-java-review.pptx,"14, 13, 21, 15",5,3,5,5,"The question directly assesses switch statement fall-through behavior, which is core to the subtopic. All explanations are accurate and clear. However, the Bloom level is misaligned—this question requires ""Remember"" or ""Understand"" (recognizing fall-through behavior) rather than ""Evaluate"" (which demands making judgments based on criteria). The question tests recall of a language feature, not higher-order evaluation skills."
223e2ff2-7005-4a31-965b-a1c3bdf79e54,2025-11-25T07:17:44.242673,Control Flow,switch statements,Evaluate,"What will the following code output?

```java
int num = 3;
switch (num) {
    case 1:
        System.out.print(""One "");
    case 3:
        System.out.print(""Three "");
    default:
        System.out.print(""Default"");
}
```",Three Default,One Three,Three,Three Default,A,"Correct. With no break statements, execution falls through from case 3 to default, printing ""Three Default"".","Incorrect. ""One"" is not printed because num is 3, so case 1 is skipped.","Incorrect. ""Default"" is also printed due to fall-through.","Incorrect. ""Three Default"" is the printed output, but this matches option A, not D.","When the matching case lacks a break, execution continues through subsequent cases (fall-through), so both ""Three"" and ""Default"" are printed.","Question: What will the following code output?

```java
int num = 3;
switch (num) {
    case 1:
        System.out.print(""One "");
    case 3:
        System.out.print(""Three "");
    default:
        System.out.print(""Default"");
}
```

Options:
A) Three Default
B) One Three
C) Three
D) Three Default

Correct Answer: A

Option A explanation: Correct. With no break statements, execution falls through from case 3 to default, printing ""Three Default"".

Option B explanation: Incorrect. ""One"" is not printed because num is 3, so case 1 is skipped.

Option C explanation: Incorrect. ""Default"" is also printed due to fall-through.

Option D explanation: Incorrect. ""Three Default"" is the printed output, but this matches option A, not D.

Main Explanation: When the matching case lacks a break, execution continues through subsequent cases (fall-through), so both ""Three"" and ""Default"" are printed.

Tags: Control Flow, switch statements, Evaluate",Leccture1-java-review.pptx,"14, 13, 21, 15",5,3,5,5,"The question directly and clearly assesses understanding of switch statement fall-through behavior, which is core to the subtopic. Accuracy is excellent—the code, correct answer, and all distractors are technically sound with no ambiguity. Explanations are clear and educational, correctly identifying why each option is right or wrong. However, Bloom alignment is moderate: the question primarily requires students to trace execution and recall fall-through behavior (Understand/Apply level), rather than evaluate trade-offs, judge design decisions, or critique code quality as ""Evaluate"" typically demands. The question would be stronger at Bloom's Apply level."
b2b99e3c-bceb-4346-9688-4ad8a3cb185e,2025-11-25T07:17:54.282224,Control Flow,switch statements,Evaluate,"Given the following Java code, what will be printed?

```java
int value = 2;
switch (value) {
    case 1:
        System.out.print(""One "");
    case 2:
        System.out.print(""Two "");
    case 3:
        System.out.print(""Three "");
        break;
    default:
        System.out.print(""Default "");
}
```",Two Three,Two Three Default,Two Three Default One,One Two Three,A,"Correct; execution starts at case 2 and falls through to case 3, printing ""Two Three"".",Incorrect; the default case is never reached.,"Incorrect; ""One"" is only printed if value is 1.","Incorrect; ""One"" is not printed since value is 2.","In a switch without breaks, execution falls through from the matching case. Since value is 2, it starts at case 2, prints ""Two "", then ""Three "", and stops at break; default is skipped.","Question: Given the following Java code, what will be printed?

```java
int value = 2;
switch (value) {
    case 1:
        System.out.print(""One "");
    case 2:
        System.out.print(""Two "");
    case 3:
        System.out.print(""Three "");
        break;
    default:
        System.out.print(""Default "");
}
```

Options:
A) Two Three
B) Two Three Default
C) Two Three Default One
D) One Two Three

Correct Answer: A

Option A explanation: Correct; execution starts at case 2 and falls through to case 3, printing ""Two Three"".
Option B explanation: Incorrect; the default case is never reached.
Option C explanation: Incorrect; ""One"" is only printed if value is 1.
Option D explanation: Incorrect; ""One"" is not printed since value is 2.

Main Explanation: In a switch without breaks, execution falls through from the matching case. Since value is 2, it starts at case 2, prints ""Two "", then ""Three "", and stops at break; default is skipped.

Tags: Control Flow, switch statements, Evaluate",Leccture1-java-review.pptx,"14, 13, 21, 15",5,3,5,5,"The question directly assesses switch statement fall-through behavior, which is core to the subtopic. All explanations are accurate and clear. However, the Bloom level is misaligned—this question requires only ""Understand"" or ""Apply"" (predicting output based on known rules), not ""Evaluate"" (making judgments, critiquing, or justifying design decisions). To reach Evaluate level, the question would need to ask students to assess trade-offs, critique code design, or justify when fall-through is appropriate versus problematic."
b3b27310-5d2f-4ed8-8ce0-3d690f015605,2025-11-25T07:18:03.185015,Control Flow,boolean expressions,Remember,What is the value of the boolean expression: !(true && false) || (5 > 3 && 2 == 2)?,true,false,null,0,A,Correct; the entire boolean expression evaluates to true.,Incorrect; the expression is not false.,Incorrect; boolean expressions cannot result in null.,Incorrect; boolean expressions do not yield numeric results like 0.,The expression simplifies to !(false) || (true && true) → true || true → true.,"Question: What is the value of the boolean expression: !(true && false) || (5 > 3 && 2 == 2)?

Options:  
A) true  
B) false  
C) null  
D) 0  

Correct Answer: A

Option A explanation: Correct; the entire boolean expression evaluates to true.
Option B explanation: Incorrect; the expression is not false.
Option C explanation: Incorrect; boolean expressions cannot result in null.
Option D explanation: Incorrect; boolean expressions do not yield numeric results like 0.

Main Explanation: The expression simplifies to !(false) || (true && true) → true || true → true.

Tags: Control Flow, boolean expressions, Remember",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses boolean expression evaluation and operator precedence, which are core to the boolean expressions subtopic. All options are technically accurate with appropriate distractors (null and 0 are plausible misconceptions). Explanations are clear and show step-by-step simplification. However, the Bloom alignment is slightly high for ""Remember""—this question requires some application of logical operator rules and precedence understanding, placing it closer to ""Understand"" level rather than pure recall. The question is otherwise excellent for assessing foundational boolean logic knowledge."
13404b53-cde6-4259-aea6-2b9396fcfc66,2025-11-25T07:18:10.731469,Control Flow,boolean expressions,Remember,Which of the following boolean expressions evaluates to true only when both x and y are false?,x || y,!x && !y,x && y,!x || !y,B,Incorrect. This expression is true if either x or y is true.,Correct. This is only true when both x and y are false.,Incorrect. This is true only if both x and y are true.,Incorrect. This is true if at least one of x or y is false.,"The expression !x && !y checks that both x and y are false, using logical negation and AND.","Question: Which of the following boolean expressions evaluates to true only when both x and y are false?

Options:
A) x || y
B) !x && !y
C) x && y
D) !x || !y

Correct Answer: B

Option A explanation: Incorrect. This expression is true if either x or y is true.
Option B explanation: Correct. This is only true when both x and y are false.
Option C explanation: Incorrect. This is true only if both x and y are true.
Option D explanation: Incorrect. This is true if at least one of x or y is false.

Main Explanation: The expression !x && !y checks that both x and y are false, using logical negation and AND.

Tags: Control Flow, boolean expressions, Remember",Leccture1-java-review.pptx,"13, 9, 14, 10",5,5,5,5,"The question directly assesses understanding of boolean expressions and logical operators (!x && !y), which is core to the stated subtopic. All options are technically accurate with correct evaluations for all possible input combinations. The explanations are clear and specific, correctly identifying why each option is right or wrong. The cognitive demand perfectly matches the ""Remember"" level—students need to recall De Morgan's Laws and the behavior of logical operators to identify which expression produces the desired truth condition. The question is unambiguous with no trick elements."
2aa218f0-967c-4c8a-af18-c4224e1fe4c3,2025-11-25T07:18:20.906516,Control Flow,boolean expressions,Remember,What is the result of evaluating the expression: !(true && false) || (false && true) in Java?,true,false,null,Compilation error,A,Correct. The expression evaluates to true.,Incorrect. The expression does not evaluate to false.,Incorrect. Boolean expressions do not result in null.,Incorrect. The expression is syntactically valid in Java.,"The expression !(true && false) evaluates to true, and (false && true) evaluates to false, so the overall expression is true || false, resulting in true.","Question: What is the result of evaluating the expression: !(true && false) || (false && true) in Java?

Options:
A) true
B) false
C) null
D) Compilation error

Correct Answer: A

Option A explanation: Correct. The expression evaluates to true.
Option B explanation: Incorrect. The expression does not evaluate to false.
Option C explanation: Incorrect. Boolean expressions do not result in null.
Option D explanation: Incorrect. The expression is syntactically valid in Java.

Main Explanation: The expression !(true && false) evaluates to true, and (false && true) evaluates to false, so the overall expression is true || false, resulting in true.

Tags: Control Flow, boolean expressions, Remember",Leccture1-java-review.pptx,"13, 9, 14, 10",5,5,5,5,"The question directly assesses understanding of boolean operators (&&, ||, !) and expression evaluation, which are core to the boolean expressions subtopic. All options are technically accurate with no ambiguity—null is impossible for boolean expressions, compilation would not occur, and the evaluation is straightforward. The explanations clearly walk through each step: !(true && false) = !false = true, and (false && true) = false, resulting in true || false = true. The cognitive demand perfectly matches the ""Remember"" level, as it requires students to recall how logical operators work and apply them to evaluate a given expression without requiring deeper analysis or synthesis."
e075afdb-afa2-411f-ae65-d8e0a4adee01,2025-11-25T07:18:29.912546,Control Flow,boolean expressions,Understand,"Given int x = 7, int y = 4; which boolean expression evaluates to true?",(x < y) && (x != y),(x == y) || (x < y),!(x == y) && (x > y),(x > y) && (x == y),C,(x < y) is false and (x != y) is true; false && true is false.,"(x == y) is false, (x < y) is false; false || false is false.","(x == y) is false (so !(x == y) is true), (x > y) is true; true && true is true.","(x > y) is true, (x == y) is false; true && false is false.",Option C correctly combines logical NOT and AND to evaluate to true for the given x and y values.,"Question: Given int x = 7, int y = 4; which boolean expression evaluates to true?

Options:
A) (x < y) && (x != y)
B) (x == y) || (x < y)
C) !(x == y) && (x > y)
D) (x > y) && (x == y)

Correct Answer: C

Option A explanation: (x < y) is false and (x != y) is true; false && true is false.
Option B explanation: (x == y) is false, (x < y) is false; false || false is false.
Option C explanation: (x == y) is false (so !(x == y) is true), (x > y) is true; true && true is true.
Option D explanation: (x > y) is true, (x == y) is false; true && false is false.

Main Explanation: Option C correctly combines logical NOT and AND to evaluate to true for the given x and y values.

Tags: Control Flow, boolean expressions, Understand",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses understanding of boolean expressions with logical operators (&&, ||, !), which is core to the stated subtopic. All explanations are clear and trace through each component systematically. The correct answer and distractors are technically accurate with no ambiguity. Bloom alignment is strong for ""Understand"" level—students must evaluate expressions and apply knowledge of operator precedence and truth tables. The rating is 4 rather than 5 for Bloom because the question sits at the upper end of ""Understand"" (close to ""Apply""), as it requires evaluating multiple conditions simultaneously rather than simple recall or basic comprehension."
a3f03583-3955-4ec9-a9ad-8471f58d3876,2025-11-25T07:18:39.466030,Control Flow,boolean expressions,Understand,"What will the following boolean expression evaluate to if x = 5 and y = 10?  
boolean result = !(x > 3 && y < 10);",true,false,x,y,A,"Correct. (x > 3 && y < 10) is (true && false), which is false; !false is true.","Incorrect. The expression actually evaluates to true, not false.","Incorrect. The result is a boolean, not the value of x.","Incorrect. The result is a boolean, not the value of y.","The original expression inside the parentheses is false, so the logical NOT operator (!) changes it to true.","Question: What will the following boolean expression evaluate to if x = 5 and y = 10?  
boolean result = !(x > 3 && y < 10);

Options:  
A) true  
B) false  
C) x  
D) y  

Correct Answer: A

Option A explanation: Correct. (x > 3 && y < 10) is (true && false), which is false; !false is true.  
Option B explanation: Incorrect. The expression actually evaluates to true, not false.  
Option C explanation: Incorrect. The result is a boolean, not the value of x.  
Option D explanation: Incorrect. The result is a boolean, not the value of y.

Main Explanation: The original expression inside the parentheses is false, so the logical NOT operator (!) changes it to true.

Tags: Control Flow, boolean expressions, Understand",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses understanding of boolean expressions, logical operators (&&, !), and comparison operators—core components of the stated subtopic. All answer options are technically accurate with no ambiguity; options C and D are appropriately implausible distractors. Explanations are clear and trace through the evaluation step-by-step (x > 3 evaluates to true, y < 10 evaluates to false, true && false = false, !false = true). Bloom alignment is strong for ""Understand"" level—students must comprehend operator precedence and semantics rather than merely recall or apply in complex scenarios. The only minor consideration is that this question sits at the higher end of ""Understand"" (approaching ""Apply""), as it requires coordinating multiple operators, but this is appropriate for assessing genuine comprehension rather than superficial knowledge."
4fc3c9f7-0c53-456b-a033-7bfdf7dfb1ad,2025-11-25T07:18:47.730715,Control Flow,boolean expressions,Understand,What is the result of the following boolean expression: !(true && false) || (false == !false) ?,true,false,Compilation error,Runtime exception,A,Correct. The expression evaluates to true.,Incorrect. The expression is not false.,Incorrect. The expression is valid and compiles.,Incorrect. The expression does not cause an exception.,The first part !(true && false) evaluates to true. The second part (false == !false) is also true. true || true results in true.,"Question: What is the result of the following boolean expression: !(true && false) || (false == !false) ?

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: A

Option A explanation: Correct. The expression evaluates to true.
Option B explanation: Incorrect. The expression is not false.
Option C explanation: Incorrect. The expression is valid and compiles.
Option D explanation: Incorrect. The expression does not cause an exception.

Main Explanation: The first part !(true && false) evaluates to true. The second part (false == !false) is also true. true || true results in true.

Tags: Control Flow, boolean expressions, Understand",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses understanding of boolean operators (&&, ||, !, ==) and operator precedence, which are core to boolean expressions. All options are technically accurate with no ambiguity. Explanations are clear and trace through the evaluation step-by-step. The Bloom alignment is strong for ""Understand"" level—students must comprehend how operators work and evaluate expressions, though it borders on ""Apply"" due to requiring multi-step evaluation. The question effectively tests conceptual understanding of boolean logic without being trivial."
f1ffcbd7-f710-438f-908c-1bd239395bb5,2025-11-25T07:18:57.868383,Control Flow,boolean expressions,Apply,"Which value does the following Java boolean expression evaluate to, if x = 7 and y = 3?  
(x > 5) && !(y == 3 || x < 10)",true,false,It results in a compile-time error,It depends on user input,B,"Incorrect. The expression evaluates to false, not true.",Correct. The expression evaluates to false for x = 7 and y = 3.,Incorrect. The syntax is valid and causes no compile-time error.,"Incorrect. The result depends only on the given values, not user input.","(x > 5) is true, but (y == 3 || x < 10) is also true, so its negation is false. true && false evaluates to false.","Question: Which value does the following Java boolean expression evaluate to, if x = 7 and y = 3?  
(x > 5) && !(y == 3 || x < 10)

Options:
A) true
B) false
C) It results in a compile-time error
D) It depends on user input

Correct Answer: B

Option A explanation: Incorrect. The expression evaluates to false, not true.
Option B explanation: Correct. The expression evaluates to false for x = 7 and y = 3.
Option C explanation: Incorrect. The syntax is valid and causes no compile-time error.
Option D explanation: Incorrect. The result depends only on the given values, not user input.

Main Explanation:  
(x > 5) is true, but (y == 3 || x < 10) is also true, so its negation is false. true && false evaluates to false.

Tags: Control Flow, boolean expressions, Apply",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses boolean expressions with logical operators (&&, ||, !) which are core to the subtopic. All answer options are technically accurate with no ambiguity. Explanations are clear and trace through the evaluation step-by-step. The cognitive demand aligns well with ""Apply"" level—students must evaluate a multi-part expression rather than just recall definitions. The only minor consideration is that ""Apply"" could involve slightly more complex scenarios, but this is still solidly at that level."
393f2e2a-97fc-4baf-a126-5ac44efe2a7b,2025-11-25T07:19:06.369825,Control Flow,boolean expressions,Apply,"What is the value of the variable result after executing the following code?

```java
int x = 5, y = 10;
boolean result = (x < y) && !(x == 5 || y < 10);
```",true,false,Compilation error,Runtime exception,B,Incorrect; the boolean expression evaluates to false.,"Correct; the left side is true, but the right side is false, so the result is false.",Incorrect; the code compiles without errors.,Incorrect; there is no runtime exception.,"The left part `(x < y)` is true, but `!(x == 5 || y < 10)` is false since `x == 5` is true. Therefore, the entire expression is `true && false`, resulting in false.","Question: What is the value of the variable result after executing the following code?

```java
int x = 5, y = 10;
boolean result = (x < y) && !(x == 5 || y < 10);
```

Options:
A) true
B) false
C) Compilation error
D) Runtime exception

Correct Answer: B

Option A explanation: Incorrect; the boolean expression evaluates to false.
Option B explanation: Correct; the left side is true, but the right side is false, so the result is false.
Option C explanation: Incorrect; the code compiles without errors.
Option D explanation: Incorrect; there is no runtime exception.

Main Explanation: The left part `(x < y)` is true, but `!(x == 5 || y < 10)` is false since `x == 5` is true. Therefore, the entire expression is `true && false`, resulting in false.

Tags: Control Flow, boolean expressions, Apply",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses boolean expressions and logical operators (&&, ||, !), which are core to the stated subtopic. The code requires students to apply their knowledge by evaluating a multi-part boolean expression with correct operator precedence and short-circuit evaluation understanding. All explanations are accurate and clearly trace through the evaluation steps. The Bloom level is slightly below ""Apply"" in rigor—it's more of a straightforward evaluation task rather than requiring students to apply concepts to solve a novel problem, but it does require active evaluation rather than simple recall. The distractors are well-chosen and address common misconceptions (compilation errors, runtime exceptions, or misunderstanding operator precedence)."
22fc5e36-87a9-47c1-81f4-507dbd2594f7,2025-11-25T07:19:16.505978,Control Flow,boolean expressions,Apply,"Given the following variables, which expression will evaluate to true?

int x = 7, y = 4;
boolean a = false, b = true;",(x < y) && (a || b),(x > y) || (a && b),(x == y) && (a == b),(x < y) || (a && !b),B,Incorrect. (x < y) is false; (a || b) is true. false && true is false.,Correct. (x > y) is true; OR with anything else results in true.,Incorrect. (x == y) is false; AND with anything else is false.,Incorrect. (x < y) is false; (a && !b) is false. false || false is false.,"Only option B uses an OR where one side is true, so the entire expression evaluates to true; all other options evaluate to false.","Question: Given the following variables, which expression will evaluate to true?

int x = 7, y = 4;
boolean a = false, b = true;

Options:
A) (x < y) && (a || b)
B) (x > y) || (a && b)
C) (x == y) && (a == b)
D) (x < y) || (a && !b)

Correct Answer: B

Option A explanation: Incorrect. (x < y) is false; (a || b) is true. false && true is false.
Option B explanation: Correct. (x > y) is true; OR with anything else results in true.
Option C explanation: Incorrect. (x == y) is false; AND with anything else is false.
Option D explanation: Incorrect. (x < y) is false; (a && !b) is false. false || false is false.

Main Explanation: Only option B uses an OR where one side is true, so the entire expression evaluates to true; all other options evaluate to false.

Tags: Control Flow, boolean expressions, Apply",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses boolean expressions and logical operators (&&, ||, !), which are core to the stated subtopic. All explanations are technically accurate with clear step-by-step evaluation. The distractors effectively test common misconceptions about operator precedence and short-circuit evaluation. Bloom alignment is strong at the ""Apply"" level—students must evaluate expressions using their knowledge of boolean logic rather than just recall. The only minor consideration is that ""Apply"" typically involves applying concepts to new situations; this is a fairly standard textbook-style problem, which might suggest it borders between ""Understand"" and ""Apply,"" though evaluating multiple complex expressions does require application of rules."
86d81ba2-ad68-4a2d-9746-00f2af8302e9,2025-11-25T07:19:30.332109,Control Flow,boolean expressions,Analyze,"Given int x = 3, y = 7, z = 5;, which condition correctly checks if x is less than y but greater than z?",(x < y) && (x > z),(x > y) && (x > z),(x < y) || (x > z),(x > y) || (x < z),A,Correct; it uses && to ensure both conditions—x < y and x > z—are met.,"Incorrect; x > y is false, so the expression can't be true.","Incorrect; || means only one condition must be true, not both.",Incorrect; neither condition alone ensures x is between y and z.,"To check if x is less than y and simultaneously greater than z, both boolean expressions must be true, so && is needed to combine them.","Question: Given int x = 3, y = 7, z = 5;, which condition correctly checks if x is less than y but greater than z?

Options:
A) (x < y) && (x > z)
B) (x > y) && (x > z)
C) (x < y) || (x > z)
D) (x > y) || (x < z)

Correct Answer: A

Option A explanation: Correct; it uses && to ensure both conditions—x < y and x > z—are met.
Option B explanation: Incorrect; x > y is false, so the expression can't be true.
Option C explanation: Incorrect; || means only one condition must be true, not both.
Option D explanation: Incorrect; neither condition alone ensures x is between y and z.

Main Explanation: To check if x is less than y and simultaneously greater than z, both boolean expressions must be true, so && is needed to combine them.

Tags: Control Flow, boolean expressions, Analyze",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses boolean expressions and logical operators (&&, ||), which are core to the Control Flow subtopic. All options are technically accurate with clear distinctions between && and || operators. The explanations are concise and educational, addressing why each option is correct or incorrect. The cognitive demand aligns well with ""Analyze"" level—students must evaluate multiple conditions and determine which logical operator correctly combines them. The only minor consideration is that ""Analyze"" typically involves breaking down complex structures; this question is somewhat straightforward once students understand && vs ||, placing it slightly below the highest analytical rigor, though still solidly within the Analyze category."
7430900b-e904-4872-9709-cad798d4fac9,2025-11-25T07:19:41.287542,Control Flow,boolean expressions,Analyze,Which expression correctly determines if an integer x is outside the inclusive range 10 to 20 in Java?,(x < 10 && x > 20),(x < 10 || x > 20),(x <= 10 && x >= 20),(x > 10 || x < 20),B,Incorrect; x cannot be both less than 10 and greater than 20 simultaneously.,Correct; x is outside the range if it is less than 10 or greater than 20.,Incorrect; x cannot be both less than or equal to 10 and greater than or equal to 20 at once.,"Incorrect; this is true for almost all values and does not express ""outside the range"".","The correct boolean expression for determining if x is outside 10 to 20 inclusive is (x < 10 || x > 20), since these two cases encompass all values not within [10, 20].","Question: Which expression correctly determines if an integer x is outside the inclusive range 10 to 20 in Java?

Options:
A) (x < 10 && x > 20)
B) (x < 10 || x > 20)
C) (x <= 10 && x >= 20)
D) (x > 10 || x < 20)

Correct Answer: B

Option A explanation: Incorrect; x cannot be both less than 10 and greater than 20 simultaneously.
Option B explanation: Correct; x is outside the range if it is less than 10 or greater than 20.
Option C explanation: Incorrect; x cannot be both less than or equal to 10 and greater than or equal to 20 at once.
Option D explanation: Incorrect; this is true for almost all values and does not express ""outside the range"".

Main Explanation: The correct boolean expression for determining if x is outside 10 to 20 inclusive is (x < 10 || x > 20), since these two cases encompass all values not within [10, 20].

Tags: Control Flow, boolean expressions, Analyze",Leccture1-java-review.pptx,"13, 9, 14, 10",5,4,5,5,"The question directly assesses boolean expressions and logical operators (AND/OR), which are core to control flow. All explanations are clear and technically accurate. The distractors effectively target common mistakes (confusing AND/OR, incorrect boundary conditions). The cognitive demand aligns well with ""Analyze"" as students must evaluate which logical expression correctly represents the negation of a range condition. The only minor consideration is that this could arguably be slightly lower on Bloom's scale (closer to ""Understand"") since it's somewhat formulaic (negating a range condition), but it does require students to analyze the logical structure and test cases mentally, justifying the ""Analyze"" level."
20e7882c-5492-49e5-acd6-05387ea464cf,2025-11-25T07:19:53.064811,Control Flow,boolean expressions,Analyze,"Given int x = 3, y = 7, z = 5; which boolean expression evaluates to true?",(x > y) && (z < y),(y == z) || (x < z),!(x < y) && (z != x),(x <= z) && (y > z),D,"(x > y) is false and (z < y) is true, but '&&' requires both to be true.","(y == z) is false; (x < z) is true, but '||' means true overall, yet only one is true.","!(x < y) is false; (z != x) is true, but '&&' means the whole is false.","(x <= z) is true and (y > z) is true; both conditions are true, so '&&' yields true.","Option D is correct since both boolean sub-expressions are true, making the entire expression true using the '&&' operator.","Question: Given int x = 3, y = 7, z = 5; which boolean expression evaluates to true?

Options:
A) (x > y) && (z < y)
B) (y == z) || (x < z)
C) !(x < y) && (z != x)
D) (x <= z) && (y > z)

Correct Answer: D

Option A explanation: (x > y) is false and (z < y) is true, but '&&' requires both to be true.
Option B explanation: (y == z) is false; (x < z) is true, but '||' means true overall, yet only one is true.
Option C explanation: !(x < y) is false; (z != x) is true, but '&&' means the whole is false.
Option D explanation: (x <= z) is true and (y > z) is true; both conditions are true, so '&&' yields true.

Main Explanation: Option D is correct since both boolean sub-expressions are true, making the entire expression true using the '&&' operator.

Tags: Control Flow, boolean expressions, Analyze",Leccture1-java-review.pptx,"13, 9, 14, 10",5,3,5,5,"The question directly assesses boolean expressions with logical operators (&&, ||, !), which is core to the stated subtopic. All explanations are accurate and clear. However, the Bloom level is misaligned—this question primarily requires students to EVALUATE/APPLY (Bloom levels 3-4) by substituting values and checking conditions, rather than ANALYZE (Bloom level 4), which would require deeper reasoning about why certain operators behave differently or comparing multiple logical structures. The task is straightforward evaluation of given expressions rather than breaking down complex logical relationships or justifying design choices."
0c93f91d-e3bd-4ff1-a821-857e1111d67e,2025-11-25T07:20:06.272858,Control Flow,boolean expressions,Evaluate,"Given int x = 5, y = 10; which boolean expression accurately determines if exactly one of x or y is greater than 7?",(x > 7) && (y > 7),(x > 7) || (y > 7),(x > 7) ^ (y > 7),!(x > 7) && !(y > 7),C,"Incorrect. This checks if both are greater than 7, not exactly one.",Incorrect. This returns true even if both are greater than 7.,Correct. The XOR (^) operator returns true only if exactly one is true.,Incorrect. This checks if neither is greater than 7.,"The XOR operator (^) evaluates to true only if one, but not both, operands are true, matching the requirement of ""exactly one.""","Question: Given int x = 5, y = 10; which boolean expression accurately determines if exactly one of x or y is greater than 7?

Options:  
A) (x > 7) && (y > 7)  
B) (x > 7) || (y > 7)  
C) (x > 7) ^ (y > 7)  
D) !(x > 7) && !(y > 7)  

Correct Answer: C

Option A explanation: Incorrect. This checks if both are greater than 7, not exactly one.

Option B explanation: Incorrect. This returns true even if both are greater than 7.

Option C explanation: Correct. The XOR (^) operator returns true only if exactly one is true.

Option D explanation: Incorrect. This checks if neither is greater than 7.

Main Explanation: The XOR operator (^) evaluates to true only if one, but not both, operands are true, matching the requirement of ""exactly one.""

Tags: Control Flow, boolean expressions, Evaluate",Leccture1-java-review.pptx,"13, 9, 14, 10",5,3,5,5,"The question directly assesses boolean expressions and logical operators (XOR), which are core to the subtopic. All explanations are technically accurate and clear. However, the Bloom level is misaligned—this question primarily requires students to *understand* and *apply* knowledge of the XOR operator rather than *evaluate* complex scenarios. True evaluation would involve analyzing trade-offs between different approaches or justifying design decisions. The question is well-constructed overall but slightly overrated in cognitive demand."
